[
  {
    "n_arguments": 2,
    "description": "The EnumerateSecurityPackages function returns an array of  SecPkgInfo structures that provide information about the security packages available to the client.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns a nonzero error code. Possible values include, but are not limited to, those in the following table.  ",
    "remarks": "The caller can use the Name member of a SecPkgInfo structure to specify a security package in a call to the  AcquireCredentialsHandle (General) function. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "EnumerateSecurityPackages",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PULONG",
        "name": "pcPackages",
        "description": "A pointer to a ULONG variable that receives the number of packages available on the system. This includes packages that are already loaded and packages available on demand."
      },
      {
        "in_out": "_In_",
        "type": "PSecPkgInfo",
        "name": "*ppPackageInfo",
        "description": "A pointer to a variable that receives a pointer to an array of  SecPkgInfo structures. Each structure contains information from the security support provider (SSP) that describes the capabilities of the security package available within that SSP. When you have finished using the array, free the memory by calling the FreeContextBuffer function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The InitSecurityInterface function returns a pointer to an SSPI dispatch table. This function enables clients to use SSPI without binding directly to an implementation of the interface.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the return value is a pointer to a  SecurityFunctionTable structure. If the function fails, the return value is NULL. ",
    "remarks": "",
    "return_type": "PSecurityFunctionTable SEC_Entry",
    "category": "Authentication",
    "name": "InitSecurityInterface",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves information about a specified security package. This information includes the bounds on sizes of authentication information, credentials, and contexts.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the return value is SEC_E_OK. If the function fails, the return value is a nonzero error code. ",
    "remarks": "The caller must call the  FreeContextBuffer function to free the buffer returned in ppPackageInfo. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "QuerySecurityPackageInfo",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SEC_CHAR",
        "name": "*pszPackageName",
        "description": "Pointer to a null-terminated string that specifies the name of the security package."
      },
      {
        "in_out": "_Out_",
        "type": "PSecPkgInfo",
        "name": "*ppPackageInfo",
        "description": "Pointer to a variable that receives a pointer to a  SecPkgInfo structure containing information about the specified security package."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The AcquireCredentialsHandle (General) function acquires a handle to preexisting credentials of a security principal. This handle is required by the  InitializeSecurityContext (General) and  AcceptSecurityContext (General) functions. These can be either preexisting credentials, which are established through a system logon that is not described here, or the caller can provide alternative credentials.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns one of the following error codes.  ",
    "remarks": "The AcquireCredentialsHandle (General) function returns a handle to the credentials of a principal, such as a user or client, as used by a specific security package. This can be the handle to preexisting credentials, or the function can create a new set of credentials and return it. This handle can be used in subsequent calls to the  AcceptSecurityContext (General) and  InitializeSecurityContext (General) functions. In general, AcquireCredentialsHandle (General) does not allow a process to obtain a handle to the credentials of other users logged on to the same computer. However, a caller with SE_TCB_NAME privilege has the option of specifying the logon identifier (LUID) of any existing logon session token to get a handle to that session's credentials. Typically, this is used by kernel-mode modules that must act on behalf of a logged-on user. A package might call the function in pGetKeyFn provided by the RPC run-time transport. If the transport does not support the notion of callback to retrieve credentials, this parameter must be NULL. For kernel mode callers, the following differences must be noted: When you have finished using the returned credentials, free the memory used by the credentials by calling the  FreeCredentialsHandle function. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "AcquireCredentialsHandle (General)",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SEC_CHAR",
        "name": "*pszPrincipal",
        "description": "A pointer to a null-terminated string that specifies the name of the principal whose credentials the handle will reference. When using the Digest SSP, this parameter is optional. When using the Schannel SSP, this parameter is not used and should be set to NULL. Note  If the process that requests the handle does not have access to the credentials, the function returns an error. A null string indicates that the process requires a handle to the credentials of the user under whose security context it is executing."
      },
      {
        "in_out": "_In_",
        "type": "SEC_CHAR",
        "name": "*pszPackage",
        "description": "A pointer to a null-terminated string that specifies the name of the security package with which these credentials will be used. This is a security package name returned in the Name member of a  SecPkgInfo structure returned by the  EnumerateSecurityPackages function. After a context is established,  QueryContextAttributes (General) can be called with ulAttribute set to SECPKG_ATTR_PACKAGE_INFO to return information on the security package in use. When using the Digest SSP, set this parameter to WDIGEST_SP_NAME. When using the Schannel SSP, set this parameter to UNISP_NAME."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "fCredentialUse",
        "description": "A flag that indicates how these credentials will be used. This parameter can be one of the following values.  ValueMeaning  SECPKG_CRED_AUTOLOGON_RESTRICTED 0x00000010   The security does not use default logon credentials or credentials from Credential Manager. This value is supported only by the Negotiate security package. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   SECPKG_CRED_BOTH   Validate an incoming credential or use a local credential to prepare an outgoing token. This flag enables both other flags. This flag is not valid with the Digest and Schannel SSPs.   SECPKG_CRED_INBOUND   Validate an incoming server credential. Inbound credentials might be validated by using an authenticating authority when InitializeSecurityContext (General) or AcceptSecurityContext (General) is called. If such an authority is not available, the function will fail and return SEC_E_NO_AUTHENTICATING_AUTHORITY. Validation is package specific.   SECPKG_CRED_OUTBOUND   Allow a local client credential to prepare an outgoing token.   SECPKG_CRED_PROCESS_POLICY_ONLY 0x00000020   The function processes server policy and returns SEC_E_NO_CREDENTIALS, indicating that the application should prompt for credentials. This value is supported only by the Negotiate security package. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported."
      },
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "pvLogonID",
        "description": "A pointer to a  locally unique identifier (LUID) that identifies the user. This parameter is provided for file-system processes such as network redirectors. This parameter can be NULL. When using the Schannel SSP, this parameter is not used and should be set to NULL."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pAuthData",
        "description": "A pointer to package-specific data. This parameter can be NULL, which indicates that the default credentials for that package must be used. To use supplied credentials, pass a SEC_WINNT_AUTH_IDENTITY structure that includes those credentials in this parameter. The RPC run time passes whatever was provided in  RpcBindingSetAuthInfo. When using the Digest SSP, this parameter is  a  pointer to  a SEC_WINNT_AUTH_IDENTITY structure that contains authentication information to use to locate the credentials. When using the Schannel SSP, specify an  SCHANNEL_CRED structure that indicates the protocol to use and the settings for various customizable channel features.  When using the NTLM or Negotiate packages, the maximum character lengths for user name, password, and domain are 256, 256, and 15, respectively."
      },
      {
        "in_out": "_In_",
        "type": "SEC_GET_KEY_FN",
        "name": "pGetKeyFn",
        "description": "This parameter is not used  and should be set to NULL."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pvGetKeyArgument",
        "description": "This parameter is not used and should be set to NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PCredHandle",
        "name": "phCredential",
        "description": "A pointer to a CredHandle structure to receive the credential handle."
      },
      {
        "in_out": "_Out_",
        "type": "PTimeStamp",
        "name": "ptsExpiry",
        "description": "A pointer to a TimeStamp structure that receives the time at which the returned credentials expire. The value returned in this TimeStamp structure depends on the security package. The security package must return this value in local time. This parameter is set to a constant maximum time. There is no expiration time for Digest security contexts or credentials or when using the Digest SSP. When using the Schannel SSP, this parameter is optional. When the credential to be used for authentication is a certificate, this parameter receives the expiration time for that certificate. If no certificate was supplied, then a maximum time value is returned."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The ExportSecurityContext function creates a serialized representation of a security context that can later be imported into a different process by calling   ImportSecurityContext. The process that imports the security context must be running on the same computer as the process that called ExportSecurityContext.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns one of the following error codes.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "ExportSecurityContext",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle of the security context to be exported."
      },
      {
        "in_out": "_In_",
        "type": "Ulong",
        "name": "fFlags",
        "description": "This parameter can be a bitwise-OR combination of the following values.  ValueMeaning  SECPKG_CONTEXT_EXPORT_RESET_NEW 1 (0x1)   The new security context is reset to its initial state.   SECPKG_CONTEXT_EXPORT_DELETE_OLD 2 (0x2)   The old security context is deleted.   SECPKG_CONTEXT_EXPORT_TO_KERNEL 4 (0x4)   This value is not supported.  Windows Server 2003 and Windows XP/2000:  The security context is to be exported to the kernel.This value is supported only in Schannel kernel mode."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "pPackedContext",
        "description": "A pointer to a buffer of type SECBUFFER_EMPTY that receives the serialized security context. When you have finished using this context,  free it by calling the  FreeContextBuffer function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "HANDLE",
        "name": "*pToken",
        "description": "A pointer to receive the handle of the context's token. When you have finished using the user token, release the handle by calling the CloseHandle function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The FreeCredentialsHandle function notifies the security system that the credentials are no longer needed. An application calls this function to free the credential handle acquired in the call to the  AcquireCredentialsHandle (General) function after calling the DeleteSecurityContext function to free any context handles associated with the credential. When all references to this credential set have been removed, the credentials themselves can be removed.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns the following error code.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "FreeCredentialsHandle",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCredHandle",
        "name": "phCredential",
        "description": "A pointer to the CredHandle handle obtained by using the  AcquireCredentialsHandle (General) function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The ImportSecurityContext function imports a security context. The security context must have been exported to the process calling ImportSecurityContext by a previous call to ExportSecurityContext.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns one of the following error codes.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "ImportSecurityContext",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_STRING",
        "name": "*pszPackage",
        "description": "A string that contains the name of the security package to which the security context was exported."
      },
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "pPackedContext",
        "description": "A pointer to a buffer that contains the serialized security context created by ExportSecurityContext."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "pToken",
        "description": "A handle to the context's token."
      },
      {
        "in_out": "_Out_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle of the new security context created from pPackedContext. When you have finished using the context, delete it by calling the  DeleteSecurityContext function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the attributes of a credential, such as the name associated with the credential. The information is valid for any security context created with the specified credential.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the return value is SEC_E_OK. If the function fails, the return value may be one of the following error codes.  ",
    "remarks": "The QueryCredentialsAttributes function allows an application to determine several characteristics of a credential, including the name associated with the specified credentials. Querying the SECPKG_ATTR_CIPHER_STRENGTHS attribute returns a  SecPkgCred_CipherStrengths structure. The cipher strength in this structure is the same as the cipher strength in the  SCHANNEL_CRED structure used when a credential was created. Querying the SECPKG_ATTR_SUPPORTED_ALGS attribute returns a  SecPkgCred_SupportedAlgs structure. The algorithms in this structure are compatible with those indicated in the SCHANNEL_CRED structure used when a credential was created. Querying the SECPKG_ATTR_SUPPORTED_PROTOCOLS attribute returns a  SecPkgCred_SupportedProtocols structure that contains a bit array compatible with the grbitEnabledProtocols field of the SCHANNEL_CRED structure. The caller must allocate the structure pointed to by the pBuffer parameter. The security package allocates the buffer for any pointer returned in the pBuffer structure. The caller can call the  FreeContextBuffer function to free any pointers allocated by the security package. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "QueryCredentialsAttributes",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCredHandle",
        "name": "phCredential",
        "description": "A handle of the credentials to be queried."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulAttribute",
        "description": "Specifies the attribute to query. This parameter can be any of the following attributes.      \t\t\t\t\t  ValueMeaning   SECPKG_CRED_ATTR_CERT   Returns the certificate thumbprint in a pbuffer of type SecPkgCredentials_Cert. This attribute is only supported by Kerberos. Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This attribute is not available.    SECPKG_CRED_ATTR_NAMES   Returns the name of a credential in a pbuffer of type SecPkgCredentials_Names. This attribute is not supported by Schannel in WOW64 mode.    SECPKG_ATTR_SUPPORTED_ALGS   Returns the supported algorithms in a pbuffer of type SecPkgCred_SupportedAlgs. All supported algorithms are included, regardless of whether they are supported by the provided certificate or enabled on the local computer. This attribute is supported only by Schannel.    SECPKG_ATTR_CIPHER_STRENGTHS   Returns the cipher strengths in a pbuffer of type SecPkgCred_CipherStrengths. This attribute is supported only by Schannel.    SECPKG_ATTR_SUPPORTED_PROTOCOLS   Returns the supported algorithms in a pbuffer of type SecPkgCred_SupportedProtocols. All supported protocols are included, regardless of whether they are supported by the provided certificate or enabled on the local computer. This attribute is supported only by Schannel."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "pBuffer",
        "description": "A pointer to a buffer that receives the requested attribute. The type of structure returned depends on the value of ulAttribute."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The AcceptSecurityContext (General) function enables the server component of a transport application to establish a security context between the server and a remote client. The remote client uses the  InitializeSecurityContext (General) function to start the process of establishing a security context. The server can require one or more reply tokens from the remote client to complete establishing the security context.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "This function returns one of the following values.  ",
    "remarks": "The AcceptSecurityContext (General) function is the server counterpart to the  InitializeSecurityContext (General) function. When the server receives a request from a client, the server uses the fContextReq parameter to specify what it requires of the session. In this fashion, a server can specify that clients must be capable of using a confidential or integrity-checked session, and it can reject clients that cannot meet that demand. Alternatively, a server can require nothing, and whatever the client can provide or requires is returned in the pfContextAttr parameter. For a package that supports multiple-leg authentication, such as mutual authentication, the calling sequence is as follows: The fContextReq and pfContextAttr parameters are bitmasks that represent various context attributes. For a description of the various attributes, see  Context Requirements. The caller is responsible for determining whether the final context attributes are sufficient. If, for example, confidentiality (encryption) was requested, but could not be established, some applications may choose to shut down the connection immediately. If the security context cannot be established, the server must free the partially created context by calling the DeleteSecurityContext function. For information about when to call the DeleteSecurityContext function, see DeleteSecurityContext. After the security context has been established, the server application can use the QuerySecurityContextToken function to retrieve a handle to the user account to which the client certificate was mapped. Also, the server can use the ImpersonateSecurityContext function to impersonate the user. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "AcceptSecurityContext (General)",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PCredHandle",
        "name": "phCredential",
        "description": "A handle to the credentials of the server. The server calls the  AcquireCredentialsHandle (General) function with either the SECPKG_CRED_INBOUND or SECPKG_CRED_BOTH flag set to retrieve this handle."
      },
      {
        "in_out": "_Inout_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A pointer to a  CtxtHandle structure. On the first call to AcceptSecurityContext (General), this pointer is NULL. On subsequent calls, phContext is the handle to the partially formed context that was returned in the phNewContext parameter by the first call."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSecBufferDesc",
        "name": "pInput",
        "description": "A pointer to a  SecBufferDesc structure generated by a client call to  InitializeSecurityContext (General) that contains the input buffer descriptor. When using the Schannel SSP, the first buffer must be of type SECBUFFER_TOKEN and contain the security token received from the client. The second buffer should be of type SECBUFFER_EMPTY. When using the Negotiate, Kerberos, or NTLM SSPs, channel binding information can be specified by passing in a SecBuffer structure of type SECBUFFER_CHANNEL_BINDINGS in addition to the buffers generated by the call to the InitializeSecurityContext (General) function. The channel binding information for the channel binding buffer can be obtained by calling the QueryContextAttributes (Schannel) function on the Schannel context the client used to authenticate."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "fContextReq",
        "description": "Bit flags that specify the attributes required by the server to establish the context. Bit flags can be combined by using bitwise-OR operations. This parameter can be one or more of the following values.  ValueMeaning  ASC_REQ_ALLOCATE_MEMORY   Digest and Schannel will allocate output buffers for you. When you have finished using the output buffers, free them  by calling the FreeContextBuffer function.   ASC_REQ_ALLOW_MISSING_BINDINGS   Indicates that Digest does not require channel bindings for both inner and outer channels. This value is used for backward compatibility when support for endpoint channel binding is not known.  This value is mutually exclusive with ASC_REQ_PROXY_BINDINGS. This value is supported only by the Digest SSP.  Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   ASC_REQ_CONFIDENTIALITY   Encrypt and decrypt messages.  The Digest SSP supports this flag for SASL only.   ASC_REQ_CONNECTION   The security context will not handle formatting messages.   ASC_REQ_DELEGATE   The server is allowed to impersonate the client. Valid for Kerberos. Ignore this flag for constrained delegation.   ASC_REQ_EXTENDED_ERROR   When errors occur, the remote party will be notified.   ASC_REQ_HTTP (0x10000000)   Use Digest for HTTP. Omit this flag to use Digest as an SASL mechanism.   ASC_REQ_INTEGRITY   Sign messages and verify signatures. Schannel does not support this flag.   ASC_REQ_MUTUAL_AUTH   The client is required to supply a certificate to be used for client authentication. This flag is supported only by Schannel.   ASC_REQ_PROXY_BINDINGS   Indicates that Digest requires channel binding.  This value is mutually exclusive with ASC_REQ_ALLOW_MISSING_BINDINGS. This value is supported only by the Digest SSP.  Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   ASC_REQ_REPLAY_DETECT   Detect replayed packets.   ASC_REQ_SEQUENCE_DETECT   Detect messages received out of sequence.   ASC_REQ_STREAM   Support a stream-oriented connection. This flag is supported only by Schannel.      For possible attribute flags and their meanings, see  Context Requirements. Flags used for this parameter are prefixed with ASC_REQ, for example, ASC_REQ_DELEGATE. The requested attributes may not be supported by the client. For more information, see the pfContextAttr parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TargetDataRep",
        "description": "The data representation, such as byte ordering, on the target. This parameter can be either SECURITY_NATIVE_DREP or SECURITY_NETWORK_DREP. This parameter is not used with Schannel or Digest SSPs.  When you use Schannel or Digest SSPs, specify zero for this parameter."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PCtxtHandle",
        "name": "phNewContext",
        "description": "A pointer to a CtxtHandle structure. On the first call to AcceptSecurityContext (General), this pointer receives the new context handle. On subsequent calls, phNewContext can be the same as the handle specified in the phContext parameter."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PSecBufferDesc",
        "name": "pOutput",
        "description": "A pointer to a  SecBufferDesc structure that contains the output buffer descriptor. This buffer is sent to the client for input into additional calls to InitializeSecurityContext (General). An output buffer may be generated even if the function returns SEC_E_OK. Any buffer generated must be sent back to the client application. When using Schannel, on output, this buffer receives a token for the security context. The token must be sent to the client. The function can also return a buffer of type SECBUFFER_EXTRA. In addition, the caller must pass in a buffer of type SECBUFFER_ALERT. On output, if an alert is generated, this buffer  contains information about that alert, and the function fails."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pfContextAttr",
        "description": "A pointer to a variable that receives a set of bit flags that indicate the attributes of the established context. For a description of the various attributes, see  Context Requirements. Flags used for this parameter are prefixed with ASC_RET, for example, ASC_RET_DELEGATE. Do not check for security-related attributes until the final function call returns successfully. Attribute flags not related to security, such as the ASC_RET_ALLOCATED_MEMORY flag, can be checked before the final return."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PTimeStamp",
        "name": "ptsTimeStamp",
        "description": "A pointer to a TimeStamp structure that receives the expiration time of the context. We recommend that the security package always return this value in local time. This parameter is set to a constant maximum time. There is no expiration time for Digest security contexts or credentials or when using the Digest SSP. This is optional when using the Schannel SSP. When the remote party has supplied a certificate to be used for authentication, this parameter receives the expiration time for that certificate. If no certificate was supplied, a maximum time value is returned. Note  Until the last call of the authentication process, the expiration time for the context can be incorrect because more information will be provided during later stages of the negotiation. Therefore, ptsTimeStamp must be NULL until the last call to the function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The ApplyControlToken function provides a way to apply a control token to a security context. A token can be received when the security context is being established by a call to  the InitializeSecurityContext (Schannel) function or with a per-message security service, such as verify or unseal.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns a nonzero error code. The following error code is one of the possible error codes that can be returned.  ",
    "remarks": "The ApplyControlToken function can modify the context based on this token. Among the tokens that this function can add to the client context are SCHANNEL_ALERT_TOKEN and SCHANNEL_SESSION_TOKEN. This function can be used to shut down the security context that underlies an existing Schannel connection. For information about how to do this, see Shutting Down an Schannel Connection. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "ApplyControlToken",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle to the context to which the token is applied. For information about the way the Schannel SSP notifies the remote party of the shutdown, see the Remarks section of DecryptMessage (Schannel). For additional information on the use of this function, see  Shutting Down an Schannel Connection."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "pInput",
        "description": "A pointer to a  SecBufferDesc structure that contains a pointer to a  SecBuffer structure that contains the input token to apply to the context."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CompleteAuthToken function completes an authentication token. This function is used by protocols, such as DCE, that need to revise the security information after the transport application has updated some message parameters.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns one of the following error codes.  ",
    "remarks": "The client of a transport application calls the CompleteAuthToken function to allow the security package to update a checksum or similar operation after all the protocol headers have been updated by the transport application. The client calls this function only if the  InitializeSecurityContext (Digest) call returned SEC_I_COMPLETE_NEEDED or SEC_I_COMPLETE_AND_CONTINUE. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "CompleteAuthToken",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle of the context that needs to be completed."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "pToken",
        "description": "A pointer to a  SecBufferDesc structure that contains the buffer descriptor for the entire message."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The DeleteSecurityContext function deletes the local data structures associated with the specified security context initiated by a previous call to the InitializeSecurityContext (General) function or the AcceptSecurityContext (General) function.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds or the handle has already been deleted, the return value is SEC_E_OK. If the function fails, the return value can be the following error code.  ",
    "remarks": "The DeleteSecurityContext function terminates a security context and frees associated resources. The caller must call this function for a security context when that security context is no longer needed. This is true if the security context is partial, incomplete, rejected, or failed. After the security context is successfully deleted, further use of that security context is not permitted and the handle is no longer valid. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "DeleteSecurityContext",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "Handle of the security context to delete."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The FreeContextBuffer function enables callers of security package functions to free memory buffers allocated by the security package.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "Memory buffers are typically allocated by the  InitializeSecurityContext (General) and AcceptSecurityContext (General) functions. The FreeContextBuffer function can free any memory allocated by a security package. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "FreeContextBuffer",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pvContextBuffer",
        "description": "A pointer to memory to be freed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The ImpersonateSecurityContext function allows a server to impersonate a client by using a token previously obtained by a call to AcceptSecurityContext (General) or QuerySecurityContextToken. This function allows the application server to act as the client, and thus all necessary access controls are enforced.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns the following error code.  ",
    "remarks": "The server application calls the ImpersonateSecurityContext function when it needs to impersonate the client. Before doing so, the server must have obtained a valid context handle. To obtain the context handle, the server must call  AcceptSecurityContext (General) to submit the client's incoming security token to the security system. The server gets a context handle if the inbound context is validated. The function creates an impersonation token and allows the thread or process to run with the impersonation context. When using the Schannel security support provider (SSP), the server application must pass the ASC_REQ_MUTUAL_AUTH flag when calling AcceptSecurityContext (General). This ensures that the client is asked for a client certificate during the SSL/TLS handshake. When a client certificate is received, the Schannel package verifies the client certificate and attempts to map it to a user account. When this mapping is successful, then a client user token is created and this function succeeds. The application server must call the  RevertSecurityContext function when it finishes or when it needs to restore its own security context. ImpersonateSecurityContext is not available with all security packages on all platforms. Typically, it is implemented only on platforms and with security packages that support impersonation. To learn whether a security package supports impersonation, call the  QuerySecurityPackageInfo function. All impersonate functions, including ImpersonateSecurityContext allow the requested impersonation if one of the following is true: Windows XP with SP1 and earlier:  The SeImpersonatePrivilege privilege is not supported. Windows XP:  The SeImpersonatePrivilege privilege is not supported until Windows XP with Service Pack 2 (SP2). ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "ImpersonateSecurityContext",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "The handle of the context to impersonate. This handle must have been obtained by a call to the  AcceptSecurityContext (General) function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "The InitializeSecurityContext (General) function initiates the client side, outbound security context from a credential handle. The function is used to build a security context between the client application and a remote peer. InitializeSecurityContext (General) returns a token that the client must pass to the remote peer, which the peer in turn submits to the local security implementation through the  AcceptSecurityContext (General) call. The token generated should be considered opaque by all callers.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns one of the following success codes.  If the function fails, the function returns one of the following error codes.  ",
    "remarks": "The caller is responsible for determining whether the final context attributes are sufficient. If, for example, confidentiality was requested, but could not be established, some applications may choose to shut down the connection immediately. If attributes of the security context are not sufficient, the client must free the partially created context by calling the  DeleteSecurityContext function. The InitializeSecurityContext (General) function is used by a client to initialize an outbound context. For a two-leg security context, the calling sequence is as follows: For multiple-leg security contexts, such as mutual authentication, the calling sequence is as follows: If the server has successfully responded, the security package returns SEC_E_OK and a secure session is established. If the function returns one of the error responses, the server's response is not accepted, and the session is not established. If the function returns SEC_I_CONTINUE_NEEDED, SEC_I_COMPLETE_NEEDED, or SEC_I_COMPLETE_AND_CONTINUE, steps 2 and 3 are repeated. To initialize a security context, more than one call to this function may be required, depending on the underlying authentication mechanism as well as the choices specified in the fContextReq parameter. The fContextReq and pfContextAttributes parameters are bitmasks that represent various context attributes. For a description of the various attributes, see  Context Requirements. The pfContextAttributes parameter is valid on any successful return, but only on the final successful return should you examine the flags that pertain to security aspects of the context. Intermediate returns can set, for example, the ISC_RET_ALLOCATED_MEMORY flag. If the ISC_REQ_USE_SUPPLIED_CREDS flag is set, the security package must look for a SECBUFFER_PKG_PARAMS buffer type in the pInput input buffer. This is not a generic solution, but it allows for a strong pairing of security package and application when appropriate. If ISC_REQ_ALLOCATE_MEMORY was specified, the caller must free the memory by calling the  FreeContextBuffer function. For example, the input token could be the challenge from a LAN Manager. In this case, the output token would be the NTLM-encrypted response to the challenge. The action the client takes depends on the return code from this function. If the return code is SEC_E_OK, there will be no second InitializeSecurityContext (General) call, and no response from the server is expected. If the return code is SEC_I_CONTINUE_NEEDED, the client expects a token in response from the server and passes it in a second call to InitializeSecurityContext (General). The SEC_I_COMPLETE_NEEDED return code indicates that the client must finish building the message and call the CompleteAuthToken function. The SEC_I_COMPLETE_AND_CONTINUE code incorporates both of these actions. If InitializeSecurityContext (General) returns success on the first (or only) call, then the caller must eventually call the DeleteSecurityContext function on the returned handle, even if the call fails on a later leg of the authentication exchange. The client may call InitializeSecurityContext (General) again after it has completed successfully. This indicates to the security package that a reauthentication is wanted. Kernel mode callers have the following differences: the target name is a Unicode string that must be allocated in virtual memory by using VirtualAlloc; it must not be allocated from the pool. Buffers passed and supplied in pInput and pOutput must be in virtual memory, not in the pool. When using the Schannel SSP, if the function returns SEC_I_INCOMPLETE_CREDENTIALS, check that you specified a valid and trusted certificate in your credentials. The certificate is specified when calling the AcquireCredentialsHandle (General) function. The certificate must be a client authentication certificate issued by a certification authority (CA) trusted by the server. To obtain a list of the CAs trusted by the server, call the QueryContextAttributes (General) function and specify the SECPKG_ATTR_ISSUER_LIST_EX attribute. When using the Schannel SSP, after a client application receives an authentication certificate from a CA that is trusted by the server, the application  creates a new credential by calling the AcquireCredentialsHandle (General) function and then calling InitializeSecurityContext (General) again, specifying the new credential in the phCredential parameter. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "InitializeSecurityContext (General)",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PCredHandle",
        "name": "phCredential",
        "description": "A handle to the credentials returned by  AcquireCredentialsHandle (General). This handle is used to build the security context. The InitializeSecurityContext (General) function requires at least OUTBOUND credentials."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A pointer to a CtxtHandle structure. On the first call to InitializeSecurityContext (General), this pointer is NULL. On the second call, this parameter is a pointer to the handle to the partially formed context returned in the phNewContext parameter by the first call. This parameter is optional with the Microsoft Digest SSP and can be set to NULL. When using the Schannel SSP, on the first call to InitializeSecurityContext (General), specify NULL. On future calls, specify the token received in the phNewContext parameter after the first call to this function."
      },
      {
        "in_out": "_In_opt_",
        "type": "SEC_CHAR",
        "name": "*pszTargetName",
        "description": "A pointer to a null-terminated string that indicates the target of the context. The string contents are security-package specific, as described in the following table. This list is not exhaustive. Additional system SSPs and third party SSPs can be added to a system.  SSP in useMeaning  Digest    Null-terminated string that uniquely identifies the URI of the requested resource. The string must be composed of characters that are allowed in a URI and must be representable by  the US ASCII code set.  Percent encoding can be used to represent characters outside the US ASCII code set.   Kerberos or Negotiate    Service principal name (SPN) or the security context of the destination server.   NTLM    Service principal name (SPN) or the security context of the destination server.   Schannel/SSL    Null-terminated string that uniquely identifies the target server. Schannel uses this value to verify the server certificate. Schannel also uses this value to locate the session in the session cache when reestablishing a connection. The cached session is used only if all of the following conditions are met: The target name is the same. The cache entry has not expired. The application process that calls the function is the same. The logon session is the same. The credential handle is the same."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "fContextReq",
        "description": "Bit flags that indicate requests for the context. Not all packages can support all requirements. Flags used for this parameter are prefixed with ISC_REQ_, for example,  ISC_REQ_DELEGATE. This parameter can be one or more of the following attributes flags.  ValueMeaning  ISC_REQ_ALLOCATE_MEMORY   The security package allocates output buffers for you. When you have finished using the output buffers, free them by calling the   FreeContextBuffer function.   ISC_REQ_CONFIDENTIALITY   Encrypt messages by using the EncryptMessage function.   ISC_REQ_CONNECTION   The security context will not handle formatting messages. This value is the default for the Kerberos, Negotiate, and NTLM security packages.   ISC_REQ_DELEGATE   The server can use the context to authenticate to other servers as the client. The ISC_REQ_MUTUAL_AUTH flag must be set for this flag to work. Valid for Kerberos. Ignore this flag for constrained delegation.   ISC_REQ_EXTENDED_ERROR   When errors occur, the remote party will be notified.   ISC_REQ_HTTP   Use Digest for HTTP. Omit this flag to use Digest as a SASL mechanism.   ISC_REQ_INTEGRITY   Sign messages and verify signatures by using the EncryptMessage and MakeSignature functions.   ISC_REQ_MANUAL_CRED_VALIDATION   Schannel must not authenticate the server automatically.   ISC_REQ_MUTUAL_AUTH   The mutual authentication policy of the service will be satisfied. Caution  This does not necessarily mean that mutual authentication is performed, only that the authentication policy of the service is satisfied. To ensure that mutual authentication is performed, call the QueryContextAttributes (General) function.     ISC_REQ_NO_INTEGRITY   If this flag is set, the ISC_REQ_INTEGRITY flag is ignored. This value is supported only by the Negotiate and Kerberos security packages.   ISC_REQ_REPLAY_DETECT   Detect replayed messages that have been encoded by using the EncryptMessage or MakeSignature functions.   ISC_REQ_SEQUENCE_DETECT   Detect messages received out of sequence.   ISC_REQ_STREAM   Support a stream-oriented connection.   ISC_REQ_USE_SESSION_KEY   A new session key must be negotiated. This value is supported only by the Kerberos security package.   ISC_REQ_USE_SUPPLIED_CREDS   Schannel must not attempt to supply credentials for the client automatically.     The requested attributes may not be supported by the client. For more information, see the pfContextAttr parameter. For  further descriptions of the various attributes, see  Context Requirements."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Reserved1",
        "description": "This parameter is reserved and must be set to zero."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TargetDataRep",
        "description": "The data representation, such as byte ordering, on the target. This parameter can be either SECURITY_NATIVE_DREP or SECURITY_NETWORK_DREP. This parameter is not used with Digest or Schannel. Set it to zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSecBufferDesc",
        "name": "pInput",
        "description": "A pointer to a  SecBufferDesc structure that contains pointers to the buffers supplied as input to the package. Unless the client context was initiated by the server, the value of this parameter must be NULL on the first call to the function. On subsequent calls to the function or when the client context was initiated by the server, the value of this parameter is a pointer to a buffer allocated with enough memory to hold the token returned by the remote computer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Reserved2",
        "description": "This parameter is reserved and must be set to zero."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PCtxtHandle",
        "name": "phNewContext",
        "description": "A pointer to a  CtxtHandle structure. On the first call to InitializeSecurityContext (General), this pointer receives the new context handle. On the second call, phNewContext can be the same as the handle specified in the phContext parameter. When using the Schannel SSP,  on calls after the first call, pass the  handle returned here as the phContext parameter and specify NULL for phNewContext."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PSecBufferDesc",
        "name": "pOutput",
        "description": "A pointer to a  SecBufferDesc structure that contains pointers to the  SecBuffer structure that receives the output data. If a buffer was typed as SEC_READWRITE in the input, it will be there on output. The system will allocate a buffer for the security token if requested (through ISC_REQ_ALLOCATE_MEMORY) and fill in the address in the buffer descriptor for the security token. When using the Microsoft Digest SSP,  this parameter receives the challenge response that must be sent to the server. When using the Schannel SSP, if the ISC_REQ_ALLOCATE_MEMORY flag is specified, the Schannel SSP will allocate memory for  the buffer and put the appropriate information in the SecBufferDesc. In addition, the caller must pass in a buffer of type SECBUFFER_ALERT. On output, if an alert is generated, this buffer  contains information about that alert, and the function fails."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pfContextAttr",
        "description": "A pointer to a variable to receive a set of bit flags that indicate the attributes of the established context. For a description of the various attributes, see  Context Requirements.  Flags used for this parameter are prefixed with ISC_RET, such as ISC_RET_DELEGATE.     For a list of valid values, see the fContextReq parameter. Do not check for security-related attributes until the final function call returns successfully. Attribute flags that are not related to security, such as the ASC_RET_ALLOCATED_MEMORY flag, can be checked before the final return. Note  Particular context attributes can change during negotiation with a remote peer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PTimeStamp",
        "name": "ptsExpiry",
        "description": "A pointer to a TimeStamp structure that receives the expiration time of the context. It is recommended that the security package always return this value in local time. This parameter is optional and NULL should be passed for short-lived clients. There is no expiration time for Microsoft Digest SSP security contexts or credentials."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Enables a transport application to query a security package for certain attributes of a security context.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the return value is SEC_E_OK. If the function fails, the return value is a nonzero error code. ",
    "remarks": "The structure pointed to by the pBuffer parameter varies depending on the attribute being queried. The caller must allocate the pBuffer structure itself, but the SSP allocates any memory required to hold variable sized members of the pBuffer structure. Memory allocated by the SSP can be freed by calling the FreeContextBuffer function. After the SECPKG_ATTR_REMOTE_CERT_CONTEXT or SECPKG_ATTR_LOCAL_CERT_CONTEXT value has been read, the hCertStore member will be set to a handle to a certificate store that contains the intermediate certificates, if any. Also, the application is responsible for calling CertFreeCertificateContext to release the memory used by the certificate context. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "QueryContextAttributes (General)",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle to the security context to be queried."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulAttribute",
        "description": "Specifies the attribute of the context to be returned. This parameter can be one of the following values.  ValueMeaning  SECPKG_ATTR_ACCESS_TOKEN 18   The pBuffer parameter contains a pointer to a SecPkgContext_AccessToken structure. Returns a handle to the access token.   SECPKG_ATTR_APP_DATA 0x5e   The pBuffer parameter contains a pointer to a SecPkgContext_SessionAppData structure. Returns or specifies application data for the session. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_AUTHORITY 6   The pBuffer parameter contains a pointer to a SecPkgContext_Authority structure. Queries the name of the authenticating authority.   SECPKG_ATTR_CLIENT_SPECIFIED_TARGET 27   The pBuffer parameter contains a pointer to a SecPkgContext_ClientSpecifiedTarget structure that represents the service principal name (SPN) of the initial target supplied by the client.  Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   SECPKG_ATTR_CONNECTION_INFO 0x5a   The pBuffer parameter contains a pointer to a SecPkgContext_ConnectionInfo structure. Returns detailed information on the established connection. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_CREDS_2 0x80000086   The pBuffer parameter contains a pointer to a SecPkgContext_ClientCreds structure that specifies client credentials.  If the client credential is user name and password, the buffer is a packed KERB_INTERACTIVE_LOGON structure. If the client credential is user name and smart card PIN, the buffer is a packed \tKERB_CERTIFICATE_LOGON structure. If the client credential is an online identity credential, the buffer is a marshaled SEC_WINNT_AUTH_IDENTITY_EX2 structure. This attribute is supported only on the CredSSP server. Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   SECPKG_ATTR_DCE_INFO 3   The pBuffer parameter contains a pointer to a SecPkgContext_DceInfo structure. Queries for authorization data used by DCE services.   SECPKG_ATTR_ENDPOINT_BINDINGS 26   The pBuffer parameter contains a pointer to a SecPkgContext_Bindings structure that specifies channel binding information. This attribute is supported only by the Schannel security package. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   SECPKG_ATTR_EAP_KEY_BLOCK 0x5b   The pBuffer parameter contains a pointer to a SecPkgContext_EapKeyBlock structure. Queries for key data used by the EAP TLS protocol. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_FLAGS 14   The pBuffer parameter contains a pointer to a SecPkgContext_Flags structure. Returns information about the negotiated context flags.   SECPKG_ATTR_ISSUER_LIST_EX 0x59   The pBuffer parameter contains a pointer to a SecPkgContext_IssuerListInfoEx structure. Returns a list of certificate issuers that are accepted by the server. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_KEY_INFO 5   The pBuffer parameter contains a pointer to a SecPkgContext_KeyInfo structure. Queries information about the keys used in a security context.   SECPKG_ATTR_LAST_CLIENT_TOKEN_STATUS 30   The pBuffer parameter contains a pointer to a SecPkgContext_LastClientTokenStatus structure that specifies whether the token from the most recent call to the InitializeSecurityContext function is the last token from the client. This value is supported only by the Negotiate, Kerberos, and NTLM security packages. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   SECPKG_ATTR_LIFESPAN 2   The pBuffer parameter contains a pointer to a SecPkgContext_Lifespan structure.  \t\t\t\t\t\t\t\t\tQueries the life span of the context.   SECPKG_ATTR_LOCAL_CERT_CONTEXT 0x54   The pBuffer parameter contains a pointer to a PCCERT_CONTEXT \t\t\t\t\t\t\tstructure. Finds a certificate context that contains a local end certificate. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_LOCAL_CRED   The pBuffer parameter contains a pointer to a SecPkgContext_LocalCredentialInfo structure. (obsolete) Superseded by SECPKG_ATTR_LOCAL_CERT_CONTEXT.   SECPKG_ATTR_NAMES 1   The pBuffer parameter contains a pointer to a SecPkgContext_Names structure. Queries the name associated with the context.   SECPKG_ATTR_NATIVE_NAMES 13   The pBuffer parameter contains a pointer to a SecPkgContext_NativeNames structure. Returns the principal name (CNAME) from the outbound ticket.   SECPKG_ATTR_NEGOTIATION_INFO 12   The pBuffer parameter contains a pointer to a SecPkgContext_NegotiationInfo structure. Returns information about the security package to be used with the negotiation process and the current state of the negotiation for the use of that package.   SECPKG_ATTR_PACKAGE_INFO 10   The pBuffer parameter contains a pointer to a SecPkgContext_PackageInfo \t\t\t\t\t\t\tstructure. Returns information on the SSP in use.   SECPKG_ATTR_PASSWORD_EXPIRY 8   The pBuffer parameter contains a pointer to a SecPkgContext_PasswordExpiry structure. Returns password expiration information.   SECPKG_ATTR_REMOTE_CERT_CONTEXT 0x53   The pBuffer parameter contains a pointer to a PCCERT_CONTEXT \t\t\t\t\t\t\tstructure. Finds a certificate context that contains the end certificate supplied by the server. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_ROOT_STORE 0x55   The pBuffer parameter contains a pointer to a HCERTCONTEXT. \t\t\t\t\t\t\tFinds a certificate context that contains a certificate supplied by the Root store.   SECPKG_ATTR_SESSION_KEY 9   The pBuffer parameter contains a pointer to a SecPkgContext_SessionKey structure. Returns information about the session keys.   SECPKG_ATTR_SESSION_INFO 0x5d   The pBuffer parameter contains a pointer to a SecPkgContext_SessionInfo structure. Returns information about the session. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_SIZES 0   The pBuffer parameter contains a pointer to a SecPkgContext_Sizes structure. Queries the sizes of the structures used in the per-message functions.   SECPKG_ATTR_STREAM_SIZES 4   The pBuffer parameter contains a pointer to a SecPkgContext_StreamSizes structure. Queries the sizes of the various parts of a stream used in the per-message functions. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_SUBJECT_SECURITY_ATTRIBUTES 124   The pBuffer parameter contains a pointer to a SecPkgContext_SubjectAttributes structure. This value returns information about  the security attributes for the connection. This value is supported only on the CredSSP server. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   SECPKG_ATTR_SUPPORTED_SIGNATURES 0x66   The pBuffer parameter contains a pointer to a SecPkgContext_SupportedSignatures structure. This value returns information about  the signature types that are supported for the connection. This value is supported only by the Schannel security package. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported.   SECPKG_ATTR_TARGET_INFORMATION 17   The pBuffer parameter contains a pointer to a SecPkgContext_TargetInformation structure. Returns information about the name of the remote server.   SECPKG_ATTR_UNIQUE_BINDINGS 25   The pBuffer parameter contains a pointer to a SecPkgContext_Bindings structure that specifies channel binding information. This value is supported only by the Schannel security package. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This value is not supported."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "pBuffer",
        "description": "A pointer to a structure that receives the attributes. The type of structure pointed to depends on the value specified in the ulAttribute parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Obtains the access token for a client security context and uses it directly.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns a nonzero error code. One possible error code return is SEC_E_INVALID_HANDLE. ",
    "remarks": "This function is called by a server application to control impersonation outside the SSPI layer, such as when launching a child process. The handle returned must be closed with CloseHandle when the handle is no longer needed. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "QuerySecurityContextToken",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "Handle of the context to query."
      },
      {
        "in_out": "_Out_",
        "type": "HANDLE",
        "name": "*phToken",
        "description": "Returned handle to the access token."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enables a transport application to set  attributes of a security context for a security package. This function is supported only by the Schannel security package.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns a nonzero error code. The following error code is one of the possible error codes.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SetContextAttributes",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle to the security context to be set."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulAttribute",
        "description": "The attribute of the context to be set. This parameter can be one of the following values.  ValueMeaning  SECPKG_ATTR_APP_DATA   The pBuffer parameter contains a pointer to a SecPkgContext_SessionAppData structure. Sets application data for the session. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_EAP_PRF_INFO   The pBuffer parameter contains a pointer to a SecPkgContext_EapPrfInfo structure. Sets the pseudo-random function (PRF) used by the Extensible Authentication Protocol (EAP). This is the value that is returned by a call to the QueryContextAttributes (Schannel) function when SECPKG_ATTR_EAP_KEY_BLOCK is passed as the value of the ulAttribute parameter. This attribute is supported only by the Schannel security package.   SECPKG_ATTR_DTLS_MTU 34   Sets and retrieves the MTU (maximum transmission unit) value for use with DTLS.  If DTLS is not enabled in a security context, this attribute is not supported.   Valid values are between 200 bytes and 64 kilobytes. The default DTLS MTU value in Schannel is 1096 bytes."
      },
      {
        "in_out": "_In_",
        "type": "void",
        "name": "*pBuffer",
        "description": "A pointer to a structure that contains  values to set  the attributes to. The type of structure pointed to depends on the value specified in the ulAttribute parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "cbBuffer",
        "description": "The size, in bytes, of the pBuffer parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Allows a security package to discontinue the impersonation of the caller and restore its own security context.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the return value is SEC_E_OK. If the function fails, the return value can be one of the following error codes.  ",
    "remarks": "RevertSecurityContext is not available with all security packages on all platforms. Typically, it is implemented only on platforms and with security packages for which a call to the  QuerySecurityPackageInfo function indicates impersonation support. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "RevertSecurityContext",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "Handle of the security context being impersonated. This handle must have been obtained in the call to the  AcceptSecurityContext (General) function and used in the call to the  ImpersonateSecurityContext function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The DecryptMessage (General) function decrypts a message. Some packages do not encrypt and decrypt messages but rather perform and check an integrity hash.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function verifies that the message was received in the correct sequence, the function returns SEC_E_OK. If the function fails to decrypt the message, it returns one of the following error codes.  ",
    "remarks": "When you use the Schannel SSP, the DecryptMessage (General) function returns SEC_I_CONTEXT_EXPIRED when the message sender has shut down the connection. For information about initiating or recognizing a shutdown, see Shutting Down an Schannel Connection. When you use the Schannel SSP,  DecryptMessage (General)  returns SEC_I_RENEGOTIATE when the message sender wants to renegotiate the connection (security context). An application  handles a requested renegotiation by calling  AcceptSecurityContext (General) (server side) or  InitializeSecurityContext (General) (client side) and passing in empty input buffers. After this initial call returns a value, proceed as though your application were creating a new connection. For more information, see  Creating an Schannel Security Context. For information about interoperating with GSSAPI, see SSPI/Kerberos Interoperability with GSSAPI. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "DecryptMessage (General)",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle to the security context to be used to decrypt the message."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "pMessage",
        "description": "A pointer to a  SecBufferDesc structure. On input, the structure references one or more  SecBuffer structures. One of these may be of type SECBUFFER_DATA. That buffer contains the encrypted message. The encrypted message is decrypted in place, overwriting the original contents of its buffer. When using the Digest SSP, on input, the structure references one or more  SecBuffer structures. One of these must be of type SECBUFFER_DATA or SECBUFFER_STREAM, and it must contain the encrypted message. When using the Schannel SSP with contexts that are not connection oriented, on input, the structure must contain four  SecBuffer structures. Exactly one buffer must be of type SECBUFFER_DATA and contain an encrypted message, which is decrypted in place. The remaining buffers are used for output and must be of type SECBUFFER_EMPTY.    For connection-oriented contexts, a SECBUFFER_DATA type buffer must be supplied, as noted for nonconnection-oriented contexts. Additionally, a second SECBUFFER_TOKEN type buffer that contains a security token must also be supplied."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSeqNo",
        "description": "The sequence number expected by the transport application, if any. If the transport application does not maintain sequence numbers, this parameter must be set to zero. When using the Digest SSP, this parameter must be set to zero. The Digest SSP manages sequence numbering internally. When using the Schannel SSP, this parameter must be set to zero. The Schannel SSP does not use sequence numbers."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pfQOP",
        "description": "A pointer to a variable of type ULONG that receives package-specific flags that indicate the quality of protection. When using the Schannel SSP, this parameter is not used and should be set to NULL. This parameter can be one of the following flags.  ValueMeaning  SECQOP_WRAP_NO_ENCRYPT   The message was not encrypted, but a header or trailer was produced. Note  KERB_WRAP_NO_ENCRYPT has the same value and the same meaning.     SIGN_ONLY    When using the Digest SSP, use this flag when the security context is set to verify the signature only. For more information, see  Quality of Protection."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The EncryptMessage (General) function encrypts a message to provide privacy. EncryptMessage (General) allows an application to choose among cryptographic algorithms supported by the chosen mechanism. The EncryptMessage (General) function uses the security context referenced by the context handle. Some packages do not have messages to be encrypted or decrypted but rather provide an integrity hash that can be checked.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns one of the following error codes.  ",
    "remarks": "The EncryptMessage (General) function encrypts a message based on the message and the session key from a security context. If the transport application created the security context to support sequence detection and the caller provides a sequence number, the function includes this information with the encrypted message. Including this information protects against replay, insertion, and suppression of messages. The security package incorporates the sequence number passed down from the transport application. When you use the Digest SSP, get the size of the output buffer by calling the QueryContextAttributes (General) function and specifying SECPKG_ATTR_SIZES. The function will return a SecPkgContext_Sizes structure. The size of the output buffer is the sum of the values in the cbMaxSignature and cbBlockSize members. When used with the Schannel SSP, the pMessage parameter must contain a SecBufferDesc structure with the following buffers.  When you use the Schannel SSP, determine the maximum size of each of the buffers by calling the QueryContextAttributes (General) function and specifying the SECPKG_ATTR_STREAM_SIZES attribute. This function returns a SecPkgContext_StreamSizes structure whose members contain the maximum sizes for the header (cbHeader member), message (cbMaximumMessage member) and trailer (cbTrailer member) buffers. For optimal performance, the pMessage structures should be allocated from contiguous memory. Windows XP/2000:  This function was also known as SealMessage. Applications should now use EncryptMessage (General)  only. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "EncryptMessage (General)",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle to the security context to be used to encrypt the message."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "fQOP",
        "description": "Package-specific flags that indicate the quality of protection. A security package can use this parameter to enable the selection of cryptographic algorithms. When using the Digest SSP, this parameter must be set to zero. This parameter can be one of the following flags.  ValueMeaning  SECQOP_WRAP_NO_ENCRYPT   Produce a header or trailer but do not encrypt the message. Note  KERB_WRAP_NO_ENCRYPT has the same value and the same meaning.     SECQOP_WRAP_OOB_DATA   Send an Schannel alert message. In this case, the pMessage parameter must contain a standard two-byte SSL/TLS event code. This value is supported only by the Schannel SSP."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "pMessage",
        "description": "A pointer to a  SecBufferDesc structure. On input, the structure references one or more  SecBuffer structures. One of these can be of type SECBUFFER_DATA. That buffer contains the message to be encrypted. The  message is encrypted in place, overwriting the original contents of the structure. The function does not process buffers with the SECBUFFER_READONLY attribute. The length of the  SecBuffer structure that contains the message must be no greater than cbMaximumMessage, which is obtained from the  QueryContextAttributes (General) (SECPKG_ATTR_STREAM_SIZES) function. When using the Digest SSP,  there must be a second buffer of type SECBUFFER_PADDING or SEC_BUFFER_DATA to hold signature information. To get the size of the output buffer, call the  QueryContextAttributes (General) function and specify SECPKG_ATTR_SIZES. The function will return a  SecPkgContext_Sizes structure. The size of the output buffer is the sum of the values in the cbMaxSignature and cbBlockSize members. Applications that do not use SSL must supply a SecBuffer of type SECBUFFER_PADDING."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSeqNo",
        "description": "The sequence number that the transport application assigned to the message. If the transport application does not maintain sequence numbers, this parameter must be zero. When using the Digest SSP, this parameter must be set to zero. The Digest SSP manages sequence numbering internally. When using the Schannel SSP, this parameter must be set to zero. The Schannel SSP does not use sequence numbers."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The MakeSignature function generates a cryptographic checksum of the message, and also includes sequencing information to prevent message loss or insertion. MakeSignature allows the application to choose between several cryptographic algorithms, if supported by the chosen mechanism. The MakeSignature function uses the security context referenced by the context handle.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns one of the following error codes.  ",
    "remarks": "The MakeSignature function generates a signature that is based on the message and the session key for the context. The VerifySignature function verifies the messages signed by the MakeSignature function. If the transport application created the security context to support sequence detection and the caller provides a sequence number, the function includes this information in the signature. This protects against reply, insertion, and suppression of messages. The security package incorporates the sequence number passed down from the transport application. ",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "MakeSignature",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle to the security context to use to sign the message."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "fQOP",
        "description": "Package-specific flags that indicate the quality of protection. A security package can use this parameter to enable the selection of cryptographic algorithms. When using the Digest SSP, this parameter must be set to zero."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "pMessage",
        "description": "A pointer to a  SecBufferDesc structure. On input, the structure references one or more  SecBuffer structures that contain the message to be signed. The function does not process buffers with the SECBUFFER_READONLY_WITH_CHECKSUM  attribute. The SecBufferDesc structure also references a SecBuffer structure of type SECBUFFER_TOKEN that receives the signature. When the Digest SSP is used as an HTTP authentication protocol, the buffers should be configured as follows.  Buffer #/buffer typeMeaning  0 SECBUFFER_TOKEN   Empty.   1 SECBUFFER_PKG_PARAMS   Method.   2 SECBUFFER_PKG_PARAMS   URL.   3 SECBUFFER_PKG_PARAMS   HEntity. For more information, see  Input Buffers for the Digest Challenge Response.   4 SECBUFFER_PADDING   Empty. Receives the signature.     When the Digest SSP is used as an SASL mechanism, the buffers should be configured as follows.  Buffer #/buffer typeMeaning  0 SECBUFFER_TOKEN   Empty. Receives the signature. This buffer must be large enough to hold the largest possible signature. Determine the size required by calling the  QueryContextAttributes (General) function and specifying SECPKG_ATTR_SIZES. Check the returned  SecPkgContext_Sizes structure member cbMaxSignature.   1 SECBUFFER_DATA   Message to be signed.   2 SECBUFFER_PADDING   Empty."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSeqNo",
        "description": "The sequence number that the transport application assigned to the message. If the transport application does not maintain sequence numbers, this parameter is zero. When using the Digest SSP, this parameter must be set to zero. The Digest SSP manages sequence numbering internally."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Verifies that a message signed by using the  MakeSignature function was received in the correct sequence and has not been modified.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the function verifies that the message was received in the correct sequence and has not been modified, the return value is SEC_E_OK. If the function determines that the message is not correct according to the information in the signature, the return value can be one of the following error codes.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_Entry",
    "category": "Authentication",
    "name": "VerifySignature",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "A handle to the security context to use for the message."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "pMessage",
        "description": "Pointer to a  SecBufferDesc structure that references a set of  SecBuffer structures that contain the message and signature to verify. The signature is in a SecBuffer structure of type SECBUFFER_TOKEN."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSeqNo",
        "description": "Specifies the sequence number expected by the transport application, if any. If the transport application does not maintain sequence numbers, this parameter is zero."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pfQOP",
        "description": "Pointer to a ULONG variable that receives package-specific flags that indicate the quality of protection. Some security packages ignore this parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SpLsaModeInitialize function is called once by the Local Security Authority (LSA) for each registered security support provider/authentication package (SSP/AP) DLL it loads. This function provides the LSA with pointers to the functions implemented by each security package in the SSP/AP DLL.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "The SpLsaModeInitialize function must be implemented by SSP/AP DLLs. The ppTables parameter should contain one  SECPKG_FUNCTION_TABLE for each security package deployed in the DLL. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "SpLsaModeInitialize",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "LsaVersion",
        "description": "The version of the LSA."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "PackageVersion",
        "description": "Pointer to a ULONG that returns the SSP/AP DLL version number."
      },
      {
        "in_out": "_Out_",
        "type": "PSECPKG_FUNCTION_TABLE",
        "name": "*ppTables",
        "description": "Pointer to an array of  SECPKG_FUNCTION_TABLE structures. Each structure is a table of pointers to the functions implemented by a security package deployed in the SSP/AP DLL."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pcTables",
        "description": "Pointer that returns the number of elements in the array pointed to by the ppTables parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Called by the Local Security Authority (LSA) when a logon application with a trusted connection to the LSA calls the  LsaCallAuthenticationPackage function and specifies the authentication package's identifier.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. This return value indicates that the authentication package attempted to provide the requested service. Use the ProtocolStatus parameter to return the completion status of the service request. If the authentication package could not process the request and therefore did not attempt to provide the requested service, return an NTSTATUS code indicating the problem. This code can be the following value or one of the  LSA Policy Function Return Values.  ",
    "remarks": "This function must be implemented by authentication packages. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaApCallPackage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST buffer representing the LSA client's request."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "Supplies a protocol message specific to the authentication package."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBufferBase",
        "description": "Provides the address within the client process of the protocol message. This may be necessary to remap any pointers within the ProtocolSubmitBuffer buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferLength",
        "description": "Specifies the length of the ProtocolSubmitBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProtocolReturnBuffer",
        "description": "Returns the address of the output buffer within the client process. The authentication package is responsible for calling the  AllocateClientBuffer function to allocate the buffer within the client process. The contents of this buffer are specific to the authentication package."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnBufferLength",
        "description": "Pointer to a ULONG that returns the length of the ProtocolReturnBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "ProtocolStatus",
        "description": "Pointer to an NTSTATUS value. If the function returns STATUS_SUCCESS, ProtocolStatus returns a completion status set by the authentication package. ProtocolStatus values are specific to the authentication package.     More information about NTSTATUS codes can be found in the Subauth.h file shipped with the Platform SDK."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The LsaCallAuthenticationPackage function is used by a logon application to communicate with an authentication package.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. Check the ProtocolStatus parameter to obtain the status returned by the authentication package. If the function fails, the return value is an NTSTATUS code. The following are possible error codes.  For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "Logon applications can call LsaCallAuthenticationPackage to communicate with an authentication package. There are several reasons why an application may do this: Typically, this function is used to exchange information with a custom authentication package. This function is not needed by an application that is using one of the authentication packages supplied with Windows, such as MSV1_0 or Kerberos. You must call LsaCallAuthenticationPackage to clean up PKINIT device credentials for LOCAL_SYSTEM and NETWORK_SERVICE. When there is no PKINIT device credential, a successful call does no operation. When there is a PKINIT device credential, a successful call cleans up the PKINIT device credential so that only the password credential remains. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaCallAuthenticationPackage",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "LsaHandle",
        "description": "A handle obtained from a previous call to  LsaRegisterLogonProcess or  LsaConnectUntrusted."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationPackage",
        "description": "Supplies the identifier of the authentication package. This value is obtained by calling  LsaLookupAuthenticationPackage."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "An authentication package\u2013specific message buffer passed to the authentication package. ..."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferLength",
        "description": "Indicates the length, in bytes, of the ProtocolSubmitBuffer buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProtocolReturnBuffer",
        "description": "A pointer that receives the address of the buffer returned by the authentication package. For information about the format and content of this buffer, see the documentation for the individual authentication package. This buffer is allocated by this function. When you have finished using this buffer, free the memory by calling the LsaFreeReturnBuffer function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "*ReturnBufferLength",
        "description": "A pointer to a ULONG that receives the length of the returned buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "ProtocolStatus",
        "description": "If the function succeeds, this parameter receives a pointer to an NTSTATUS code that indicates the completion status of the authentication package."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The dispatch function for pass-through logon requests sent to the  LsaCallAuthenticationPackage function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. This return value indicates that the authentication package attempted to provide the requested service. Use the ProtocolStatus parameter to return the completion status of the service request. If the authentication package could not process the request and therefore did not attempt to provide the requested service, return an NTSTATUS code indicating the problem. This code can be the following value or one of the  LSA Policy Function Return Values.  ",
    "remarks": "This function must be implemented by authentication packages. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaApCallPackagePassthrough",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST buffer representing the LSA client's request."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "Supplies a protocol-specific message to the authentication package."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBufferBase",
        "description": "Provides the address within the client process of the protocol message. This may be necessary to remap pointers within the ProtocolSubmitBuffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferLength",
        "description": "Specifies the length of the ProtocolSubmitBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProtocolReturnBuffer",
        "description": "Returns the address of the output buffer in the client process. The authentication package is responsible for calling the  AllocateClientBuffer function to allocate the buffer in the client process. The contents of this buffer are specific to the authentication package."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnBufferLength",
        "description": "Pointer to a ULONG that returns the length of the ProtocolReturnBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "ProtocolStatus",
        "description": "Pointer to an NTSTATUS value. If the function returns STATUS_SUCCESS, ProtocolStatus returns a completion status set by the authentication package. ProtocolStatus values are specific to the authentication package.     More information about NTSTATUS codes can be found in the Subauth.h file shipped with the Platform SDK."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Called by the Local Security Authority (LSA) when an application with an untrusted connection to the LSA calls the  LsaCallAuthenticationPackage function and specifies the authentication package's identifier.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. This return value indicates that the authentication package attempted to provide the requested service. Use the ProtocolStatus parameter to return the completion status of the service request. If the authentication package could not process the request and therefore did not attempt to provide the requested service, return an NTSTATUS code indicating the problem. This code can be the following value or one of the LSA Policy Function Return Values.  ",
    "remarks": "This function is similar to  LsaApCallPackage but handles untrusted connections. An application should determine what subset of the functionality implemented in LsaApCallPackage should be available to untrusted connections, and it should implement that subset in LsaApCallPackageUntrusted. For information about establishing an untrusted connection, see  LsaConnectUntrusted. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaApCallPackageUntrusted",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST buffer representing the LSA client's request."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "Pointer to a protocol message specific to the authentication package."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBufferBase",
        "description": "Provides the address within the client process of the protocol message. This may be necessary to remap any pointers within the protocol message buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferLength",
        "description": "Indicates the length of the ProtocolSubmitBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProtocolReturnBuffer",
        "description": "Returns the address of the output buffer within the client process. The authentication package is responsible for calling the  AllocateClientBuffer function to allocate the buffer within the client process. The contents of this buffer are specific to the authentication package."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnBufferLength",
        "description": "Pointer to a ULONG that returns the length of the ProtocolReturnBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "ProtocolStatus",
        "description": "Pointer to an NTSTATUS value. If the function returns STATUS_SUCCESS, ProtocolStatus is set to the completion status returned by the specified authentication package. Status values returned are specific to the authentication package.     More information about NTSTATUS codes can be found in the Subauth.h file shipped with the Platform SDK."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Called once by the Local Security Authority (LSA) during system initialization to provide the authentication package a chance to initialize itself.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS error code. For more information, see  LSA Policy Function Return Values. ",
    "remarks": "This function must be implemented by authentication packages. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaApInitializePackage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationPackageId",
        "description": "The identifier the LSA has assigned to the authentication package."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_DISPATCH_TABLE",
        "name": "LsaDispatchTable",
        "description": "Pointer to an  LSA_DISPATCH_TABLE structure that contains the addresses of LSA functions that can be called by authentication packages. Your custom authentication package should save this information if it requires any of the functions described in  LSA Functions Called by Authentication Packages."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLSA_STRING",
        "name": "Database",
        "description": "This parameter is not used; it is NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "PLSA_STRING",
        "name": "Confidentiality",
        "description": "This parameter is not used; it is NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_STRING",
        "name": "*AuthenticationPackageName",
        "description": "Pointer to a pointer to an LSA_STRING structure that receives the name of the authentication package. The authentication package is responsible for allocating the structure and the buffer that contains this string (using the  AllocateLsaHeap function) and returning the address of the structure in this parameter. The buffer will be freed by the LSA when it is no longer needed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Used to notify an authentication package when a logon session terminates. \t\t\tA logon session terminates when the last token referencing the logon session is deleted.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function does not return a value. ",
    "remarks": "When LsaApLogonTerminated is called, an authentication package should release any resources held for the logon ID, such as credentials created within the LSA. The LSA does not automatically perform this cleanup. ",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "LsaApLogonTerminated",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to the logon ID of the session that just ended."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 13,
    "description": "Authenticates a user's logon credentials.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, it should return STATUS_SUCCESS. If the function fails, it should return an NTSTATUS error code, which can be one of the following values or one of the  LSA Policy Function Return Values.  Calling applications can use the  LsaNtStatusToWinError function to convert the NTSTATUS code to a Windows error code. ",
    "remarks": "Authentication packages must implement one of the following functions: LsaApLogonUser,  LsaApLogonUserEx, or  LsaApLogonUserEx2. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaApLogonUser",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST buffer that represents the LSA client's request. Your authentication package can pass this value into  AllocateClientBuffer and  FreeClientBuffer in order to identify the client process in which memory should be allocated or freed."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "A  SECURITY_LOGON_TYPE value identifying the type of logon requested."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AuthenticationInformation",
        "description": "Supplies the authentication information specific to the authentication package. The LSA will free this buffer. This is the same input buffer passed into  LsaLogonUser."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientAuthenticationBase",
        "description": "Provides the address of the authentication information within the client process. This may be necessary to remap any pointers within the AuthenticationInformation buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationInformationLength",
        "description": "Indicates the length, in bytes, of the AuthenticationInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProfileBuffer",
        "description": "Pointer that receives the address of the profile buffer in the client process. The authentication package is responsible for allocating the ProfileBuffer buffer within the client process by calling the  AllocateClientBuffer function. However, if the LSA subsequently encounters an error that prevents a successful logon, the LSA will free this buffer.     The contents of this buffer are determined by the authentication package. The LSA does not alter this buffer; it simply returns the value to the  LsaLogonUser function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ProfileBufferLength",
        "description": "Pointer to a ULONG that receives the length of the ProfileBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an  LUID that receives the new logon ID that uniquely identifies this logon session. The authentication package is responsible for allocating this LUID, and creating the logon session for this logon."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "SubStatus",
        "description": "Pointer to an NTSTATUS that receives the reason for failures due to account restrictions. The values returned in SubStatus are determined by the authentication package.     The following table lists the SubStatus values for the MSV1_0 and Kerberos authentication packages.  ValueMeaning  STATUS_INVALID_LOGON_HOURS   The user account has time restrictions; it cannot be used to log on at this time.   STATUS_INVALID_WORKSTATION   The user account has workstation restrictions; it cannot be used to log on to the current workstation.   STATUS_PASSWORD_EXPIRED   The user account password has expired.   STATUS_ACCOUNT_DISABLED   The user account is currently disabled and cannot be used to log on.     More information about NTSTATUS codes can be found in the Subauth.h header file shipped with the Platform SDK. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_TOKEN_INFORMATION_TYPE",
        "name": "TokenInformationType",
        "description": "Pointer that receives the address of an  LSA_TOKEN_INFORMATION_TYPE value that indicates the type of information returned for inclusion in the token to be created. The information is returned in the TokenInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*TokenInformation",
        "description": "Pointer that receives information to be included in the token. The format and content of the TokenInformation buffer are indicated by the TokenInformationType parameter. Your authentication package is responsible for allocating the memory used by TokenInformation; however, this memory will be freed by the LSA."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_UNICODE_STRING",
        "name": "*AccountName",
        "description": "Pointer to an  LSA_UNICODE_STRING structure that receives the name of the user account. AccountName must always be returned regardless of the success or failure of the call; its string is included in the audit record for an authentication attempt. Your authentication package is responsible for allocating the memory used by AccountName; however, this memory will be freed by the LSA."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_UNICODE_STRING",
        "name": "*AuthenticatingAuthority",
        "description": "Optional. Pointer to an  LSA_UNICODE_STRING structure that receives the description of the authenticating authority for the logon. This parameter may be NULL. This string is included in the audit record for an authentication attempt. Your authentication package is responsible for allocating the memory used by AuthenticatingAuthority; however, this memory will be freed by the LSA.     The MSV1_0 authentication package returns the domain name of the domain validating the account. The Kerberos authentication package returns the NetBIOS domain name."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 14,
    "description": "Authenticates a user's logon credentials.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, it should return STATUS_SUCCESS. Otherwise, it should return an NTSTATUS error code, which can be one of the following values or one of the  LSA Policy Function Return Values.  Calling applications can use the  LsaNtStatusToWinError function to convert the NTSTATUS code to a Windows error code. ",
    "remarks": "Authentication packages must implement one of the following functions:  LsaApLogonUser, LsaApLogonUserEx, or  LsaApLogonUserEx2. LsaApLogonUserEx was added for C2 certification. C2 is a security classification defined by the United States government. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaApLogonUserEx",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST data type representing the LSA client's request."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "A  SECURITY_LOGON_TYPE structure which identifies the type of logon being attempted."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AuthenticationInformation",
        "description": "Supplies the authentication information specific to the authentication package. The LSA will free this buffer."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientAuthenticationBase",
        "description": "Provides the address of the authentication information within the client process. This may be necessary to remap any pointers within the AuthenticationInformation buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationInformationLength",
        "description": "Indicates the length of the AuthenticationInformation buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProfileBuffer",
        "description": "Pointer that receives the address of the profile buffer in the client process. The authentication package is responsible for allocating the ProfileBuffer buffer within the client process by calling the  AllocateClientBuffer function. However, if the LSA subsequently encounters an error which prevents a successful logon, then the LSA will take care of freeing this buffer.     The contents of this buffer are determined by the authentication package. The LSA does not alter this buffer; it simply returns the value to the  LsaLogonUser function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ProfileBufferLength",
        "description": "Pointer to a ULONG that receives the length of the ProfileBuffer buffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an  LUID variable that receives the new logon ID that uniquely identifies this logon session. The authentication package is responsible for allocating this LUID and creating the LSA logon session for this logon."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "SubStatus",
        "description": "Pointer to an NTSTATUS that receives the reason for failures due to account restrictions. The values returned in SubStatus are determined by the authentication package.     The following are SubStatus values for the MSV1_0 and Kerberos authentication packages.  ValueMeaning  STATUS_INVALID_LOGON_HOURS   The user account has time restrictions and cannot be used to log on at this time.   STATUS_INVALID_WORKSTATION   The user account has workstation restrictions and cannot be used to log on from the current workstation.   STATUS_PASSWORD_EXPIRED   The user account password has expired.   STATUS_ACCOUNT_DISABLED   The user account is currently disabled and cannot be used to log on.     More information about NTSTATUS codes can be found in the Subauth.h header file shipped with the Platform SDK."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_TOKEN_INFORMATION_TYPE",
        "name": "TokenInformationType",
        "description": "Pointer that receives the address of an  LSA_TOKEN_INFORMATION_TYPE value that indicates the type of information returned for inclusion in the token to be created. The information is returned by means of the TokenInformation parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*TokenInformation",
        "description": "Pointer that receives the address of information to be included in the token. The format and content of TokenInformation are indicated by the TokenInformationType parameter. Your authentication package is responsible for allocating the memory used by TokenInformation; however, this memory will be freed by the LSA."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "*AccountName",
        "description": "Pointer to an  LSA_UNICODE_STRING structure that receives the name of the user account. AccountName must always be returned regardless of the success or failure of the call; its string is included in the audit record for an authentication attempt. Your authentication package is responsible for allocating the memory used by AccountName It will be freed by the LSA."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "*AuthenticatingAuthority",
        "description": "Optional. Pointer to an LSA_UNICODE_STRING structure that receives the description of the authenticating authority for the logon. This parameter may be NULL. This string is included in the audit record for an authentication attempt. Your authentication package is responsible for allocating the memory used by AuthenticatingAuthority; however, this memory will be freed by the LSA.     The MSV1_0 authentication package returns the domain name of the domain validating the account. The Kerberos authentication package returns the NetBIOS domain name."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "*MachineName",
        "description": "Optional. Pointer that receives the address of an LSA_UNICODE_STRING structure containing the name of the client's workstation. This information is included in the audit record for an authentication attempt. Your authentication package is responsible for allocating the memory used by MachineName; however, this memory will be freed by the LSA.     The MSV1_0 authentication package returns the NetBIOS name of the client's workstation."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 16,
    "description": "Used to authenticate a user logon attempt on the user's initial logon. \t\t\tA new logon session is established for the user, and validation information for the user is returned.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, it should return STATUS_SUCCESS. Otherwise, it should return an NTSTATUS error code, which can be one of the following values or one of the  LSA Policy Function Return Values.  Calling applications can use the  LsaNtStatusToWinError function to convert the NTSTATUS code to a Windows error code. ",
    "remarks": "Authentication packages must implement one of the following functions:  LsaApLogonUser,  LsaApLogonUserEx, or LsaApLogonUserEx2. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaApLogonUserEx2",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to a  LSA_CLIENT_REQUEST opaque buffer representing the client's request."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "SECURITY_LOGON_TYPE value that identifies the type of logon."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "Buffer that supplies the authentication information specific to the authentication package."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBufferBase",
        "description": "Buffer that provides the address within the client process at which the authentication information was resident. This might be necessary to fix any pointers within the authentication information buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferSize",
        "description": "A ULONG value that indicates the size, in bytes, of the authentication information buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProfileBuffer",
        "description": "Pointer that receives the address of the profile buffer in the client process. The authentication package is responsible for allocating ProfileBuffer within the client process by calling the  AllocateClientBuffer function. However, if the LSA subsequently encounters an error which prevents a successful logon, then the LSA will take care of freeing this buffer.     The contents of this buffer are determined by the authentication package. The LSA does not alter this buffer; it simply returns the value to the  LsaLogonUser function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ProfileBufferSize",
        "description": "Pointer to a ULONG that receives the size of the ProfileBuffer buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an  LUID variable that receives the new logon ID that uniquely identifies this logon session. The authentication package is responsible for allocating this LUID and creating the LSA logon session for this logon."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "SubStatus",
        "description": "Pointer to an NTSTATUS that receives the reason for failures due to account restrictions. The values returned in SubStatus are determined by the authentication package.     The following table lists the SubStatus values for the MSV1_0 and Kerberos authentication packages.  ValueMeaning  STATUS_INVALID_LOGON_HOURS   The user account has time restrictions; it cannot be used to log on at this time.   STATUS_INVALID_WORKSTATION   The user account has workstation restrictions; it cannot be used to log on to the current workstation.   STATUS_PASSWORD_EXPIRED   The user account password has expired.   STATUS_ACCOUNT_DISABLED   The user account is currently disabled and cannot be used to log on.     More information about NTSTATUS codes can be found in the Subauth.h header file shipped with the Platform SDK. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_TOKEN_INFORMATION_TYPE",
        "name": "TokenInformationType",
        "description": "Pointer that receives the address of an  LSA_TOKEN_INFORMATION_TYPE value that indicates the type of information returned for inclusion in the token to be created. The information is returned by means of the TokenInformation parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*TokenInformation",
        "description": "Pointer that receives the address of information to be included in the token. The format and content of TokenInformation are indicated by the TokenInformationType parameter. Your authentication package is responsible for allocating the memory used by TokenInformation; however, this memory will be freed by the LSA."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "*AccountName",
        "description": "Pointer to an  LSA_UNICODE_STRING structure that receives the name of the user account. AccountName must always be returned regardless of the success or failure of the call; its string is included in the audit record for an authentication attempt. Your authentication package is responsible for allocating the memory used by AccountName; however, this memory will be freed by the LSA."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "*AuthenticatingAuthority",
        "description": "Optional. Pointer to an  LSA_UNICODE_STRING structure that receives the description of the authenticating authority for the logon. This parameter may be NULL. This string is included in the audit record for an authentication attempt. Your authentication package is responsible for allocating the memory used by AuthenticatingAuthority; however, this memory will be freed by the LSA.     The MSV1_0 authentication package returns the domain name of the domain validating the account. The Kerberos authentication package returns the NetBIOS domain name."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "*MachineName",
        "description": "Optional. Pointer that receives the address of a UNICODE_STRING structure containing the name of the client's computer. This string may optionally be omitted. This string is included in the audit record for this authentication attempt. Your authentication package is responsible for allocating the memory used by MachineName; however, this memory will be freed by the LSA.     The MSV1_0 authentication package returns the NetBIOS name of the client's workstation."
      },
      {
        "in_out": "_Out_",
        "type": "PSECPKG_PRIMARY_CRED",
        "name": "PrimaryCredentials",
        "description": "Pointer to a  SECPKG_PRIMARY_CRED structure that returns primary credentials for handing to other packages."
      },
      {
        "in_out": "_Out_",
        "type": "PSECPKG_SUPPLEMENTAL_CRED_ARRAY",
        "name": "*SupplementalCredentials",
        "description": "Pointer to a  SECPKG_SUPPLEMENTAL_CRED_ARRAY array of supplemental credentials for other packages."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Called by the Local Security Authority (LSA) to pass the security package any credentials stored for the authenticated security principal. This function is called once for each set of credentials stored by the LSA.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "The security package should save the credentials so that it can service requests for credentials. For additional information, see the  SpAcquireCredentialsHandle function. SSP/APs must implement the SpAcceptCredentials function; unlike other SSP/AP functions the name of the function must be SpAcceptCredentials. The LSA accesses the SpAcceptCredentials function through the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpAcceptCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "A  SECURITY_LOGON_TYPE value indicating the type of logon."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AccountName",
        "description": "Pointer to a  UNICODE_STRING structure specifying the name of the logged-on account."
      },
      {
        "in_out": "_In_",
        "type": "PSECPKG_PRIMARY_CRED",
        "name": "PrimaryCredentials",
        "description": "Pointer to a  SECPKG_PRIMARY_CRED structure containing the credentials used to logon. This structure can have NULL members."
      },
      {
        "in_out": "_In_",
        "type": "PSECPKG_SUPPLEMENTAL_CRED",
        "name": "SupplementalCredentials",
        "description": "Pointer to a  SECPKG_SUPPLEMENTAL_CRED structure containing package-specific supplemental credentials."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "Server dispatch function used to create a security context shared by a server and client.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the SpAcceptLsaModeContext function succeeds and no more processing is required to establish the security context, return STATUS_SUCCESS. If additional processing is required, the function should return SEC_I_CONTINUE_NEEDED. If the function fails to create the security context for any other reason, return an NTSTATUS code indicating the reason. ",
    "remarks": "SpInitLsaModeContext is the client-side function for creating a security context. SSP/APs must implement the SpAcceptLsaModeContext function. The actual name given to the implementation is up to the developer. A pointer to the SpAcceptLsaModeContext function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpAcceptLsaModeContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "Optional. Handle to the credentials to use for the context."
      },
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "Optional. Handle to the current context."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "InputBuffer",
        "description": "Pointer to a  SecBufferDesc structure containing information from the client."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ContextRequirements",
        "description": "Flags indicating the context requirements. The following table lists the valid values.  ValueMeaning  ASC_REQ_DELEGATE   The server is allowed to impersonate the client.   ASC_REQ_MUTUAL_AUTH   Both the client and the server are required to prove their identity.   ASC_REQ_REPLAY_DETECT   The security context will support the detection of replayed packets.   ASC_REQ_SEQUENCE_DETECT   The security context will support the detection of out-of-order messages.   ASC_REQ_USE_SESSION_KEY   A new session key must be negotiated.   ASC_REQ_PROMPT_FOR_CREDS   If the client is an interactive user, the package must, if possible, prompt the user for the appropriate credentials.   ASC_REQ_USE_SUPPLIED_CREDS   The input buffer contains package-specific credential information which should be used to authenticate the connection.   ASC_REQ_ALLOCATE_MEMORY   The package must allocate memory. The caller must eventually call the  FreeContextBuffer function to free memory allocated by the security package.   ASC_REQ_USE_DCE_STYLE   The caller expects a three-leg mutual authentication transaction.   ASC_REQ_DATAGRAM   A datagram-type communications channel should be used. For more information, see  Datagram Contexts.   ASC_REQ_CONNECTION   A connection-type communications channel should be used. For more information see  Connection-Oriented Contexts.   ASC_REQ_EXTENDED_ERROR   If the context fails, generate an error reply message to send back to the client.   ASC_REQ_STREAM   A stream-type communications channel should be used. For more information, see  Stream Contexts.   ASC_REQ_INTEGRITY   Buffer integrity can be verified; however, replayed and out-of-sequence messages will not be detected."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TargetDataRep",
        "description": "Flag indicating the data representation, such as byte ordering, to use. Contains SECURITY_NATIVE_DREP or SECURITY_NETWORK_DREP."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_SEC_HANDLE",
        "name": "NewContextHandle",
        "description": "Pointer to an LSA_SEC_HANDLE. On the first call to  AcceptSecurityContext, this pointer receives the new context handle. On subsequent calls, NewContextHandle can be the same as the handle specified in the ContextHandle parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBufferDesc",
        "name": "OutputBuffer",
        "description": "Pointer to a  SecBufferDesc structure that receives information to be sent to the client."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ContextAttributes",
        "description": "Pointer to flags specifying the context attributes that the server supports. For a list of valid values, see the ContextRequirements parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PTimeStamp",
        "name": "ExpirationTime",
        "description": "Pointer to a  TimeStamp that receives the expiration time for the context."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "MappedContext",
        "description": "Pointer to a Boolean value. Set MappedContext to TRUE if the security package implements the user-mode SSP/AP functions."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "ContextData",
        "description": "Optional. Pointer to a  SecBuffer structure that receives context-specific data to copy when creating the user-mode security context. Memory for ContextData must be allocated using the  AllocateLsaHeap function. The Local Security Authority (LSA) will free the memory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Called to obtain a handle to a principal's credentials. The security package can deny access to the caller if the caller does not have permission to access the credentials.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following table lists common reasons for failure and the error codes that should be returned.  ",
    "remarks": "The package can use the Local Security Authority (LSA) support functions to determine whether the caller should be given access to the requested credentials. Credentials obtained from SpAcquireCredentialsHandle are freed by calling the  SpFreeCredentialsHandle function. SSP/APs must implement the SpAcquireCredentialsHandle function; however, the actual name given to the implementation is up to the developer. A pointer to the SpAcquireCredentialsHandle function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpAcquireCredentialsHandle",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "PrincipalName",
        "description": "Optional. Pointer to a  UNICODE_STRING structure containing the name of the security principal whose credentials are being requested. If this value is NULL, the caller requests a handle to the credentials of the user in whose security context the caller is executing."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CredentialUseFlags",
        "description": "Flags indicating how the credentials will be used. The following values are valid.  ValueMeaning  SECPKG_CRED_INBOUND   Credentials will be used with the  AcceptSecurityContext (General) function.   SECPKG_CRED_OUTBOUND   Credentials will be used with the  InitializeSecurityContext (General) function."
      },
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Optional. Pointer to an  LUID containing the logon identifier of the security principal."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AuthorizationData",
        "description": "Optional. Pointer to supplemental authentication data."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "GetKeyFunction",
        "description": "Pointer to a function in the caller's address space that generates session keys."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "GetKeyArgument",
        "description": "Pointer to the argument used with the GetKeyFunction function."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "Pointer to an LSA_SEC_HANDLE that receives the credentials. When you have finished using the credentials, free the handle by calling the SpFreeCredentialsHandle function."
      },
      {
        "in_out": "_Out_",
        "type": "PTimeStamp",
        "name": "ExpirationTime",
        "description": "Pointer to a  TimeStamp that receives the time the credentials handle expires."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Used to add credentials for a security principal.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpAddCredentials function; however, the actual name given to the implementation is up to the developer. A pointer to the SpAddCredentials function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpAddCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "A handle to the credential to add."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "PrincipalName",
        "description": "Optional. Pointer to a  UNICODE_STRING structure containing the name of the security principal whose credentials are being added."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "Package",
        "description": "Pointer to a  UNICODE_STRING structure containing the name of the authenticating package."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CredentialUseFlags",
        "description": "Flags indicating how the credentials will be used. The following values are valid.  ValueMeaning  SECPKG_CRED_INBOUND   Credentials will be used with the  AcceptSecurityContext (General) function.   SECPKG_CRED_OUTBOUND   Credentials will be used with the  InitializeSecurityContext (General) function."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AuthorizationData",
        "description": "Optional. Pointer to supplemental authentication data."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "GetKeyFunction",
        "description": "Pointer to a function in the caller's address space that generates session keys."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "GetKeyArgument",
        "description": "Pointer to the argument used with the GetKeyFunction function."
      },
      {
        "in_out": "_Out_",
        "type": "PTimeStamp",
        "name": "ExpirationTime",
        "description": "Pointer to a  TimeStamp that receives the time the credentials handle expires."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Applies a control token to a security context. This function is not currently called by the Local Security Authority (LSA).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists common reasons for failure and the error codes that the function should return.  ",
    "remarks": "SSP/APs must implement the SpApplyControlToken function; however, the actual name given to the implementation is up to the developer. A pointer to the SpApplyControlToken function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpApplyControlToken",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the security context to be modified based on the ControlToken parameter."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "ControlToken",
        "description": "Pointer to a  SecBufferDesc structure containing the token to apply to the context."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes a security context.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following table lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "SSP/APs must implement the SpDeleteContext function; however, the actual name given to the implementation is up to the developer. A pointer to the SpDeleteContext function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpDeleteContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the security context to delete."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Deletes credentials from a security package's list of primary or supplemental credentials.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpDeleteCredentials function; however, the actual name given to the implementation is up to the developer. A pointer to the SpDeleteCredentials function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpDeleteCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "A handle to the credentials to delete."
      },
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "Key",
        "description": "Pointer to a  SecBuffer structure whose contents indicate which credentials to delete. The information stored in the Key parameter is package specific."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Frees credentials acquired by calling the  SpAcquireCredentialsHandle function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "SSP/APs must implement the SpFreeCredentialsHandle function; however, the actual name given to the implementation is up to the developer. A pointer to the SpFreeCredentialsHandle function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpFreeCredentialsHandle",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "A handle to the credentials to free."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SpGetCredentials function retrieves the primary and supplemental credentials from the user object.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code indicating the reason it failed. The following  lists common reasons for failure and the error codes that the function should return.  ",
    "remarks": "SSP/APs must implement the SpGetCredentials function; however, the actual name given to the implementation is up to the developer. A pointer to the SpGetCredentials function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpGetCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "A handle to the credentials to be retrieved."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "Credentials",
        "description": "Pointer to a  SecBuffer structure that receives the credentials."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SpGetExtendedInformation function provides extended information about a security package.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "Extended information is set using the  SpSetExtendedInformation function. An SSP/AP must implement the SpGetExtendedInformation function; however, the actual name given to the implementation is up to the package developer. A pointer to the SpGetExtendedInformation function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpGetExtendedInformation",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SECPKG_EXTENDED_INFORMATION_CLASS",
        "name": "Class",
        "description": "A value from the  SECPKG_EXTENDED_INFORMATION_CLASS enumeration indicating the type of extended information."
      },
      {
        "in_out": "_Out_",
        "type": "PSECPKG_EXTENDED_INFORMATION",
        "name": "*ppInformation",
        "description": "Pointer to a pointer to a  SECPKG_EXTENDED_INFORMATION structure allocated by the security package. If the function call succeeds, the returned structure contains the requested information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SpGetInfo function provides general information about the security package, such as its name and capabilities.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "It is safe to place pointers to constant or dynamic data into the  SecPkgInfo structure\u00e2\u0080\u0094the LSA will make a copy of the data prior to forwarding it. SSP/APs must implement the SpGetInfo function; however, the actual name given to the implementation is up to the developer. A pointer to the SpGetInfo function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpGetInfo",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSecPkgInfo",
        "name": "PackageInfo",
        "description": "Pointer to a  SecPkgInfo structure that is allocated by the Local Security Authority (LSA) and must be populated by the package."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SpGetUserInfo function retrieves information about a logon session.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "The Flags value NO_LONG_NAMES provides compatibility with Microsoft NTLM. SSP/APs must implement the SpGetUserInfo function; however, the actual name given to the implementation is up to the developer. A pointer to the SpGetUserInfo function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpGetUserInfo",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an LUID containing the logon session for which information is to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Specifies the acceptable length of the domain name as one of the following values.      \t\t\t\t\t  ValueMeaning  NO_LONG_NAMES   The returned domain name cannot be longer than 15 characters.   UNDERSTANDS_LONG_NAMES   The returned domain name can be longer than 15 characters."
      },
      {
        "in_out": "_Out_",
        "type": "PSecurityUserData",
        "name": "*UserData",
        "description": "Pointer to a pointer to a  SecurityUserData structure. If the function call succeeds, the user information is returned in this structure. The security package should allocate the memory for this structure in the caller's address space. The caller is responsible for freeing the buffer by calling the  FreeContextBuffer function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SpInitialize function is called once by the Local Security Authority (LSA) to provide a security package with general security information and a dispatch table of support functions. The security package should save the information and do internal initialization processing, if any is needed.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS, or an informational status code. If the function fails, return an NTSTATUS error code indicating the reason it failed. For more information, see Remarks. ",
    "remarks": "If SpInitialize returns an NTSTATUS error code to the LSA, the package will be unloaded, and the Local Security Authority (LSA) will not include it in the list of available security packages. SSP/APs must implement the SpInitialize function; however, the actual name given to the implementation is up to the developer. A pointer to the SSP/AP's implementation of the SpInitialize function must be in the  SECPKG_FUNCTION_TABLE structure passed to the LSA from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpInitialize",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "PackageId",
        "description": "A unique identifier the LSA assigns to each security package. The value is valid until the system is restarted."
      },
      {
        "in_out": "_In_",
        "type": "PSECPKG_PARAMETERS",
        "name": "Parameters",
        "description": "A pointer to a  SECPKG_PARAMETERS structure containing primary domain and machine state information."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_SECPKG_FUNCTION_TABLE",
        "name": "FunctionTable",
        "description": "Pointer to a table of LSA support functions that a security package can call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "The SpInitLsaModeContext function is the client dispatch function used to establish a security context between a server and client.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds and no more processing is required, return STATUS_SUCCESS. If processing is not complete, the function should return SEC_I_CONTINUE_NEEDED. When this value is returned, the caller must call the  InitializeSecurityContext (General) function again. If the function fails to create the security context for any other reason, it should return an NTSTATUS code indicating the reason it failed. ",
    "remarks": "The  SpAcceptLsaModeContext function is the server-side function for creating a context. SSP/APs must implement the SpInitLsaModeContext function; however, the actual name given to the implementation is up to the developer. A pointer to the SpInitLsaModeContext function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpInitLsaModeContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "Optional. Handle to the credentials to use for the context. CredentialHandle can be NULL if the ContextHandle parameter is not NULL."
      },
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "Optional. Handle to the context to use as the basis for this context. ContextHandle can be NULL if the CredentialHandle parameter is not NULL."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "TargetName",
        "description": "Optional. Pointer to a  UNICODE_STRING containing the name of the target of the context. The content of TargetName is package-specific and is not interpreted by the LSA."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ContextRequirements",
        "description": "Flags indicating the context attributes required by the client. The actual context attributes are returned in the ContextAttributes parameter.     The following table lists the valid values.  ValueMeaning  ISC_REQ_DELEGATE   The server is allowed to impersonate the client.   ISC_REQ_MUTUAL_AUTH   Both the client and the server are required to prove their identity.   ISC_REQ_REPLAY_DETECT   The security context will support the detection of replayed packets.   ISC_REQ_SEQUENCE_DETECT   The security context will support the detection of out-of-order messages.   ISC_REQ_USE_SESSION_KEY   A new session key must be negotiated.   ISC_REQ_PROMPT_FOR_CREDS   If the client is an interactive user, the package must, if possible, prompt the user for the appropriate credentials.   ISC_REQ_USE_SUPPLIED_CREDS   The input buffer contains package-specific credential information which should be used to authenticate the connection.   ISC_REQ_ALLOCATE_MEMORY   The package must allocate memory. The caller must eventually call the  FreeContextBuffer function to free memory allocated by the package.   ISC_REQ_USE_DCE_STYLE   The caller expects a three-leg mutual authentication transaction.   ISC_REQ_DATAGRAM   A datagram-type communications channel should be used. For more information, see  Datagram Contexts.   ISC_REQ_CONNECTION   A connection-type communications channel should be used. For more information see  Connection-Oriented Contexts.   ISC_REQ_EXTENDED_ERROR   If the context fails, generate an error reply message to send back to the client.   ISC_REQ_STREAM   A stream-type communications channel should be used. For more information, see  Stream Contexts.   ISC_REQ_INTEGRITY   Buffer integrity is verified; however, replayed and out-of-sequence messages will not be detected."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "TargetDataRep",
        "description": "Flag indicating the data representation, such as byte ordering, on the target. Contains SECURITY_NATIVE_DREP or SECURITY_NETWORK_DREP."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "InputBuffers",
        "description": "Pointer to a  SecBufferDesc structure containing the previous reply message from the server. The first time this function is called the InputBuffers parameter is NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_SEC_HANDLE",
        "name": "NewContextHandle",
        "description": "Pointer that receives a handle to the new security context. When you have finished using the security context, release the handle by calling the SpDeleteContext function."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBufferDesc",
        "name": "OutputBuffers",
        "description": "Pointer to a  SecBufferDesc structure containing the security token to pass back to the server."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ContextAttributes",
        "description": "Pointer to flags specifying the attributes of the new context. The client requests a set of attributes using the ContextRequirements parameter. If the ContextRequirements flags do not match the ContextAttributes flags, the client must decide whether to continue or terminate. For a complete list of the valid flags, see  Context Requirements."
      },
      {
        "in_out": "_Out_",
        "type": "PTimeStamp",
        "name": "ExpirationTime",
        "description": "Pointer to a  TimeStamp that receives the expiration time for the new context."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "MappedContext",
        "description": "Pointer to a Boolean value. Set MappedContext to TRUE if the security package implements the user-mode SSP/AP functions."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "ContextData",
        "description": "Pointer to a  SecBuffer structure that receives the data to copy when creating a user-mode security context. Allocate memory for ContextData using the  AllocateLsaHeap function. The LSA will free the memory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SpQueryContextAttributes function retrieves the attributes of a security context.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "SSP/APs must implement the SpQueryContextAttributes function; however, the actual name given to the implementation is up to the developer. A pointer to the LSA-mode implementation of the SpQueryContextAttributes function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. A pointer to the user-mode implementation of the SpQueryContextAttributes function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpQueryContextAttributes",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the security context."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ContextAttribute",
        "description": "Context attribute to query. For a list of valid values, see the  QueryContextAttributes (General) function."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer that receives the address of a buffer containing the requested attributes. Memory for the Buffer parameter should be allocated with the  AllocateHeap function from the  SECPKG_DLL_FUNCTIONS function table in user-mode. In Local Security Authority (LSA) mode, use the  AllocateLsaHeap function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SpQueryCredentialsAttributes function retrieves the attributes for a credential.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists common reasons for failure and the error codes that the function should return.  ",
    "remarks": "SSP/APs must implement the SpQueryCredentialsAttributes function; however, the actual name given to the implementation is up to the developer. A pointer to the SpQueryCredentialsAttributes function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpQueryCredentialsAttributes",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "A handle to the credential to query."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CredentialAttribute",
        "description": "Attribute to query. The following table lists the valid values.      \t\t\t\t\t  ValueMeaning  SECPKG_CRED_ATTR_NAMES   The name of the principal associated with the credentials.   SECPKG_ATTR_SUPPORTED_ALGS   The algorithms supported with a particular credential.   SECPKG_ATTR_CIPHER_STRENGTHS   The minimum and maximum cipher strength used with a credential.   SECPKG_ATTR_SUPPORTED_PROTOCOLS   The protocols supported with a particular credential."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a buffer that receives the requested attributes. Allocate memory for this buffer using the  AllocateClientBuffer function, so that caller can free it by calling the  FreeContextBuffer function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Saves a supplemental credential to the user object.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpSaveCredentials function; however, the actual name given to the implementation is up to the developer. A pointer to the SpSaveCredentials function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpSaveCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "A handle to the credential to save."
      },
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "Credentials",
        "description": "Pointer to a  SecBuffer structure containing the credential information to be saved."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Sets extended information about the security package.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "To retrieve extended information, the  SpGetExtendedInformation function is called. An SSP/AP must implement the SpSetExtendedInformation function; however, the actual name given to the implementation is up to the package developer. A pointer to the SpSetExtendedInformation function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpSetExtendedInformation",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SECPKG_EXTENDED_INFORMATION_CLASS",
        "name": "Class",
        "description": "A  SECPKG_EXTENDED_INFORMATION_CLASS enumeration value indicating the type of extended information."
      },
      {
        "in_out": "_In_",
        "type": "PSECPKG_EXTENDED_INFORMATION",
        "name": "Info",
        "description": "Pointer to a  SECPKG_EXTENDED_INFORMATION structure containing the extended information set."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The SpShutDown function is called by the Local Security Authority (LSA) before the security support provider/authentication package (SSP/AP) is unloaded. The implementation of this function should release any allocated resources, such as credentials.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpShutDown function; however, the actual name given to the implementation is up to the developer. A pointer to the SpShutDown function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpShutDown",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The SslCrackCertificate function is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use the CertCreateCertificateContext function.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Schannel.h",
    "return_value": "Returns nonzero if this function successfully created an X509Certificate structure or zero otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "SslCrackCertificate",
    "is_callback": 0,
    "dll": "Schannel.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "pbCertificate",
        "description": "The certificate BLOB from which to create the new X509Certificate structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCertificate",
        "description": "The length, in bytes, of the BLOB contained in the pbCertificate parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Set this value to CF_CERT_FROM_FILE to specify that the certificate BLOB contained in the pbCertificate parameter is from a file."
      },
      {
        "in_out": "_Out_",
        "type": "PX509Certificate",
        "name": "*ppCertificate",
        "description": "On return, receives the address of a pointer to the X509Certificate structure that this function creates. When you have finished using the X509Certificate structure, free it by calling SslFreeCertificate."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Removes the specified string from the Schannel cache.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Schannel.h",
    "return_value": "Returns nonzero if the specified entries are removed from the Schannel cache or zero otherwise. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "SslEmptyCache",
    "is_callback": 0,
    "dll": "Schannel.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTR",
        "name": "pszTargetName",
        "description": "A pointer to a null-terminated string that specifies the entry to remove from the cache. If the value of this parameter is NULL, all entries are removed from the cache."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "This parameter is not used."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The SslFreeCertificate function is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use the CertFreeCertificateContext function.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Schannel.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "void",
    "category": "Authentication",
    "name": "SslFreeCertificate",
    "is_callback": 0,
    "dll": "Schannel.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PX509Certificate",
        "name": "pCertificate",
        "description": "The certificate to free."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SpUserModeInitialize function is called when a security support provider/authentication package (SSP/AP) DLL is loaded into the process space of a client/server application. This function provides the  SECPKG_USER_FUNCTION_TABLE tables for each security package in the SSP/AP DLL.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "The SpUserModeInitialize function must be implemented by SSP/AP DLLs that contain user-mode security packages. The ppTables parameter should contain one  SECPKG_USER_FUNCTION_TABLE for each user-mode security package deployed in the DLL. For more information on deploying security packages in DLLs, see  User Mode Initialization. ",
    "return_type": "NTSTATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SpUserModeInitialize",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "LsaVersion",
        "description": "The version of the security provider DLL (either Secur32.dll or Security.dll)."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "PackageVersion",
        "description": "Pointer that returns the version of the SSP/AP DLL."
      },
      {
        "in_out": "_Out_",
        "type": "PSECPKG_USER_FUNCTION_TABLE",
        "name": "*ppTables",
        "description": "Pointer that returns an array of  SECPKG_USER_FUNCTION_TABLE structures. Each structure is a table of pointers to the user-mode functions implemented by a security package deployed in the SSP/AP DLL."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pcTables",
        "description": "Pointer that returns the number of elements in the array pointed to by the ppTables parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SpInitUserModeContext function creates a user-mode security context from a packed Local Security Authority (LSA)-mode context.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "The SpInitUserModeContext function is called after a security context has been created by the security package, if the MappedContext parameter of the  SpInitLsaModeContext or  SpAcceptLsaModeContext is set to TRUE. The package-specific context data should contain the information required to determine which function resulted in the call to SpInitUserModeContext. SSP/APs must implement the SpInitUserModeContext function; however, the actual name given to the implementation is up to the developer. A pointer to the SpInitUserModeContext function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpInitUserModeContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the LSA-mode context returned from the  SpInitLsaModeContext or  SpAcceptLsaModeContext function."
      },
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "PackedContext",
        "description": "Pointer to a  SecBuffer structure that contains the serialized context data. Use the  FreeContextBuffer function to free memory allocated for this structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SpCompleteAuthToken function completes an authentication token.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "SSP/APs must implement the SpCompleteAuthToken function; however, the actual name given to the implementation is up to the developer. A pointer to the SpCompleteAuthToken function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpCompleteAuthToken",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "Handle of the context to complete."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "InputBuffer",
        "description": "Pointer to a  SecBufferDesc structure that contains package-specific information for the context."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Exports a security context to another process.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "To import a previously exported security context use the  SpImportSecurityContext function. SSP/APs must implement the SpExportSecurityContext function; however, the actual name given to the implementation is up to the developer. A pointer to the SpExportSecurityContext function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpExportSecurityContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "phContext",
        "description": "A handle to the security context to export."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "fFlags",
        "description": "Optional. Specifies context duplication options. The following table lists the valid values which are defined in Sspi.h.      \t\t\t\t\t  ValueMeaning  SECPKG_CONTEXT_EXPORT_RESET_NEW   New context is reset to initial state.   SECPKG_CONTEXT_EXPORT_DELETE_OLD   Old context is deleted during export."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "pPackedContext",
        "description": "Pointer to a  SecBuffer structure containing the serialized context. Resources should be allocated using the  AllocateClientBuffer function, and freed by the caller using the  FreeContextBuffer function."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "pToken",
        "description": "Optional. Pointer to a handle that receives the context's token."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Formats credentials to be stored in a user object.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpFormatCredentials function; however, the actual name given to the implementation is up to the developer. A pointer to the SpFormatCredentials function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpFormatCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "Credentials",
        "description": "Pointer to a  SecBuffer structure containing the credentials to be formatted."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "FormattedCredentials",
        "description": "Pointer to a SecBuffer structure containing the formatted credentials. Allocate memory for the structure using the  AllocateHeap function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Obtains the token to impersonate. The SpGetContextToken function is used by the SSPI  ImpersonateSecurityContext function to obtain the token to impersonate.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "SSP/APs must implement the SpGetContextToken function; however, the actual name given to the implementation is up to the developer. A pointer to the SpGetContextToken function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpGetContextToken",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the context to impersonate."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "ImpersonationToken",
        "description": "Pointer that receives a handle to the token for the specified context. Return the handle to the token without first duplicating the handle or the token."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SpImportSecurityContext function imports a security context from another process.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpImportSecurityContext function; however, the actual name given to the implementation is up to the developer. A pointer to the SpImportSecurityContext function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpImportSecurityContext",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "pPackedContext",
        "description": "Pointer to a  SecBuffer structure containing a serialized security context previously generated by the  SpExportSecurityContext function."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "Token",
        "description": "Optional. Handle to the context token."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_SEC_HANDLE",
        "name": "phContext",
        "description": "Pointer to an LSA_SEC_HANDLE that receives the imported context handle."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SpInstanceInit function is called once for each security package contained in an SSP/AP, when the SSP/AP is loaded into a client/server process. Security packages should use this function to perform any user mode-specific initialization.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "The SpInstanceInit function is called once when the SSP/AP is loaded into the user-mode process, after the  SpUserModeInitialize function is called. SSP/APs must implement the SpInstanceInit function; however, the actual name given to the implementation is up to the developer. A pointer to the SpInstanceInit function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpInstanceInit",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Version",
        "description": "The version of the Local Security Authority (LSA)."
      },
      {
        "in_out": "_In_",
        "type": "PSECPKG_DLL_FUNCTIONS",
        "name": "FunctionTable",
        "description": "Pointer to a  SECPKG_DLL_FUNCTIONS structure containing the support functions that the security package can use in user-mode."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*UserFunctions",
        "description": "This parameter is not used."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SpMakeSignature function generates a signature based on the specified message and security context.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following  lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "The counterpart to the SpMakeSignature function is the  SpVerifySignature function, used to verify signatures at the receiving end. SSP/APs must implement the SpMakeSignature function; however, the actual name given to the implementation is up to the developer. A pointer to the SpMakeSignature function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpMakeSignature",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the security context to be used to generate the message signature."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "QualityOfProtection",
        "description": "Specifies package-specific flags that indicate the quality of protection. A security package can use this parameter to support the selection of cryptographic algorithms."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "MessageBuffers",
        "description": "Pointer to an array of  SecBuffer structures. On input, the structures contain the message to be signed. On output, the SecBuffer structure of type SECBUFFER_TOKEN contains the signature."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSequenceNumber",
        "description": "Sequence number to assign to the message. Sequence numbers are optional and are used as protection against loss and insertion of messages. A value of zero indicates that sequence numbers are not in use."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SpMarshallSupplementalCreds function converts supplemental credentials from a public format into a format suitable for local procedure calls.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpMarshallSupplementalCreds function; however, the actual name given to the implementation is up to the developer. A pointer to the SpMarshallSupplementalCreds function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpMarshallSupplementalCreds",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CredentialSize",
        "description": "Specifies the size of the supplemental credentials."
      },
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "Credentials",
        "description": "Pointer to the supplemental credentials."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "MarshalledCredSize",
        "description": "Pointer to the size of the MarshalledCreds buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*MarshalledCreds",
        "description": "Pointer that receives the address of the buffer containing the serialized credentials. Allocate the memory for this buffer by calling the  AllocateHeap function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Encrypts a message exchanged between a client and server.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following table lists common reasons for failure and the error codes that the function should return.  ",
    "remarks": "Messages encrypted by the sender using the SpSealMessage function are decrypted using the  SpUnsealMessage function. SSP/APs must implement the SpSealMessage function; however, the actual name given to the implementation is up to the developer. A pointer to the SpSealMessage function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpSealMessage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "Handle of the security context used to sign the message."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "QualityOfProtection",
        "description": "Specifies package-specific flags that indicate the quality of protection. An SSP/AP can use this parameter to enable the selection of cryptographic algorithms."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "MessageBuffers",
        "description": "Pointer to a  SecBufferDesc structure that contains message buffers. Only one of these message buffers can be of type SECBUFFER_DATA, and it contains the message to be encrypted. The buffer cannot have the SECBUFFER_READONLY attribute because the encryption is done in-place."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSequenceNumber",
        "description": "Sequence number to assign to the message. Sequence numbers are optional and are used as protection against loss and insertion of messages. A value of zero indicates that sequence numbers are not in use."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Decrypts a message that was previously encrypted with the  SpSealMessage function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "SSP/APs must implement the SpUnsealMessage function; however, the actual name given to the implementation is up to the developer. A pointer to the SpUnsealMessage function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpUnsealMessage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "Handle of the security context used to seal the message."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "MessageBuffers",
        "description": "Pointer to a  SecBufferDesc structure that contains the message buffers and a signature buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSequenceNumber",
        "description": "Sequence number to assign to the message. Sequence numbers are optional and are used as protection against loss and insertion of messages. A value of zero indicates that sequence numbers are not in use."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "QualityOfProtection",
        "description": "Not used."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Verifies that the message received is correct according to the signature.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS. If the function fails, return an NTSTATUS code that indicates the reason it failed. The following table lists a common reason for failure and the error code that the function should return.  ",
    "remarks": "The signature verified by the SpVerifySignature function is created by the  SpMakeSignature function, used by a message sender. SSP/APs must implement the SpVerifySignature function; however, the actual name given to the implementation is up to the developer. A pointer to the SpVerifySignature function is available in the  SECPKG_USER_FUNCTION_TABLE structure received from the  SpUserModeInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "SpVerifySignature",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the security context used to sign the message."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "MessageBuffers",
        "description": "Pointer to a  SecBufferDesc structure containing the message to verify."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MessageSequenceNumber",
        "description": "Sequence number to assign to the message. Sequence numbers are optional and are used as protection against loss and insertion of messages. A value of zero indicates that sequence numbers are not in use."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "QualityOfProtection",
        "description": "Pointer to package-specific flags that indicate the quality of protection."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[AddCredential is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Applications should use the LsaCallAuthenticationPackage function with KerbAddExtraCredentialsMessage specified as the message type. KerbAddExtraCredentialsMessage is a   KERB_PROTOCOL_MESSAGE_TYPE enumeration value.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the function returns STATUS_SUCCESS. If the function fails, it returns an NTSTATUS code, which can be the following value or one of the  LSA Policy Function Return Values.  The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "The body of the credential string must be self-relative; that is, it must contain no pointers to memory outside the credentials. Credentials are copied, and any pointers outside the credentials themselves will no longer be valid in the copy. In particular, strings referred to in credentials should have both the UNICODE_STRING header and body placed in the credential buffer. Pointers to strings in the body of credentials should be changed to offsets. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "AddCredential",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "A pointer to an  LUID that contains the session ID of the logon session to which credentials are to be added."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationPackage",
        "description": "The authentication package ID of the calling authentication package. This value is received in the  LsaApInitializePackage call during DLL initialization."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_STRING",
        "name": "PrimaryKeyValue",
        "description": "A string that contains a value that the authentication package will later need to reference as a primary key of the credential data. This can be used, for example, to keep the name of the domain or server the credentials are related to. The format and meaning of this string are specific to the authentication package. Note that the string value does not have to be unique, even for the specified logon session. For example, there can be two passwords for the same domain, each with the passwords stored as credentials and the domain name stored as the primary key."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_STRING",
        "name": "Credentials",
        "description": "A string that represents the user credentials. The format and meaning of this string are specific to the authentication package."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Allocates a buffer in the client's address space. Buffers allocated in the client's address space are used to hold information returned to the client from an authentication package.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be the following value or one of the  LSA Policy Function Return Values.  The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "The authentication package or the client process must later free the buffer. The authentication process can free the buffer by using the  FreeClientBuffer dispatch routine. The client process can free the buffer by using the  LsaFreeReturnBuffer function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "AllocateClientBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST data structure that contains information about the LSA client's authentication request. A custom authentication package should pass in the value received during the client's call to the function, such as  LsaApCallPackage or  LsaApLogonUser, that returns the output parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "LengthRequired",
        "description": "Length of the buffer needed, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ClientBaseAddress",
        "description": "Pointer that receives the address of the buffer. This address is the virtual address of the buffer within the client process, not in the current process."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Allocates memory on the heap. Some information passed back to the LSA is expected to be allocated using this function. Memory allocated with this routine must be deallocated with the  FreeLsaHeap function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function returns a pointer to the allocated heap memory. If memory could not be allocated, the function returns NULL. ",
    "remarks": "",
    "return_type": "PVOID",
    "category": "Authentication",
    "name": "AllocateLsaHeap",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Number of bytes to allocate from the heap."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Copies information from the address space of a  client process into a buffer in the current process.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CopyFromClientBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST data structure that contains information about the LSA client's authentication request."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Length of the buffer to be copied, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BufferToCopy",
        "description": "Pointer to the local buffer into which the data is to be copied."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBaseAddress",
        "description": "Pointer to the client buffer whose contents are to be copied. This address is the address of the buffer within the client process, not the current process."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Copies information from a buffer in the current process into a client process's address space.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CopyToClientBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST data type representing a client request."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Length in bytes of the buffer to be copied."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBaseAddress",
        "description": "Pointer to a buffer that receives the data. This address is the address of the buffer within the client process, not the current process."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "BufferToCopy",
        "description": "Pointer to the local buffer whose contents are to be copied into the client address space."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Creates logon sessions.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be the following value or one of the  LSA Policy Function Return Values.  The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "If an authentication package creates extraneous logon sessions while determining whether to authenticate the user, it should delete them by calling  DeleteLogonSession. If the authentication fails, the authentication package should delete all related logon sessions. Because logon sessions use memory in the kernel, it is important to delete any unused or discarded logon sessions. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CreateLogonSession",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an  LUID structure to be assigned to the new logon session. An authentication package calls  AllocateLocallyUniqueId in order to generate this ID."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Deletes an existing credential.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be one of the following values or one of the  LSA Policy Function Return Values.  The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "DeleteCredential",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an  LUID structure containing the session ID of the logon session from which the credential is to be deleted."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationPackage",
        "description": "Authentication package ID of the calling authentication package received in the  LsaApInitializePackage call during DLL initialization."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_STRING",
        "name": "PrimaryKeyValue",
        "description": "Contains the primary lookup key of the credential to be deleted."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Cleans up any logon sessions created while determining whether a user's authentication information is legitimate.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be one of the following values or one of the  LSA Policy Function Return Values.  The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "Because logon sessions use up memory in the kernel, any unused or discarded logon sessions should be deleted. However, logon sessions should not be deleted after a logon ID for the session has been returned to the LSA. After the LSA has been given a logon ID (for example, as a result of a  LsaApLogonUser call), the LSA assumes it is responsible for the logon session and will delete it when the operating system no longer needs it. At this time, the LSA calls  LsaApLogonTerminated to notify the authentication package that the session has been deleted. In contrast, authentication packages are not notified when a logon session is deleted with DeleteLogonSession. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "DeleteLogonSession",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an  LUID structure containing the session ID of logon session to delete."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Frees a client buffer previously allocated with the  AllocateClientBuffer function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "Because this function frees pages in the client's process, it must be called with great care. Calling this function with an address that is not valid can cause the client process to crash. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "FreeClientBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_CLIENT_REQUEST",
        "name": "ClientRequest",
        "description": "Pointer to an opaque  LSA_CLIENT_REQUEST data type containing information about the LSA client's request."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBaseAddress",
        "description": "Optional. Pointer to the buffer to be freed. This address is the virtual address of the buffer within the client process, not in the current process. If NULL is passed, no memory is freed. This allows the client to pass in a value returned to it by the LSA without knowing whether the LSA actually allocated a buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deallocates heap memory previously allocated by  AllocateLsaHeap.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function does not return a value. However, if the function sets Base to NULL, the buffer was freed. If Base is not NULL after the function call ends, the buffer could not be freed. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "FreeLsaHeap",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Base",
        "description": "Pointer to the buffer to be freed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Retrieves credentials associated with a logon session.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the function returns the NTSTATUS code, STATUS_SUCCESS, indicating that the credentials were successfully retrieved. If the function fails, the return value is an NTSTATUS code, which can be one of the following values or one of the  LSA Policy Function Return Values.  The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "GetCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an  LUID structure containing the session ID of the logon session from which credentials are to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationPackage",
        "description": "Authentication package ID of the calling authentication package. Authentication packages should retrieve only their own credentials."
      },
      {
        "in_out": "_Inout_",
        "type": "PULONG",
        "name": "QueryContext",
        "description": "Pointer to an unsigned LONG value used across successive calls to retrieve multiple credentials. The first time this function is used, the value pointed to by this argument should be zero. Thereafter, this value will be updated to allow retrieval to continue where it left off. This value should, therefore, not be changed until all credentials of a given query operation have been retrieved."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "RetrieveAllCredentials",
        "description": "Indicates whether all credentials for the specified logon session should be retrieved (TRUE), or only those matching the specified PrimaryKeyValue (FALSE)."
      },
      {
        "in_out": "_Inout_",
        "type": "PLSA_STRING",
        "name": "PrimaryKeyValue",
        "description": "This parameter serves two purposes. If the RetrieveAllCredentials parameter is FALSE, this string contains the value to use as a primary lookup key. In this case, only credentials belonging to the correct logon session with a primary lookup key matching this value will be retrieved.     If RetrieveAllCredentials is TRUE, the value of this string on input is ignored and the primary lookup key of each credential retrieved is returned in this string."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "PrimaryKeyLength",
        "description": "If the RetrieveAllCredentials parameter is TRUE, this parameter receives the length needed to store the PrimaryKeyValue string."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_STRING",
        "name": "Credentials",
        "description": "Pointer to a buffer that receives the retrieved credential. Only one credential is retrieved for each call made. The credential is returned in a buffer that the function allocates by calling the  AllocateLsaHeap function. It is the caller's responsibility to free the Credentials buffer when it is no longer needed, by calling  FreeLsaHeap."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The AllocateSharedMemory function allocates a block of shared memory from a section of memory previously reserved by a call to the  CreateSharedMemory function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is a pointer to the allocated memory. If the function fails, the return value is NULL. ",
    "remarks": "Reserve a section of shared memory using the  CreateSharedMemory function. Free a block of memory allocated by AllocateSharedMemory using the  FreeSharedMemory function. A pointer to the AllocateSharedMemory function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "PVOID",
    "category": "Authentication",
    "name": "AllocateSharedMemory",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "SharedMem",
        "description": "Pointer to a section of reserved shared memory."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Size",
        "description": "Specifies the amount of shared memory to allocate, in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The AuditAccountLogon function produces an audit record that represents the mapping of a foreign principal name onto a Windows account.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function returns STATUS_SUCCESS. ",
    "remarks": "A pointer to the AuditAccountLogon function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "AuditAccountLogon",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuditId",
        "description": "Security package\u2013defined message identifier. ..."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "Success",
        "description": "Specifies whether the audit record is generated on success or failure of the logon."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "Source",
        "description": "Pointer to a  UNICODE_STRING specifying the source of the logon attempt."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ClientName",
        "description": "Pointer to a UNICODE_STRING specifying the client name."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "MappedName",
        "description": "Pointer to a UNICODE_STRING containing the Windows account name to which the client name was mapped, if any."
      },
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "Status",
        "description": "An NTSTATUS value specifying any error that occurred."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The AuditLogon function is used to audit a logon attempt.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function does not return a value. ",
    "remarks": "A pointer to the AuditLogon function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "AuditLogon",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "Status",
        "description": "Status of the logon attempt."
      },
      {
        "in_out": "_In_",
        "type": "NTSTATUS",
        "name": "SubStatus",
        "description": "Additional status information for the logon attempt."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AccountName",
        "description": "Pointer to a  UNICODE_STRING  that contains the account name used in the logon attempt."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AuthenticatingAuthority",
        "description": "Pointer to a UNICODE_STRING  that contains the name of the authority that authenticated the logon, normally the operating system domain name."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "WorkstationName",
        "description": "Pointer to a  UNICODE_STRING  that contains the name of the workstation used to attempt the logon."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSID",
        "name": "UserSid",
        "description": "Pointer to the SID of the security principal attempting to logon."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "A  SECURITY_LOGON_TYPE value indicating the type of logon."
      },
      {
        "in_out": "_In_",
        "type": "PTOKEN_SOURCE",
        "name": "TokenSource",
        "description": "Pointer to a  TOKEN_SOURCE structure  that specifies the source for the user token. This value must include the package name."
      },
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to the logon session identifier. LogonId is valid only if the logon attempt was successful."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The CallPackage function is used to call another security package to access its services.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. The following table lists a common reason for failure and the error code that the function returns.  ",
    "remarks": "A pointer to the CallPackage function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CallPackage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AuthenticationPackage",
        "description": "Pointer to a  UNICODE_STRING containing the name of the package to call."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "Pointer to the input buffer. The content of this buffer is package-specific."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferLength",
        "description": "Size of the ProtocolSubmitBuffer parameter in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProtocolReturnBuffer",
        "description": "Pointer that receives the address of the output buffer. The content of this buffer is package-specific."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnBufferLength",
        "description": "Pointer to a variable that receives the size of the ProtocolReturnBuffer parameter in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "ProtocolStatus",
        "description": "Pointer to a variable that receives the status code returned by the called package."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The CallPackageEx function is used to call another security package to access its services.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. The following table lists a common reason for failure and the error code that the function returns.  ",
    "remarks": "A pointer to the CallPackageEx function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CallPackageEx",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AuthenticationPackage",
        "description": "Pointer to a  UNICODE_STRING containing the name of the authentication package to call."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBufferBase",
        "description": "The base address of the input buffer, in the client's address space."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "Pointer to the input buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferLength",
        "description": "Size of ProtocolSubmitBuffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProtocolReturnBuffer",
        "description": "Pointer that receives the address of the output buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnBufferLength",
        "description": "Pointer to a variable that receives the size of ProtocolReturnBuffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "ProtocolStatus",
        "description": "Pointer to a variable that receives the status code returned by the authentication package."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The CallPackagePassthrough function is used to call another security package to access its services.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. The following table lists a common reason for failure and the error code that the function returns.  ",
    "remarks": "The Local Security Authority (LSA) does not examine or alter any of the function arguments. A pointer to the CallPackagePassthrough function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CallPackagePassthrough",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AuthenticationPackage",
        "description": "Pointer to a  UNICODE_STRING containing the name of the package to call."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ClientBufferBase",
        "description": "The base address of the input buffer, in the client's address space."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "ProtocolSubmitBuffer",
        "description": "Pointer to the input buffer."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SubmitBufferLength",
        "description": "Size of the ProtocolSubmitBuffer parameter in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProtocolReturnBuffer",
        "description": "Pointer to the output buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ReturnBufferLength",
        "description": "Pointer to a variable that receives the size of the ProtocolReturnBuffer parameter in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "ProtocolStatus",
        "description": "Pointer to a variable that receives the status code returned by the package."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CancelNotification function cancels a previously registered notification.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. The following table lists a common reason for failure and the error code that the function returns.  ",
    "remarks": "Use the  RegisterNotification function to register a notification. A pointer to the CancelNotification function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CancelNotification",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "NotifyHandle",
        "description": "Handle returned by a previous call to  RegisterNotification."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The ClientCallback function allows a Local Security Authority (LSA)-mode security package to call back to its user-mode package and invoke a function in its DLL there.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the function returns STATUS_SUCCESS. If the function fails, it returns an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "A pointer to the ClientCallback function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. The user-mode security package must use the  RegisterCallback function to register the function to be called. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "ClientCallback",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCHAR",
        "name": "Callback",
        "description": "A pointer to the name of the function to invoke. For more information, see ClientCallback_Function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "Argument1",
        "description": "A pointer to the first argument to pass to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "Argument2",
        "description": "A pointer to the second argument to pass to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "Input",
        "description": "A pointer to a  SecBuffer structure that contains information to pass to the callback function."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "Output",
        "description": "A pointer to a SecBuffer structure that receives information passed from the callback function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "The value returned by this function is ignored. ",
    "remarks": "The implementation of this function is accessed by means of the  ClientCallback function. ",
    "return_type": "void",
    "category": "Authentication",
    "name": "ClientCallback_Function",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "Argument1",
        "description": "First argument to the function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "Argument2",
        "description": "Second argument to the function."
      },
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "InputBuffer",
        "description": "A pointer to a  SecBuffer structure that contains information to pass to the function."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "OutputBuffer",
        "description": "A pointer to a  SecBuffer structure that receives information passed from the function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CloseSamUser function closes a handle to a Security Accounts Manager (SAM) user account.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason. The following table lists a common reason for failure and the error code that the function returns.  ",
    "remarks": "A pointer to the CloseSamUser function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CloseSamUser",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "UserHandle",
        "description": "A handle to the SAM user account previously opened using the  OpenSamUser function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 10,
    "description": "The ConvertAuthDataToToken function creates an access token from the authorization data returned from the  GetAuthDataForUser or  GetUserAuthData functions.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. ",
    "remarks": "A pointer to the ConvertAuthDataToToken function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "ConvertAuthDataToToken",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "UserAuthData",
        "description": "Pointer to the authorization data received from the  GetAuthDataForUser or  GetUserAuthData functions."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "UserAuthDataSize",
        "description": "Size, in bytes, of the authorization data specified by the UserAuthData parameter."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_IMPERSONATION_LEVEL",
        "name": "ImpersonationLevel",
        "description": "A  SECURITY_IMPERSONATION_LEVEL value specifying the impersonation level for the token to be created."
      },
      {
        "in_out": "_In_",
        "type": "PTOKEN_SOURCE",
        "name": "TokenSource",
        "description": "Pointer to a  TOKEN_SOURCE structure specifying the source to record in the token."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "A  SECURITY_LOGON_TYPE value indicating the type of logon to record in the token."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AuthorityName",
        "description": "Pointer to a  UNICODE_STRING structure that specifies the name of the authority that authorized this user, typically a domain name."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Token",
        "description": "Pointer to a HANDLE that receives the user token handle. When you have finished using the user token, release the handle by calling CloseHandle."
      },
      {
        "in_out": "_Out_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to an LUID that receives the logon identifier for the token."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "AccountName",
        "description": "Pointer to a  UNICODE_STRING structure that receives the account name encoded in the UserAuthData parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "SubStatus",
        "description": "Pointer to a variable that receives additional information about the return value of the function call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "The CrackSingleName function converts a name from one format to another.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the function returns STATUS_SUCCESS. If the function fails, it returns STATUS_UNSUCCESSFUL. For more information, see the value returned in the SubStatus parameter. ",
    "remarks": "A pointer to the CrackSingleName function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CrackSingleName",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "FormatOffered",
        "description": "The format of the input name. The following table contains the valid values for this parameter.  ValueMeaning  DS_CANONICAL_NAME   Complete canonical name (for example, example.microsoft.com/software/someone). The domain-only version includes a trailing forward slash (/).   DS_CANONICAL_NAME_EX   Same as DS_CANONICAL_NAME except that the rightmost forward slash (/) is replaced with a newline character (\\n), even in a domain-only case (for example, example.microsoft.com/software\\nsomeone).   DS_DISPLAY_NAME   A \"friendly\" display name. The display name is not necessarily the defining relative distinguished name (RDN).   DS_FQDN_1779_NAME   Fully qualified distinguished name (for example, CN=NameOfPerson,OU=Users,DC=Example,DC=Fabrikam,DC=Com).   DS_NT4_ACCOUNT_NAME   Windows account name (for example, Example\\Name). The domain-only version includes trailing backslashes (\\\\).   DS_SERVICE_PRINCIPAL_NAME   Generalized service principal name (for example, www/www.microsoft.com@microsoft.com).   DS_SID_OR_SID_HISTORY_NAME   A security identifier (SID) for the object. This can be either the current SID or a SID from the object's SID history. The SID string can use either the standard string representation of a SID, or one of the string constants defined in Sddl.h. For information about converting a binary SID into a SID string, see SID Strings. This value is not valid for the formatDesired parameter.   DS_UNIQUE_ID_NAME   GUID string that the  IIDFromString function returns (for example, {4fa050f0-f561-11cf-bdd9-00aa003a77b6}).   DS_UNKNOWN_NAME   Unknown name type.   DS_USER_PRINCIPAL_NAME   User principal name (for example, someone@example.microsoft.com)."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "PerformAtGC",
        "description": "Specifies whether to perform the translation at a global catalog server."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "NameInput",
        "description": "A pointer to a  UNICODE_STRING structure that contains the name to convert."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "Prefix",
        "description": "A pointer to a UNICODE_STRING structure that specifies a prefix for the name."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "RequestedFormat",
        "description": "The requested format of the cracked name. For a list of valid values, see the FormatOffered parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "CrackedName",
        "description": "A pointer to a UNICODE_STRING structure that receives the reformatted name."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "DnsDomainName",
        "description": "A pointer to a UNICODE_STRING structure that receives the name of the domain that owns the name specified by the NameInput parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "SubStatus",
        "description": "A pointer to a variable that receives additional information about the return value of the function call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CreateSharedMemory function creates a section of memory that is shared by client processes and the security package.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "The function returns a pointer to the block of shared memory, or NULL if the block was not reserved. ",
    "remarks": "Creating a shared section for each client is not advisable because it is a resource-intensive operation and may exhaust system resources. The package's clients can write to shared memory which makes it susceptible to attack. Data in the shared segment should not be trusted. The pointer returned by the CreateSharedMemory function is required by the  AllocateSharedMemory,  DeleteSharedMemory, and  FreeSharedMemory functions. Use the DeleteSharedMemory function to release memory reserved by the CreateSharedMemory function. Pointers to these functions are available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "PVOID NTAPI",
    "category": "Authentication",
    "name": "CreateSharedMemory",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaxSize",
        "description": "Specifies the maximum size of the shared memory."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "InitialSize",
        "description": "Specifies the initial size of the shared memory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 13,
    "description": "The CreateToken function is used by SSP/APs to create tokens while processing calls to  SpAcceptLsaModeContext.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "A pointer to the CreateToken function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "CreateToken",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Pointer to a logon session identifier for the new token. This identifier is obtained from a previous call to  CreateLogonSession."
      },
      {
        "in_out": "_In_",
        "type": "PTOKEN_SOURCE",
        "name": "TokenSource",
        "description": "Pointer to a  TOKEN_SOURCE structure that specifies the source for this token. Specify the package name."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "A  SECURITY_LOGON_TYPE value that indicates the type of logon."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_IMPERSONATION_LEVEL",
        "name": "ImpersonationLevel",
        "description": "A  SECURITY_IMPERSONATION_LEVEL value that indicates the extent to which a server process can impersonate a client process."
      },
      {
        "in_out": "_In_",
        "type": "LSA_TOKEN_INFORMATION_TYPE",
        "name": "TokenInformationType",
        "description": "Specifies the type of structure in the TokenInformation parameter.      \t\t\t\t\t  ValueMeaning  LsaTokenInformationNull    LSA_TOKEN_INFORMATION_NULL    LsaTokenInformationV1    LSA_TOKEN_INFORMATION_V1"
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "TokenInformation",
        "description": "Pointer to the token information. The type of structure pointed to by TokenInformation is indicated by the TokenInformationType parameter. If the structure pointed to by this parameter is an LSA_TOKEN_INFORMATION_V1 structure, the caller must allocate the memory for the Groups member of that structure by calling the AllocatePrivateHeap function."
      },
      {
        "in_out": "_In_",
        "type": "PTOKEN_GROUPS",
        "name": "TokenGroups",
        "description": "Pointer to a  TOKEN_GROUPS structure that specifies groups not contained in TokenInformation."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AccountName",
        "description": "Pointer to a  UNICODE_STRING structure that contains the name of the security principal. This information is used for auditing and name searches."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "AuthorityName",
        "description": "Pointer to a UNICODE_STRING structure that contains the name of the authority that validated the logon credentials, normally the Windows domain name."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "Workstation",
        "description": "Pointer to a UNICODE_STRING structure that contains the name of the client's workstation, normally a NetBIOS name."
      },
      {
        "in_out": "_In_",
        "type": "PUNICODE_STRING",
        "name": "ProfilePath",
        "description": "Pointer to a UNICODE_STRING structure that contains the path to the user's profile, if any."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Token",
        "description": "Pointer that receives the address of a handle to the new token. When you have finished using the handle, close it by calling the CloseHandle function."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "SubStatus",
        "description": "Pointer to a variable that receives error information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The DeleteSharedMemory function releases a section of memory that is shared by clients and a security package.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. ",
    "remarks": "The DeleteSharedMemory function releases the shared memory reserved by the  CreateSharedMemory function. To release shared memory allocated by the  AllocateSharedMemory function, use the  FreeSharedMemory function. Pointers to these functions are available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "BOOLEAN",
    "category": "Authentication",
    "name": "DeleteSharedMemory",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "SharedMem",
        "description": "Pointer to shared memory previously reserved by the  CreateSharedMemory function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The FreeReturnBuffer function is used to free buffers allocated by the Local Security Authority (LSA) and returned to the security package. The package calls this function when the information in the returned buffer is no longer needed.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function does not return a value. ",
    "remarks": "A pointer to the FreeReturnBuffer function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "void",
    "category": "Authentication",
    "name": "FreeReturnBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Base",
        "description": "Pointer to the buffer to free."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The FreeSharedMemory function frees a block of shared memory previously allocated by the  AllocateSharedMemory function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function does not return a value. ",
    "remarks": "A pointer to the FreeSharedMemory function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "FreeSharedMemory",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "SharedMem",
        "description": "Pointer to the shared memory section previously reserved using the  CreateSharedMemory function."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Memory",
        "description": "Pointer to the memory previously allocated from the shared memory section specified by the SharedMem parameter, using the  AllocateSharedMemory function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The GetAuthDataForUser function retrieves authentication information for a user from the Security Accounts Manager (SAM) database and puts it into a format suitable for the  ConvertAuthDataToToken function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code that indicates the reason it failed. ",
    "remarks": "The GetAuthDataForUser function combines the  OpenSamUser,  GetUserAuthData, and  CloseSamUser functions into one call. Pointers to these functions are available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "GetAuthDataForUser",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_STRING",
        "name": "Name",
        "description": "Pointer to a  UNICODE_STRING structure that specifies the name of the SAM account."
      },
      {
        "in_out": "_In_",
        "type": "SECPKG_NAME_TYPE",
        "name": "NameType",
        "description": "A  SECPKG_NAME_TYPE enumeration value that specifies the type of account name in Name. This parameter can be one of the following values.  ValueMeaning  SecNameSamCompatible   Name is compatible with the SAM. An example of a name in SAM-compatible format is \"ExampleDomain\\Username\".   SecNameAlternateId   Name is in the AltSecId property of the SAM account. You must specify a value for the Prefix parameter when using this value.   SecNameFlat   Name is a flat user principal name (UPN) style account name.   SecNameDN   Name is the distinguished name of the object. For more information, see  Remarks."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_STRING",
        "name": "Prefix",
        "description": "Pointer to a  UNICODE_STRING structure that contains the prefix to use for names specified with the SecNameAlternateId NameType."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "*UserAuthData",
        "description": "Pointer that receives the address of the retrieved data."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "UserAuthDataSize",
        "description": "Pointer to a ULONG that receives the size of the retrieved data."
      },
      {
        "in_out": "_Out_",
        "type": "PUNICODE_STRING",
        "name": "UserFlatName",
        "description": "Pointer to a  UNICODE_STRING structure that receives the UPN, if applicable."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetCallInfo function retrieves information about the most recent function call.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. ",
    "remarks": "A pointer to the GetCallInfo function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "BOOLEAN",
    "category": "Authentication",
    "name": "GetCallInfo",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSECPKG_CALL_INFO",
        "name": "Info",
        "description": "Pointer to a  SECPKG_CALL_INFO structure that receives information about the call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetClientInfo function gets information about the client process, such as thread and process ID, and flags indicating the client's state and privileges.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. ",
    "remarks": "A pointer to the GetClientInfo function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "GetClientInfo",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PSECPKG_CLIENT_INFO",
        "name": "ClientInfo",
        "description": "Pointer to a  SECPKG_CLIENT_INFO structure that receives information about the client."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetUserAuthData function returns the authorization data for the user in a single buffer.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. ",
    "remarks": "The authorization data returned by the GetUserAuthData function can be passed to the  ConvertAuthDataToToken function. A pointer to the GetUserAuthData function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "GetUserAuthData",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "UserHandle",
        "description": "A handle to the user account. This handle is returned by the  OpenSamUser function."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "*UserAuthData",
        "description": "Pointer that receives the consolidated authorization data. When you have finished using the authorization data, free the memory by calling the FreeLsaHeap function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "UserAuthDataSize",
        "description": "Pointer that receives the size of the authorization data."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The ImpersonateClient function is called by security packages to impersonate the package user.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. ",
    "remarks": "If the call to ImpersonateClient fails, the client connection is not impersonated and the client request is made in the security context of the process. If the process is running as a highly privileged account, such as LocalSystem, or as a member of an administrative group, the user may be able to perform actions they would otherwise be disallowed. Therefore, it is important to always check the return value of the call, and if it fails, raise an error; do not continue execution of the client request. To end the impersonation, call the  RevertToSelf function. All impersonate functions, including ImpersonateClient allow the requested impersonation if one of the following is true: Windows XP with SP1 and earlier:  The SeImpersonatePrivilege privilege is not supported. A pointer to the ImpersonateClient function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "ImpersonateClient",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The MapBuffer function maps a  SecBuffer structure into the address space of the security support provider/authentication package (SSP/AP).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. ",
    "remarks": "If the  SecBuffer has already been mapped, the MapBuffer function copies the contents of the input buffer over the output buffer. A pointer to the MapBuffer function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "MapBuffer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSecBuffer",
        "name": "InputBuffer",
        "description": "Pointer to the  SecBuffer structure to map."
      },
      {
        "in_out": "_Out_",
        "type": "PSecBuffer",
        "name": "OutputBuffer",
        "description": "Pointer that receives the address of the mapped  SecBuffer structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves a handle to a user account in the Security Accounts Manager (SAM) database.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is one of the following  NTSTATUS error codes that indicates the reason for  failure.  ",
    "remarks": "To close the handle received by the UserHandle parameter,   call the  CloseSamUser function. The distinguished name of a user identifies the name, domain, and the complete path to the  Active Directory object that represents the user. A pointer to the OpenSamUser function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "OpenSamUser",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECURITY_STRING",
        "name": "Name",
        "description": "Pointer to a  UNICODE_STRING structure that specifies the name of the SAM account."
      },
      {
        "in_out": "_In_",
        "type": "SECPKG_NAME_TYPE",
        "name": "NameType",
        "description": "A  SECPKG_NAME_TYPE enumeration value that specifies the type of account name in Name. ..."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_STRING",
        "name": "Prefix",
        "description": "Pointer to a  UNICODE_STRING structure that specifies the prefix to use with names that use a NameType of SecNameAlternateId."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "AllowGuest",
        "description": "Specifies whether to use the Guest account if the SAM account is not found. This parameter can be one of the following values.  ValueMeaning  FALSE   If the user is not found, the OpenSamUser function call fails.   TRUE   If the user is not found and the Guest account is enabled, the Guest account is used."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Reserved",
        "description": "Reserved. Specify zero."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*UserHandle",
        "description": "Pointer to a pointer that receives a handle to the user account."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Provides a mechanism whereby the security package is notified. Notification can occur at fixed intervals, when an event object is signaled, or during certain system events.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is a handle to the notification. If the function fails, the return value is NULL. ",
    "remarks": "If you specify the NOTIFY_CLASS_PACKAGE_CHANGE value for the NotificationClass parameter, the following values represent valid changes.  A pointer to the RegisterNotification function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "HANDLE",
    "category": "Authentication",
    "name": "RegisterNotification",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SEC_THREAD_START",
        "name": "StartFunction",
        "description": "The function that is called to accept notification."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Parameter",
        "description": "The argument of the function specified in the StartFunction parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NotificationType",
        "description": "Specifies the type of notification. The following table lists the valid values.  ValueMeaning  NOTIFIER_TYPE_INTERVAL   Notify at fixed intervals. Use the IntervalMinutes parameter to indicate the interval length.   NOTIFIER_TYPE_HANDLE_WAIT   Notify when the event handle specified by the WaitEvent parameter is signaled.   NOTIFIER_TYPE_STATE_CHANGE   Notify when there is a change in the machine's domain or installation type.   NOTIFIER_TYPE_NOTIFY_EVENT   Notify when a security event takes place. Use the NotificationClass parameter to specify the event of interest.   NOTIFIER_TYPE_IMMEDIATE   Notify immediately. This value implies NOTIFIER_FLAG_ONE_SHOT."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NotificationClass",
        "description": "Specifies the class of events that generate notifications. Specify zero unless the NotificationType parameter is set to NOTIFIER_TYPE_NOTIFY_EVENT.  ValueMeaning  NOTIFY_CLASS_PACKAGE_CHANGE   A package was loaded, or a new package was selected as the preferred package. For more information, see Remarks.   NOTIFY_CLASS_ROLE_CHANGE   Reserved for internal use.   NOTIFY_CLASS_DOMAIN_CHANGE   Reserved for internal use."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "NotificationFlags",
        "description": "Specifies flags that control notification behavior.  ValueMeaning  NOTIFIER_FLAG_NEW_THREAD   Wait for notification using a new thread.   NOTIFIER_FLAG_ONE_SHOT   Notify only once.   NOTIFIER_FLAG_SECONDS   The IntervalMinutes parameter specifies seconds."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "IntervalMinutes",
        "description": "Specifies the time delay between notifications."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "WaitEvent",
        "description": "Optional. Handle to an event object. When the object is signaled, the notification occurs. This value is used in conjunction with the NotificationType value NOTIFIER_TYPE_HANDLE_WAIT."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Unloads an security support provider/authentication package (SSP/AP).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "The function returns STATUS_SUCCESS. ",
    "remarks": "A pointer to the UnloadPackage function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "UnloadPackage",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Provides a mechanism for one security package to notify other packages that the credentials for a logon session have changed.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. ",
    "remarks": "To notify packages about the changed credentials, the Local Security Authority (LSA) calls the  SpAcceptCredentials function implementation in each package. A pointer to the UpdateCredentials function is available in the  LSA_SECPKG_FUNCTION_TABLE structure received by the  SpInitialize function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "UpdateCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSECPKG_PRIMARY_CRED",
        "name": "PrimaryCredentials",
        "description": "Pointer to a  SECPKG_PRIMARY_CRED structure containing the primary credentials."
      },
      {
        "in_out": "_In_opt_",
        "type": "PSECPKG_SUPPLEMENTAL_CRED_ARRAY",
        "name": "Credentials",
        "description": "Optional. Pointer to a  SECPKG_SUPPLEMENTAL_CRED_ARRAY structure containing the supplemental credentials."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The AllocateHeap function allocates memory on the heap. Memory allocated with this routine must be freed using the  FreeHeap function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function returns a pointer to the allocated memory. If memory could not be allocated, the function returns NULL. ",
    "remarks": "To free memory allocated by the AllocateHeap function use the  FreeHeap function. A pointer to the AllocateHeap function is available in the  SECPKG_DLL_FUNCTIONS structure received from the  SpInstanceInit function. ",
    "return_type": "PVOID",
    "category": "Authentication",
    "name": "AllocateHeap",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Length",
        "description": "Number of bytes to allocate."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The FreeHeap function releases memory previously allocated by the  AllocateHeap function.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "This function does not return a value. However, if the function sets Base to NULL, the buffer was freed. If Base is not NULL after the function call ends, the buffer could not be freed. ",
    "remarks": "A pointer to the FreeHeap function is available in the  SECPKG_DLL_FUNCTIONS structure received from the  SpInstanceInit function. ",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "FreeHeap",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PVOID",
        "name": "Base",
        "description": "Pointer to the buffer to be freed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Registers user-mode callback functions. The RegisterCallback function is called by a user-mode security package.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason it failed. ",
    "remarks": "The registered function is accessed by means of the  ClientCallback function. A pointer to the RegisterCallback function is available in the  SECPKG_DLL_FUNCTIONS structure received from the  SpInstanceInit function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "RegisterCallback",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "CallbackId",
        "description": "Specifies an identifier for the function."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_CALLBACK_FUNCTION",
        "name": "Callback",
        "description": "Specifies the callback function that will execute in the user's process space. For information about the prototype for this function, see  ClientCallback Function Prototype."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The WlxActivateUserShell function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the function successfully starts a shell process, the function returns TRUE. If the function fails, it returns FALSE. When FALSE is returned, Winlogon cancels the logon in process. ",
    "remarks": "Before calling WlxActivateUserShell, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. Always activate the user shell program in WlxActivateUserShell rather than  WlxLoggedOutSAS. This gives Winlogon a chance to update its state, including setting workstation and desktop protections, before any logged-on user processes are allowed to run. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxActivateUserShell",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. This is the context value that the GINA returns when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "pszDesktopName",
        "description": "A pointer to a null-terminated wide character string that specifies the name of the desktop where the shell will start. Pass this string to the  CreateProcess or  CreateProcessAsUser function through the lpDesktop member of the  STARTUPINFO structure."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "pszMprLogonScript",
        "description": "A pointer to a null-terminated wide character string that specifies any script names returned from the network provider DLLs. Network provider DLLs can return scripts to be executed during logon; however, the GINA may ignore them."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pEnvironment",
        "description": "Specifies the initial environment variables for the process. Winlogon creates a copy of the environment and hands it off to the GINA. The GINA can modify this environment before using it to initialize the user's shell. The GINA should call the VirtualFree function to free the memory allocated for pEnvironment."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxDisplayLockedNotice function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function has no return values. ",
    "remarks": "To display lock information, the GINA must display a dialog box that will be interrupted by a WLX_WM_SAS message. For more information, see  Sending Messages to the GINA. Before calling WlxDisplayLockedNotice, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "WlxDisplayLockedNotice",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the GINA context associated with this window station. This is the context value that the GINA returns when Winlogon calls  WlxInitialize for this station."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxDisplaySASNotice function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function does not return a value. ",
    "remarks": "Before calling WlxDisplaySASNotice, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "void",
    "category": "Authentication",
    "name": "WlxDisplaySASNotice",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. This is the context value that the GINA returns when Winlogon calls  WlxInitialize for this station."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[The WlxDisplayStatusMessage function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": " ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxDisplayStatusMessage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_In_",
        "type": "HDESK",
        "name": "hDesktop",
        "description": "A handle to the desktop where the status message should be displayed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOptions",
        "description": "Specifies display options for the status dialog box. The following options are valid:     STATUSMSG_OPTION_NOANIMATION STATUSMSG_OPTION_SETFOREGROUND"
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "pTitle",
        "description": "Pointer to a null-terminated wide character string that specifies the title of the message to be displayed."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "pMessage",
        "description": "Pointer to a null-terminated wide character string that specifies the message to be displayed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The WlxGetConsoleSwitchCredentials function must be implemented by a replacement GINA DLL. Winlogon calls this function to read the currently logged on user's credentials to transparently transfer them to a target session.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "Returns TRUE on success and FALSE on failure. ",
    "remarks": "",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "WlxGetConsoleSwitchCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to a GINA-specific context."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "pInfo",
        "description": "Pointer to a WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 to return GINA relevant information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The WlxGetStatusMessage function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": " ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxGetStatusMessage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_Out_",
        "type": "DWORD",
        "name": "*pdwOptions",
        "description": "Pointer to a DWORD that will hold the display options for the current status message."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR",
        "name": "pMessage",
        "description": "Returns the current status message text."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwBufferSize",
        "description": "Size of the pMessage buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[The WlxInitialize function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the function successfully initializes the GINA DLL, the function returns TRUE. If the function fails, or if the GINA DLL was not initialized, the function returns FALSE. Winlogon will terminate, and the system will not boot. ",
    "remarks": "WlxInitialize is called once for each window station present on the computer. Currently only a single window station called Winsta0 is supported. Before calling WlxInitialize, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxInitialize",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpWinsta",
        "description": "A pointer to the name of the window station being initialized."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "A handle to Winlogon. The GINA must supply this handle in all calls to Winlogon support functions that involve this window station."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pvReserved",
        "description": "This parameter is reserved for future use and must be set to NULL."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWinlogonFunctions",
        "description": "A pointer to a Winlogon support function dispatch table. The contents of the table depend on the GINA DLL version returned by the  WlxNegotiate call. This table does not change, which allows the GINA DLL to reference the table without copying it. If the GINA DLL needs to make a copy of the table, it should call WlxGetOption and supply WLX_OPTION_DISPATCH_TABLE_SIZE for the Option parameter.  ValueMeaning  WLX_DISPATCH_VERSION_1_4   Winlogon dispatch table - version 1.4   WLX_DISPATCH_VERSION_1_3    \t\t\t\t\t\t\t\tWinlogon dispatch table - version 1.3   WLX_DISPATCH_VERSION_1_2    \t\t\t\t\t\t\t\tWinlogon dispatch table - version 1.2   WLX_DISPATCH_VERSION_1_1    \t\t\t\t\t\t\t\tWinlogondispatch table - version 1.1   WLX_DISPATCH_VERSION_1_0    \t\t\t\t\t\t\t\tWinlogon dispatch table - version 1.0"
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*pWlxContext",
        "description": "A pointer to a pointer to a VOID that will contain the address of the GINA context for this window station. This context is passed in all subsequent calls to the GINA from Winlogon. The GINA DLL manages any memory used by the context. The context pointer can be changed later by calling the WlxSetOption function with WLX_OPTION_CONTEXT_POINTER."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxIsLockOk function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": " ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxIsLockOk",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the GINA context associated with this window station. The GINA supplies this context when Winlogon calls  WlxInitialize."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxIsLogoffOk function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": " ",
    "remarks": "WlxIsLogoffOk can return FALSE to prevent the user from logging off the workstation. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxIsLogoffOk",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "[The WlxLoggedOnSAS function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxLoggedOnSAS function should return one of the following values.  ",
    "remarks": "Winlogon calls WlxLoggedOnSAS when the logged-on user wants to shut down, log out, or lock the workstation. The GINA DLL can lock the workstation by returning WLX_SAS_ACTION_LOCK_WKSTA. When this value is returned, Winlogon locks the workstation and calls  WlxWkstaLockedSAS the next time it receives an SAS. Before calling WlxLoggedOnSAS, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxLoggedOnSAS",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSasType",
        "description": "Specifies the type of SAS that occurred. Values from zero to WLX_SAS_TYPE_MAX_MSFT_VALUE are reserved to define standard Microsoft SAS types. GINA developers can define additional SAS types by using values greater than WLX_SAS_TYPE_MAX_MSFT_VALUE. The following SAS types are predefined.  ValueMeaning  WLX_SAS_TYPE_TIMEOUT 0 (0x0)   Indicates that no user input was received within the specified time-out period.   WLX_SAS_TYPE_CTRL_ALT_DEL 1 (0x1)   Indicates that a user has typed the standard CTRL+ALT+DEL secure attention sequence (SAS).   WLX_SAS_TYPE_SC_INSERT 5 (0x5)   Indicates that a smart card has been inserted into a compatible device.   WLX_SAS_TYPE_SC_REMOVE 6 (0x6)   Indicates that a smart card has been removed from a compatible device."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pReserved",
        "description": "This parameter is reserved and must be set to NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "[The WlxLoggedOutSAS function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the function fails, the function returns zero. If the function succeeds, it returns one of the following values.  ",
    "remarks": "Before calling WlxLoggedOutSAS, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. Do not activate the user shell program in WlxLoggedOutSAS. The user shell program should always be activated in  WlxActivateUserShell. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxLoggedOutSAS",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSasType",
        "description": "Specifies the type of SAS that occurred. Values from zero to WLX_SAS_TYPE_MAX_MSFT_VALUE are reserved to define standard Microsoft SAS types. GINA developers can define additional SAS types by using values greater than WLX_SAS_TYPE_MAX_MSFT_VALUE. The following SAS types are predefined.  ValueMeaning  WLX_SAS_TYPE_CTRL_ALT_DEL   Indicates that a user has typed the standard CTRL+ALT+DEL SAS.   WLX_SAS_TYPE_SC_INSERT   Indicates that a smart card has been inserted into a compatible device.   WLX_SAS_TYPE_SC_REMOVE   Indicates that a smart card has been removed from a compatible device.   WLX_SAS_TYPE_TIMEOUT   Indicates that no user input was received within the specified time-out period."
      },
      {
        "in_out": "_Out_",
        "type": "PLUID",
        "name": "pAuthenticationId",
        "description": "Specifies the authentication identifier associated with the current logon session. You can get this value by calling GetTokenInformation to obtain a TOKEN_STATISTICS structure for the token returned by the LogonUser function."
      },
      {
        "in_out": "_Inout_",
        "type": "PSID",
        "name": "pLogonSid",
        "description": "On input, this parameter points to a security identifier (SID) that is unique to the current logon session. Winlogon uses this SID to change the protection on the window station and application desktop so that the new logged-on user can access them. On output, Winlogon provides a SID. You can also get the SID by using the GetTokenInformation function to retrieve a TOKEN_GROUPS structure for the token returned by the LogonUser function. To do this, search the array returned in the TOKEN_GROUPS structure for the group with the SE_GROUP_LOGON_ID attribute."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "pdwOptions",
        "description": "A pointer to a DWORD that contains the set of logon options. The following option is defined.  ValueMeaning  WLX_LOGON_OPT_NO_PROFILE    Indicates that Winlogon must not load a profile for the logged-on user. Either the GINA DLL will take care of this activity, or the user does not need a profile."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "phToken",
        "description": "A pointer to a handle variable. When the logon operation succeeds, set this handle to a token that represents the logged-on user. Use the LogonUser function to get this token, then, when the user logs off, Winlogon closes this handle and calls the  WlxLogoff function. If you need this handle after calling the WlxLogoff function, make a duplicate of the handle before returning it to Winlogon."
      },
      {
        "in_out": "_Out_",
        "type": "PWLX_MPR_NOTIFY_INFO",
        "name": "pNprNotifyInfo",
        "description": "A pointer to an  WLX_MPR_NOTIFY_INFO structure that contains domain, user name, and password information for the user. Winlogon will use this information to provide identification and authentication information to network providers. The GINA is not required to return password information. Any NULL fields within the structure will be ignored by Winlogon. Use LocalAlloc to allocate each string; Winlogon will free them when they are no longer needed. The GINA should provide domain, user, and password values for  complete Session Directory functionality.  If the password is not provided, Session Directory will require the user to input the password twice before the user is connected to the server. For information about protecting passwords, see Handling Passwords."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*pProfile",
        "description": "On return from a successful authentication, the pProfile parameter points to either a  WLX_PROFILE_V1_0 or a  WLX_PROFILE_V2_0 structure. The first DWORD in the structure indicates which structure it is. Winlogon uses this structure to load the profile of the logged-on user, and frees the memory associated with the structure when it no longer needs it."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxLogoff function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function does not return a value. ",
    "remarks": "Before calling WlxLogoff, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "void",
    "category": "Authentication",
    "name": "WlxLogoff",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxNegotiate function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the Winlogon version specified by dwWinLogonVersion is greater than or equal to the version returned in pdwDllVersion, the function returns TRUE. When TRUE is returned, Winlogon will continue to initialize. If dwWinLogonVersion is less than pdwDllVersion, the function returns FALSE. When FALSE is returned, Winlogon will terminate and the system will not boot. ",
    "remarks": "Before calling WlxNegotiate, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxNegotiate",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwWinLogonVersion",
        "description": "Specifies which version of Winlogon will be communicating with the GINA."
      },
      {
        "in_out": "_Out_",
        "type": "PDWORD",
        "name": "pdwDllVersion",
        "description": "Indicates which version of Winlogon the GINA supports. This version information is also used by Winlogon to determine which dispatch table is passed to the GINA in subsequent calls to  WlxInitialize. This version cannot be greater than the version specified by dwWinLogonVersion."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxNetworkProviderLoad function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": " ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxNetworkProviderLoad",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_Out_",
        "type": "PWLX_MPR_NOTIFY_INFO",
        "name": "pNprNotifyInfo",
        "description": "Points to an  WLX_MPR_NOTIFY_INFO structure that contains domain, user name, and password information for the user. Winlogon will use this information to provide identification and authentication information to network providers.     The GINA is not required to return password information. Any NULL fields within the structure will be ignored by Winlogon. Use LocalAlloc to allocate each string; Winlogon will free them when they are no longer needed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxRemoveStatusMessage function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": " ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxRemoveStatusMessage",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxScreenSaverNotify function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the screen saver should be activated, the function returns TRUE. If the screen saver should not be activated, the function returns FALSE. ",
    "remarks": "If your GINA DLL does not export this function, Winlogon uses the following default behavior. Before calling WlxScreenSaverNotify, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxScreenSaverNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_Inout_",
        "type": "BOOL",
        "name": "*pSecure",
        "description": "A pointer to a Boolean value that, on input, specifies whether the current screen saver is secure and,     on output, indicates whether the workstation should be locked."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxShutdown function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function does not return a value. ",
    "remarks": "Winlogon calls WlxShutdown after the user has logged off and the  WlxLogoff function has been called. Before calling WlxShutdown, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "void",
    "category": "Authentication",
    "name": "WlxShutdown",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ShutdownType",
        "description": "Specifies the type of shutdown. This parameter can be one of the following values.  ValueMeaning  WLX_SAS_ACTION_SHUTDOWN 5 (0x5)   Logs the user off and shuts down the computer.   WLX_SAS_ACTION_SHUTDOWN_REBOOT 11 (0xB)   Shuts down and restarts the computer.   WLX_SAS_ACTION_SHUTDOWN_POWER_OFF 10 (0xA)   Shuts down and turns off the computer, if the hardware allows."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The WlxStartApplication function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the function successfully starts the application, the function returns TRUE. If the function fails or the application did not start, the function returns FALSE. ",
    "remarks": "Before calling WlxStartApplication, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. If the WlxStartApplication function is not exported by the GINA, Winlogon will execute the process. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxStartApplication",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "pszDesktopName",
        "description": "Specifies the name of the desktop on which to start the application. Pass this string to the  CreateProcess or  CreateProcessAsUser function through the lpDesktop member of the  STARTUPINFO structure."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pEnvironment",
        "description": "Specifies the initial environment for the process. Winlogon creates this environment and hands it off to the GINA. The GINA can modify this environment before using it to initialize the shell of the user. When the GINA has finished using this environment, it must free the memory allocated for pEnvironment by calling the VirtualFree function."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "pszCmdLine",
        "description": "The program to execute."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The WlxWkstaLockedSAS function must be implemented by a replacement GINA DLL. Winlogon calls this function when it receives a secure attention sequence (SAS) and the workstation is locked. The GINA should return a value that indicates the workstation is to remain locked, the workstation is to be unlocked, or the logged-on user is to be logged off (which leaves the workstation locked until the logoff is completed).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxWkstaLockedSAS function should return the following values.  ",
    "remarks": "Before calling WlxWkstaLockedSAS, Winlogon sets the desktop state so that the current desktop is the Winlogon desktop and sets the workstation state so that the desktop is locked. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxWkstaLockedSAS",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "A pointer to the GINA context associated with this window station. The GINA returns this context value when Winlogon calls  WlxInitialize for this station."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSasType",
        "description": "Specifies the type of SAS that occurred. Values from zero to WLX_SAS_TYPE_MAX_MSFT_VALUE are reserved for standard Microsoft SAS types. GINA developers can use values greater than WLX_SAS_TYPE_MAX_MSFT_VALUE to define additional SAS types. The following SAS types are predefined.  ValueMeaning  WLX_SAS_TYPE_CTRL_ALT_DEL   Indicates a user has typed the standard CTRL+ALT+DEL secure attention sequence (SAS).   WLX_SAS_TYPE_SC_INSERT   Indicates that a smart card has been inserted into a compatible device.   WLX_SAS_TYPE_SC_REMOVE   Indicates that a smart card has been removed from a compatible device.   WLX_SAS_TYPE_TIMEOUT   Indicates that no user input was received within the specified time-out period."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The LogonUser function attempts to log a user on to the local computer. The local computer is the computer from which LogonUser was called. You cannot use LogonUser to log on to a remote computer. You specify the user with a user name and domain and authenticate the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a process that runs in the context of the specified user.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the function returns nonzero. If the function fails, it returns zero. To get extended error information, call  GetLastError. ",
    "remarks": " The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations: The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account. The account specified by lpszUsername, must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see  Account Rights Constants. A user is considered logged on if at least one token exists. If you call  CreateProcessAsUser and then close the token, the system considers the user as still logged on until the process (and all child processes) have ended. If the LogonUser call is successful, the system notifies network providers that the logon occurred by calling the provider's NPLogonNotify entry-point function. You can generate a LocalService token by using the following code. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "LogonUser",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpszUsername",
        "description": "A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the user principal name (UPN) format, User@DNSDomainName, the lpszDomain parameter must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpszDomain",
        "description": "A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the lpszUsername account. If this parameter is NULL, the user name must be specified in UPN format. If this parameter is \".\", the function validates the account by using only the local account database."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpszPassword",
        "description": "A pointer to a null-terminated string that specifies the plaintext password for the user account specified by lpszUsername.  When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonType",
        "description": "The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.  ValueMeaning  LOGON32_LOGON_BATCH   This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.   LOGON32_LOGON_INTERACTIVE   This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a terminal server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.   LOGON32_LOGON_NETWORK   This logon type is intended for high performance servers to authenticate plaintext passwords. The LogonUser function does not cache credentials for this logon type.   LOGON32_LOGON_NETWORK_CLEARTEXT   This logon type preserves the name and password in the authentication package, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call LogonUser, verify that the user can access the system across the network, and still communicate with other servers.   LOGON32_LOGON_NEW_CREDENTIALS   This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections. This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.   LOGON32_LOGON_SERVICE   Indicates a service-type logon. The account provided must have the service privilege enabled.   LOGON32_LOGON_UNLOCK   GINAs are no longer supported. Windows Server 2003 and Windows XP:  This logon type is for GINA DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonProvider",
        "description": "Specifies the logon provider. This parameter can be one of the following values.  ValueMeaning  LOGON32_PROVIDER_DEFAULT   Use the standard logon provider for the system. The default security provider is negotiate, unless you pass NULL for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.   LOGON32_PROVIDER_WINNT50   Use the negotiate logon provider.           LOGON32_PROVIDER_WINNT40   Use the NTLM logon provider."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "phToken",
        "description": "A pointer to a handle variable that receives a handle to a token that represents the specified user. You can use the returned handle in calls to the  ImpersonateLoggedOnUser function. In most cases, the returned handle is a primary token that you can use in calls to the  CreateProcessAsUser function. However, if you specify the LOGON32_LOGON_NETWORK flag, LogonUser returns an impersonation token that you cannot use in CreateProcessAsUser unless you call DuplicateTokenEx to convert it to a primary token. When you no longer need this handle, close it by calling the  CloseHandle function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 10,
    "description": "The LogonUserEx function attempts to log a user on to the local computer. The local computer is the computer from which LogonUserEx was called. You cannot use LogonUserEx to log on to a remote computer. You specify the user with a user name and domain and authenticate the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a process  that runs in the context of the specified user.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the function returns  nonzero. If the function fails, it returns  zero. To get extended error information, call  GetLastError. ",
    "remarks": " The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations: The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account. The account specified by lpszUsername must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see  Account Object Access Rights. A user is considered logged on if at least one token exists. If you call  CreateProcessAsUser and then close the token, the user is still logged on until the process (and all child processes) have ended. If the LogonUserEx call is successful, the system notifies network providers that the logon occurred by calling the provider's NPLogonNotify entry-point function. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "LogonUserEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpszUsername",
        "description": "A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the user principal name (UPN) format, user@DNS_domain_name, the lpszDomain parameter must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpszDomain",
        "description": "A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the lpszUsername account. If this parameter is NULL, the user name must be specified in UPN format. If this parameter is \".\", the function validates the account by using only the local account database."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpszPassword",
        "description": "A pointer to a null-terminated string that specifies the plaintext password for the user account specified by lpszUsername.  When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonType",
        "description": "The type of logon operation to perform. This parameter can be one of the following values.  ValueMeaning  LOGON32_LOGON_BATCH   This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The LogonUserEx function does not cache credentials for this logon type.   LOGON32_LOGON_INTERACTIVE   This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a terminal server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.   LOGON32_LOGON_NETWORK   This logon type is intended for high performance servers to authenticate plaintext passwords. The LogonUserEx function does not cache credentials for this logon type.   LOGON32_LOGON_NETWORK_CLEARTEXT   This logon type preserves the name and password in the authentication package, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call LogonUserEx, verify that the user can access the system across the network, and still communicate with other servers. \t\t\t\t\t\t\t   LOGON32_LOGON_NEW_CREDENTIALS   This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections. This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.   LOGON32_LOGON_SERVICE   Indicates a service-type logon. The account provided must have the service privilege enabled.   LOGON32_LOGON_UNLOCK   This logon type is for GINA DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonProvider",
        "description": "The logon provider. This parameter can be one of the following values.  ValueMeaning  LOGON32_PROVIDER_DEFAULT   Use the standard logon provider for the system. The default security provider is NTLM.   LOGON32_PROVIDER_WINNT50   Use the negotiate logon provider. \t\t\t\t\t\t\t   LOGON32_PROVIDER_WINNT40   Use the NTLM logon provider."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PHANDLE",
        "name": "phToken",
        "description": "A pointer to a handle variable that receives a handle to a token that represents the specified user. You can use the returned handle in calls to the  ImpersonateLoggedOnUser function. In most cases, the returned handle is a primary token that you can use in calls to the  CreateProcessAsUser function. However, if you specify the LOGON32_LOGON_NETWORK flag, LogonUserEx returns an impersonation token that you cannot use in CreateProcessAsUser unless you call DuplicateTokenEx to convert the impersonation token to a primary token. When you no longer need this handle, close it by calling the  CloseHandle function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PSID",
        "name": "*ppLogonSid",
        "description": "A pointer to a pointer to a security identifier (SID) that receives the SID of the user logged on. When you have finished using the SID, free it by calling the LocalFree function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "*ppProfileBuffer",
        "description": "A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwProfileLength",
        "description": "A pointer to a DWORD that receives the length of the profile buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PQUOTA_LIMITS",
        "name": "pQuotaLimits",
        "description": "A pointer to a QUOTA_LIMITS structure that receives information about the quotas for the logged on user."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "The LogonUserExExW function attempts to log a user on to the local computer. The local computer is the computer from which LogonUserExExW was called. You cannot use LogonUserExExW to log on to a remote computer. Specify the user by using a user name and domain and authenticate the user by using a plaintext password. If the function succeeds, it receives a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a process  that runs in the context of the specified user.",
    "library": "",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winbasep.h",
    "return_value": "If the function succeeds, the function returns  nonzero. If the function fails, it returns  zero. To get extended error information, call  GetLastError. ",
    "remarks": " The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations: The account specified by lpszUsername must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see  Account Object Access Rights. A user is considered logged on if at least one token exists. If you call  CreateProcessAsUser and then close the token, the user is still logged on until the process (and all child processes) have ended. If the optional pTokenGroups parameter is supplied, LSA will not add either the local SID or the logon SID automatically. ",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "LogonUserExExW",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpszUsername",
        "description": "A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the user principal name (UPN) format, the lpszDomain parameter must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpszDomain",
        "description": "A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the lpszUsername account. If this parameter is NULL, the user name must be specified in UPN format. If this parameter is \".\", the function validates the account by using only the local account database."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpszPassword",
        "description": "A pointer to a null-terminated string that specifies the plaintext password for the user account specified by lpszUsername.  When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonType",
        "description": "The type of logon operation to perform. This parameter can be one of the following values.  ValueMeaning  LOGON32_LOGON_INTERACTIVE 2   This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a terminal server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.   LOGON32_LOGON_NETWORK 3   This logon type is intended for high performance servers to authenticate plaintext passwords. The LogonUserExExW function does not cache credentials for this logon type.   LOGON32_LOGON_BATCH 4   This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The LogonUserExExW function does not cache credentials for this logon type.   LOGON32_LOGON_SERVICE 5   Indicates a service-type logon. The account provided must have the service privilege enabled.   LOGON32_LOGON_UNLOCK 7   This logon type is for GINA DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.   LOGON32_LOGON_NETWORK_CLEARTEXT 8   This logon type preserves the name and password in the authentication package, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call LogonUserExExW, verify that the user can access the system across the network, and still communicate with other servers. \t\t\t\t\t\t\t   LOGON32_LOGON_NEW_CREDENTIALS 9   This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections. This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLogonProvider",
        "description": "The logon provider. This parameter can be one of the following values.  ValueMeaning  LOGON32_PROVIDER_DEFAULT   Use the standard logon provider for the system. The default security provider is NTLM.   LOGON32_PROVIDER_WINNT50   Use the negotiate logon provider. \t\t\t\t\t\t\t   LOGON32_PROVIDER_WINNT40   Use the NTLM logon provider."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTOKEN_GROUPS",
        "name": "pTokenGroups",
        "description": "A pointer to a TOKEN_GROUPS structure that specifies a list of group SIDs that are added to the token that this function receives upon successful logon. Any SIDs added to the token also effect group expansion. For example, if the added SIDs are members of local groups, those groups are also added to the received access token.  If this parameter is not NULL, the caller of this function must have the SE_TCB_PRIVILEGE privilege granted and enabled."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PHANDLE",
        "name": "phToken",
        "description": "A pointer to a handle variable that receives a handle to a token that represents the specified user. You can use the returned handle in calls to the  ImpersonateLoggedOnUser function. In most cases, the returned handle is a primary token that you can use in calls to the  CreateProcessAsUser function. However, if you specify the LOGON32_LOGON_NETWORK flag, LogonUserExExW returns an impersonation token that you cannot use in CreateProcessAsUser unless you call DuplicateTokenEx to convert the impersonation token to a primary token. When you no longer need this handle, close it by calling the  CloseHandle function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PSID",
        "name": "*ppLogonSid",
        "description": "A pointer to a pointer to a SID that receives the SID of the user logged on. When you have finished using the SID, free it by calling the LocalFree function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "*ppProfileBuffer",
        "description": "A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwProfileLength",
        "description": "A pointer to a DWORD that receives the length of the profile buffer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PQUOTA_LIMITS",
        "name": "pQuotaLimits",
        "description": "A pointer to a QUOTA_LIMITS structure that receives information about the quotas for the logged on user."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The WlxAssignShellProtection function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxAssignShellProtection function returns any errors encountered while trying to assign protection. ",
    "remarks": "The Windows API  CreateProcessAsUser function supersedes WlxAssignShellProtection. Call CreateProcessAsUser in  WlxActivateUserShell to create the shell process and set its protections in a single call. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxAssignShellProtection",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "Specifies the handle to a primary token."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hProcess",
        "description": "Specifies the handle to the process to modify. The process must be created in the suspended state, and this should be the handle returned in the  PROCESS_INFORMATION structure."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hThread",
        "description": "Specifies the handle to the initial thread of the process."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "[The WlxChangePasswordNotify function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxChangePasswordNotifyEx function returns zero if the function call succeeds. Any other value indicates an error. ",
    "remarks": "",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxChangePasswordNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "PWLX_MPR_NOTIFY_INFO",
        "name": "pMprInfo",
        "description": "Points to a  WLX_MPR_NOTIFY_INFO structure that contains Multiple Provider Router (MPR) information. Winlogon will call LocalFree to free all the data pointed to by this structure when it is done with it."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwChangeInfo",
        "description": "Changes the information flags from  Network Provider API."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[The WlxChangePasswordNotifyEx function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxChangePasswordNotifyEx function returns zero if the function call succeeds. Any other value indicates an error. ",
    "remarks": "This function supersedes the  WlxChangePasswordNotify function. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxChangePasswordNotifyEx",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "PWLX_MPR_NOTIFY_INFO",
        "name": "pMprInfo",
        "description": "Points to a  WLX_MPR_NOTIFY_INFO structure that contains Multiple Provider Router (MPR) information. Winlogon will call  LocalFree to free all the data pointed to by this structure when it is done with it."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwChangeInfo",
        "description": "Changes the information flags from Network Provider API."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "ProviderName",
        "description": "Specifies the name of a network provider, or NULL to allow the system to notify all network providers."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Reserved",
        "description": "Reserved. Must be set to zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "[The WlxCloseUserDesktop function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the function successfully closes the desktop, the return value is TRUE. If the function fails, it returns FALSE. ",
    "remarks": "In addition to closing the desktop, this function will modify access to the parent window station to remove ACEs added during the creation of the user desktop. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxCloseUserDesktop",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "PWLX_DESKTOP",
        "name": "pDesktop",
        "description": "Specifies a pointer to a  WLX_DESKTOP structure, obtained by calling the  WlxCreateUserDesktop function."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "Specifies the handle to the token of the user whose desktop is to be closed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[The WlxCreateUserDesktop function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxCreateUserDesktop function returns one of the following values.  ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxCreateUserDesktop",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "Specifies the handle to the token of the user for whom the desktop is being created."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Specifies access to the desktop. Specify one of the following.      ValueMeaning  WLX_CREATE_INSTANCE_ONLY   Specifies that only this instance of the user has access.   WLX_CREATE_USER   Specifies that any instance of this user has access."
      },
      {
        "in_out": "_In_",
        "type": "PWSTR",
        "name": "pszDesktopName",
        "description": "Specifies the name of the desktop to be created."
      },
      {
        "in_out": "_Out_",
        "type": "PWLX_DESKTOP",
        "name": "*ppDesktop",
        "description": "If the desktop is created, returns a pointer to a  WLX_DESKTOP structure for the new desktop. This pointer can be used in a call to  WlxSetReturnDesktop to make this the current desktop after a SAS event is processed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[The WlxDialogBox function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the WlxDialogBox function succeeds, the return value is the nResult parameter given in the call to the  EndDialog function used to terminate the dialog box. The following table lists some possible success return values.  If the function fails, the return value is \u00e2\u0080\u00931. ",
    "remarks": "GINA must use the Winlogon WlxDialogBox function, not the Windows DialogBox macro. WlxDialogBox duplicates the Windows DialogBox macro, and also allows Winlogon to terminate the dialog box. For more information, see  DialogBox. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxDialogBox",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hInst",
        "description": "Specifies an instance of the module whose executable file contains the dialog box template."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpszTemplate",
        "description": "Specifies the dialog box template. This parameter is either the address of a null-terminated character string that specifies the name of the dialog box template, or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use the  MAKEINTRESOURCE macro to create this value."
      },
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndOwner",
        "description": "Specifies the window that owns the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "DLGPROC",
        "name": "dlgprc",
        "description": "Points to the dialog box procedure. For more information about the dialog box procedure, see the  DialogProc callback function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[The WlxDialogBoxIndirect function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the WlxDialogBoxIndirect function succeeds, the return value is the nResult parameter given in the call to the  EndDialog function used to terminate the dialog box. The following table lists some possible success return values.  If the function fails, the return value is \u00e2\u0080\u00931. ",
    "remarks": "WlxDialogBoxIndirect duplicates the Windows DialogBoxIndirect macro, and also allows Winlogon to terminate the dialog box. For more information, see  DialogBoxIndirect. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxDialogBoxIndirect",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Winlogon handle provided to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hInst",
        "description": "Identifies the instance of the module that creates the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "LPCDLGTEMPLATE",
        "name": "hDialogTemplate",
        "description": "Specifies the address of a global memory object that contains a dialog box template used to create the dialog box. The template is in the form of a  DLGTEMPLATE structure followed by one or more  DLGITEMTEMPLATE structures. For a full description of these structures, see the Platform SDK."
      },
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndOwner",
        "description": "Identifies the window that owns the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "DLGPROC",
        "name": "dlgprc",
        "description": "Points to the dialog box procedure. For more information about the dialog box procedure, see  DialogProc."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "[The WlxDialogBoxIndirectParam function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the function succeeds, the function returns the nResult parameter given in the call to the  EndDialog function used to terminate the dialog box. The following table lists some possible success return values.  If the function fails, the return value is \u00e2\u0080\u00931. ",
    "remarks": "WlxDialogBoxIndirectParam duplicates the Windows DialogBoxIndirectParam function and also allows Winlogon to terminate the dialog box. For more information, see  DialogBoxIndirectParam. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxDialogBoxIndirectParam",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hInst",
        "description": "Specifies the instance of the module that creates the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "LPCDLGTEMPLATE",
        "name": "hDialogTemplate",
        "description": "Specifies the address of a global memory object that contains a dialog box template used to create the dialog box. The template is in the form of a  DLGTEMPLATE structure followed by one or more  DLGITEMTEMPLATE structures. For a full description of these structures, see the Platform SDK."
      },
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndOwner",
        "description": "Specifies the window that owns the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "DLGPROC",
        "name": "dlgprc",
        "description": "Points to the dialog box procedure. For more information about the dialog box procedure, see the description of the  DialogProc callback function in the Platform SDK."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "dwInitParam",
        "description": "Specifies the value used to initialize the dialog box control. This value is passed to the dialog box in the lParam parameter of the  WM_INITDIALOG message."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "[The WlxDialogBoxParam function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the WlxDialogBoxParam function succeeds, the return value is the value of the nResult parameter given in the call to the  EndDialog function used to terminate the dialog box. The following table lists some possible success return values.  If the function fails, the return value is \u00e2\u0080\u00931. ",
    "remarks": "WlxDialogBoxParam duplicates the Windows DialogBoxParam function, and also allows Winlogon to terminate the dialog box. For more information, see  DialogBoxParam. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxDialogBoxParam",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hInst",
        "description": "Specifies an instance of the module whose executable file contains the dialog box template."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpszTemplate",
        "description": "Specifies the dialog box template. This parameter is either the address of a null-terminated character string that specifies the name of the dialog box template, or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use the  MAKEINTRESOURCE macro to create this value."
      },
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndOwner",
        "description": "Specifies the window that owns the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "DLGPROC",
        "name": "dlgprc",
        "description": "Points to the dialog box procedure. For more information about the dialog box procedure, see  DialogProc."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "dwInitParam",
        "description": "Specifies the value to pass to the dialog box in the lParam parameter of the  WM_INITDIALOG message."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "[The WlxDisconnect function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxDisconnect function returns one of the following values.  ",
    "remarks": "To access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_3 structure, and set the Winlogon version to at least WLX_VERSION_1_3 in its  WlxNegotiate call. Other Winlogon support functions that may be called when Terminal Services is enabled are WlxWin31Migrate, WlxQueryClientCredentials, and WlxQueryInetConnectorCredentials. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxDisconnect",
    "is_callback": 0,
    "dll": "",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "[The WlxGetOption function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxGetOption function returns one of the following values.  ",
    "remarks": "In order to access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_3 structure and set the Winlogon version to at least WLX_VERSION_1_3 in its  WlxNegotiate call. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxGetOption",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Option",
        "description": "Specifies one of the following options:      WLX_OPTION_USE_CTRL_ALT_DEL WLX_OPTION_CONTEXT_POINTER WLX_OPTION_USE_SMART_CARD WLX_OPTION_SMART_CARD_PRESENT WLX_OPTION_SMART_CARD_INFO WLX_OPTION_DISPATCH_TABLE_SIZE"
      },
      {
        "in_out": "_Out_",
        "type": "ULONG_PTR",
        "name": "*Value",
        "description": "Returns the current value of the option."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxGetSourceDesktop function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxGetSourceDesktop function returns one of the following values.  ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxGetSourceDesktop",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_Out_",
        "type": "PWLX_DESKTOP",
        "name": "*ppDesktop",
        "description": "Receives a pointer to a  WLX_DESKTOP structure containing necessary information describing the desktop. This pointer can be freed with  LocalFree."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "[The WlxMessageBox function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "If the function fails, or if there is not enough memory to create the message box, the return value is zero. If the function succeeds, the return value is one of the following menu item values returned by the dialog box.  ",
    "remarks": "The WlxMessageBox function does not handle SAS events, and is not suitable for security dialog boxes. Use the  WlxDialogBox,  WlxDialogBoxIndirect, or  WlxDialogBoxIndirectParam function for security dialog boxes. WlxMessageBox duplicates the Windows  MessageBox function, with the exception that this function also allows Winlogon to time out the dialog box. For more information, see  MessageBox. ",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxMessageBox",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndOwner",
        "description": "Specifies the owner window of the message box to be created. If this parameter is NULL, the message box has no owner window."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpszText",
        "description": "Points to a null-terminated string that contains the message to be displayed."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpszTitle",
        "description": "Points to a null-terminated string used for the dialog box title. If this parameter is NULL, the default title Error is used."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuStyle",
        "description": "Specifies the content and behavior of the dialog box. This parameter can be a combination of the following values.  ValueMeaning  MB_ABORTRETRYIGNORE   The message box contains three command buttons: Abort, Retry, and Ignore.   MB_APPLMODAL   The user must respond to the message box before continuing to work in the window identified by the hWndOwner parameter. However, the user can move to windows of other applications to work.     Depending on the hierarchy of windows in the application, the user may be able to move to other windows within the application. All child windows of the parent of the message box are automatically disabled but pop-up windows are not. MB_APPLMODAL is the default value if neither MB_SYSTEMMODAL nor MB_TASKMODAL is specified.   MB_DEFAULT_DESKTOP_ONLY   The desktop currently receiving input must be a default desktop; otherwise, the function fails. A default desktop is one on which an application runs after the user has logged on.   MB_DEFBUTTON1   The first button is the default button. Note that the first button is always the default unless MB_DEFBUTTON2 or MB_DEFBUTTON3 is specified.   MB_DEFBUTTON2   The second button is a default button.   MB_DEFBUTTON3   The third button is a default button.   MB_DEFBUTTON4   The fourth button is a default button.   MB_ICONASTERISK   An icon that consists of a lowercase letter in a circle appears in the message box.   MB_ICONEXCLAMATION   An exclamation point icon appears in the message box.   MB_ICONHAND   A hand icon appears in the message box.   MB_ICONINFORMATION   An icon that consists of a lowercase letter in a circle appears in the message box.   MB_ICONQUESTION   A question mark icon appears in the message box.   MB_ICONSTOP   A stop sign icon appears in the message box.   MB_OK   The message box contains one command button: OK.   MB_OKCANCEL   The message box contains two command buttons: OK and Cancel.   MB_RETRYCANCEL   The message box contains two command buttons: Retry and Cancel.   MB_SERVICE_NOTIFICATION   The caller is a service notifying the user of an event. The function brings up a message box on the current active desktop, even if there is no user logged on to the computer.   MB_SETFOREGROUND   The message box becomes the foreground window. Internally, Windows calls the  SetForegroundWindow function for the message box.   MB_SYSTEMMODAL   All applications are suspended until the user responds to the message box. Unless the application specifies MB_ICONHAND, the message box does not become modal until after it is created. Consequently, the owner window and other windows continue to receive messages resulting from its activation. Use system-modal message boxes to notify the user of serious, potentially damaging errors that require immediate attention, for example, running out of memory.   MB_TASKMODAL   Same as MB_APPLMODAL except that all the top-level windows that belong to the current task are disabled if the hWndOwner parameter is NULL. Use this flag when the calling application or library does not have a window handle available, but still needs to prevent input to other windows in the current application without suspending other applications.   MB_YESNO   The message box contains two command buttons: Yes and No.   MB_YESNOCANCEL   The message box contains three command buttons: Yes, No, and Cancel."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxQueryClientCredentials function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxQueryClientCredentials function returns one of the following values.  ",
    "remarks": "The GINA DLL is responsible for calling  LocalFree to free the resources used by this structure when the structure is no longer needed. In order to access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_3 structure, and set the Winlogon version to at least WLX_VERSION_1_3 in its  WlxNegotiate call. If the Terminal Services client is using an Internet connector license, the GINA DLL must call  WlxQueryInetConnectorCredentials. Other Winlogon support functions that may be called when Terminal Services is enabled are WlxDisconnect, WlxQueryInetConnectorCredentials, and WlxWin31Migrate. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxQueryClientCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PWLX_CLIENT_CREDENTIALS_INFO_V1_0",
        "name": "pCred",
        "description": "Specifies a pointer to a  WLX_CLIENT_CREDENTIALS_INFO_V1_0 structure that contains the credentials of the client on return."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Called by GINA to read the credentials transferred from the Winlogon of the temporary session to the Winlogon of the destination session.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "Returns TRUE if credentials were transferred and FALSE if the transfer failed. ",
    "remarks": "In order to access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_4 structure. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "WlxQueryConsoleSwitchCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PWLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0",
        "name": "pCred",
        "description": "Pointer to a  WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 structure to be filled with credentials information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxQueryInetConnectorCredentials function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxQueryInetConnectorCredentials function returns one of the following values.  ",
    "remarks": "The GINA DLL is responsible for calling  LocalFree to free the resources used by this structure when the structure is no longer needed. In order to access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_3 structure, and set the Winlogon version to at least WLX_VERSION_1_3 in its  WlxNegotiate call. If Terminal Services is not using an Internet connector license, the GINA DLL must call  WlxQueryClientCredentials. Other Winlogon support functions that may be called when Terminal Services is enabled are WlxDisconnect, WlxQueryClientCredentials, WlxQueryTerminalServicesData and  WlxWin31Migrate. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxQueryInetConnectorCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PWLX_CLIENT_CREDENTIALS_INFO_V1_0",
        "name": "pCred",
        "description": "When the return value is TRUE, pCred specifies a pointer to a  WLX_CLIENT_CREDENTIALS_INFO_V1_0 structure that contains the credentials to use for auto logon."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The WlxQueryTerminalServicesData function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxQueryTerminalServicesData function returns zero if the user-configuration information was retrieved successfully. Otherwise, it returns an error code. ",
    "remarks": "WlxQueryTerminalServicesData should be called from within GINA's implementation of  WlxLoggedOutSAS after a user has been authenticated. In order to access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_3 structure, and set the Winlogon version to at least WLX_VERSION_1_3 in its  WlxNegotiate call. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "WlxQueryTerminalServicesData",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_Out_",
        "type": "PWLX_TERMINAL_SERVICES_DATA",
        "name": "pTSData",
        "description": "Points to a structure that will contain the user configuration information specific to Terminal Services."
      },
      {
        "in_out": "_In_",
        "type": "WCHAR",
        "name": "*UserName",
        "description": "Pointer to a null-terminated wide character string that specifies the name of the newly logged-on user."
      },
      {
        "in_out": "_In_",
        "type": "WCHAR",
        "name": "*Domain",
        "description": "Pointer to a null-terminated wide character string that specifies the newly logged-on user's domain."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxSasNotify function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function has no return values. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "WlxSasNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSasType",
        "description": "Specifies the type of SAS that occurred.     Values from zero to WLX_SAS_TYPE_MAX_MSFT_VALUE are reserved to define standard Microsoft SAS types. GINA developers can use values greater than WLX_SAS_TYPE_MAX_MSFT_VALUE to define additional SAS types. The following values are predefined. This value will be delivered to one of the GINA SAS service routines called by Winlogon (WlxLoggedOutSAS,  WlxLoggedOnSAS, or  WlxWkstaLockedSAS).  ValueMeaning  WLX_SAS_TYPE_CTRL_ALT_DEL   Indicates that the user has typed the CTRL+ALT+DEL SAS."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxSetContextPointer function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function has no return values. ",
    "remarks": "If the GINA must call  WlxSasNotify from the WlxInitialize function, it should first call WlxSetContextPointer to let Winlogon associate a context with the GINA. ",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "WlxSetContextPointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pWlxContext",
        "description": "Pointer to the new context that Winlogon will use in future calls to GINA."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The WlxSetOption function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxSetOption function returns one of the following values.  ",
    "remarks": "In order to access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_3 structure and set the Winlogon version to at least WLX_VERSION_1_3 in its  WlxNegotiate call. Use  WlxGetOption to retrieve the current value of an option. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxSetOption",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Option",
        "description": "Specifies one of the following options:      WLX_OPTION_USE_CTRL_ALT_DEL WLX_OPTION_CONTEXT_POINTER WLX_OPTION_USE_SMART_CARD"
      },
      {
        "in_out": "_In_",
        "type": "ULONG_PTR",
        "name": "Value",
        "description": "Specifies a new value for the option."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG_PTR",
        "name": "*OldValue",
        "description": "On return, pointer to the old value the option was set to."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxSetReturnDesktop function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxSetReturnDesktop function returns one of the following values.  ",
    "remarks": "WlxSetReturnDesktop can be called only within  WlxLoggedOnSAS or  WlxWkstaLockedSAS routines. Attempts to call this function at other times will fail. If a handle to the desktop is provided, Winlogon will duplicate the handle. If no handle is provided, Winlogon will attempt to open the desktop named in the pDesktop parameter. If the provided desktop is not valid or is the Winlogon or screen saver desktop, the call will fail. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxSetReturnDesktop",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "PWLX_DESKTOP",
        "name": "pDesktop",
        "description": "Pointer to desktop information about the alternate desktop. This desktop is created by calling the  WlxCreateUserDesktop function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[The WlxSetTimeout function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxSetTimeout function returns one of the following values.  ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxSetTimeout",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Timeout",
        "description": "Requested time-out, in seconds."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxSwitchDesktopToUser function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxSwitchDesktopToUser function returns zero if the function call succeeds. Otherwise, it returns an error code. ",
    "remarks": "",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxSwitchDesktopToUser",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxSwitchDesktopToWinlogon function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxSwitchDesktopToWinlogon function returns zero if the function call succeeds. Otherwise, it returns an error code. ",
    "remarks": "",
    "return_type": "int",
    "category": "Authentication",
    "name": "WlxSwitchDesktopToWinlogon",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specifies the Winlogon handle passed to GINA in the  WlxInitialize call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Called by GINA to tell Winlogon to use the standard CTRL+ALT+DEL key combination as a secure attention sequence (SAS).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function does not return a value. ",
    "remarks": "If GINA uses this function, it is not required to use the  WlxSasNotify function. However, if GINA is monitoring for other SASs in addition to CTRL+ALT+DEL, it must use WlxSasNotify to deliver the additional SAS event notifications. ",
    "return_type": "void",
    "category": "Authentication",
    "name": "WlxUseCtrlAltDel",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "[in] Winlogon handle provided to GINA in the WlxInitialize call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[The WlxWin31Migrate function is no longer available for use as of Windows Server 2008 and Windows Vista.]",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "This function has no return values. ",
    "remarks": "GINA needs to call this function before starting the shell, so that the migration and setup will be complete before the shell starts, but after it has processed any logon scripts. In order to use this function, the GINA DLL must specify the  WLX_DISPATCH_VERSION_1_3 structure in its call to  WlxInitialize, and set the Winlogon version to at least WLX_VERSION_1_3 in its  WlxNegotiate call. Other Winlogon support functions that may be called when Terminal Services is enabled are WlxDisconnect, WlxQueryClientCredentials, and WlxQueryInetConnectorCredentials. ",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "WlxWin31Migrate",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hWlx",
        "description": "Specify the handle received in the call to  WlxInitialize."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Returns information about which services are supported on the network.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "The NPGetCaps function returns either a constant or a bitmask, depending on the value of the nIndex parameter. A few of the nIndex values cause a constant to be returned. But in most cases, the nIndex parameter specifies which set of services to query, and the returned value is a bitmask that indicates which services in this set are supported. In these cases, a zero return value indicates that none of the services in the set are supported. The following list shows the values that nIndex may contain, each followed by a description of what is returned for that value. ",
    "remarks": "When a start time is returned by NPGetCaps, the MPR uses this value to determine when to try to start all network providers again. MPR uses the longest start time returned by the providers it called. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetCaps",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nIndex",
        "description": "Specifies the type of information to return. The following values are defined.                       ValueMeaning  WNNC_ADMIN   A bitmask that indicates which administrative functions the network provider supports.   WNNC_CONNECTION   A bitmask that indicates which connection functions the network provider supports.   WNNC_DIALOG   A bitmask that indicates which provider-specific dialog box functions the network provider supports.   WNNC_ENUMERATION   A bitmask that indicates which enumeration functions the network provider supports.   WNNC_NET_TYPE   Network type and provider version.   WNNC_SPEC_VERSION   WNet API version supported by the provider.   WNNC_START   The state of the network provider.   WNNC_USER   A bitmask that indicates which user functions the network provider supports."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The NPAddConnection function connects a local device to a network resource.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise, it should return an error code, which can be one of the following.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPAddConnection",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "Pointer to a  NETRESOURCE structure which specifies the network resource to connect to. The following fields must be set in the NETRESOURCE structure you pass in. The NPAddConnection function ignores the other fields.  ValueMeaning  lpRemoteName   Specifies the network resource to connect to.   lpLocalName   Specifies the name of a local device to be redirected, such as \"F:\" or \"LPT1\". This name is treated as case insensitive and may be an empty string or NULL pointer. If the string is empty or NULL, the function connects to the network resource without making a redirection.   dwType   Specifies the type of resource to connect to. This can be RESOURCETYPE_DISK, RESOURCETYPE _PRINT, or RESOURCETYPE_ANY. The value RESOURCETYPE _ANY is used if the caller does not care or does not know."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpPassword",
        "description": "Pointer to the password to be used in making the connection, normally the password associated with lpUserName. The NULL value may be passed in to cause the function to use the default password. An empty string may be used to indicate no password. When you have finished using the password, clear it from memory by calling the SecureZeroMemory function. For more information about protecting the password, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpUserName",
        "description": "Pointer to the user name used to make the connection. If NULL, the default user name (that of the currently logged-on user) is applied. This is used when the user wants to connect to a resource but has a different assigned user name or account for that resource. For example, if you were logged using the user name \"MyAccount\" and wanted to connect to a network resource that was available only to a second account, where the user name was \"MyOtherAccount\", you could specify \"MyOtherAccount\" in lpUserName in order to connect to the resource. You would also specify the password of this second account in lpPassword."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The NPAddConnection3 function connects a local device to a network resource. It performs the same operation as  NPAddConnection but in addition lets you specify a handle to the window that should own any resulting dialog boxes and specify how the connection should be established.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it will return WN_SUCCESS. Otherwise, it will return an error code. This may include one of the following.  ",
    "remarks": "If a provider displays a password dialog box because the specified credentials are insufficient and the CONNECT_INTERACTIVE flag is set, then the provider may not return an access-denied error code (one of ERROR_LOGON_FAILURE, WN_BAD_PASSWORD, WN_ACCESS_DENIED). The suggested behavior is for the provider to continue asking the user for valid credentials until the user either supplies them or presses a \"cancel\" button. If NPAddConnection3 is called to make the connection requested during the  WNetConnectionDialog or  WNetConnectionDialog1 function and an access-denied code is returned, the  WNetConnectionDialog or  WNetConnectionDialog1 function will, itself, display a password dialog box. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPAddConnection3",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndOwner",
        "description": "A handle to a window that should own any messages or dialog boxes. This handle is valid only if CONNECT_INTERACTIVE is set in dwFlags, and the handle should only be used to produce dialog boxes needed for authentication."
      },
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "Pointer to a  NETRESOURCE structure that specifies the network resource to connect to. The following fields must be set when making a connection. The others are ignored.  ValueMeaning  lpRemoteName   Specifies the network resource to connect to.   lpLocalName   Specifies the name of a local device to be redirected, such as \"F:\" or \"LPT1\". This name is treated as case insensitive and may be the empty string or NULL pointer. If the string is empty or NULL, the function connects to the network resource without making a redirection.   dwType   Specifies the type of resource to connect to. This can be RESOURCETYPE_DISK, RESOURCETYPE_PRINT, or RESOURCETYPE_ANY. The value RESOURCETYPE_ANY is used if the caller does not care or does not know."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpPassword",
        "description": "Pointer to the password to be used in making the connection, normally the password associated with lpUserName. The NULL value may be passed in to cause the function to use the default password. An empty string may be used to indicate no password. When you have finished using the password, clear it from memory by calling the SecureZeroMemory function. For more information about protecting the password, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpUserName",
        "description": "Pointer to the user name used to make the connection. If NULL, the default user name (that of the currently logged-on user) is applied. This is used when the user wants to connect to a resource but has a different assigned user name or account for that resource."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Any combination of the following values. The provider should ignore any other bits of dwFlags that may be set.  ValueMeaning  CONNECT_TEMPORARY   The connection is being established for browsing purposes and will probably be released quickly.   CONNECT_INTERACTIVE   The connection may have interaction with the user for authentication purposes.   CONNECT_PROMPT   Do not use any defaults for user names or passwords without offering the user a chance to supply an alternative. This flag is only valid if CONNECT_INTERACTIVE is also set.   CONNECT_DEFERRED   Do not perform any remote network operations to make the network connection; instead, restore the connection in a \"disconnected state.\" Attempt the actual connection only when some process attempts to use the connection. If this bit is set, the caller must supply lpLocalName.     This feature is used to speed the restoring of network connections at logon. A provider that supports it should return the WNNC_CON_DEFERRED bit in NPGetCaps."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The NPCancelConnection function disconnects a network connection. The changes you make to the connection are remembered if the connection is to a device. If, however, the connection is to a remote network resource, changes are not remembered.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it will return WN_SUCCESS. Otherwise, it will return an error. This can be one of the following.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPCancelConnection",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpName",
        "description": "Pointer to the name of either the redirected local device or the remote network resource to disconnect from."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fForce",
        "description": "Indicates whether the disconnect should continue in the event of open files or jobs on the connection. If FALSE is specified, the call will fail if there are open files or jobs."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The NPCloseEnum function closes an enumeration.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it will return WN_SUCCESS. Otherwise, it will return an error code, which can be one of the following:  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPCloseEnum",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hEnum",
        "description": "Handle obtained from an  NPOpenEnum call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The NPDeviceMode function specifies the parent window of a device. This window owns any dialog boxes that originate from the device.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it will return WN_SUCCESS. Otherwise, it will return a Windows error code. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPDeviceMode",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hParent",
        "description": "A handle to the window that owns dialog boxes originating from this device."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Notifies the network provider of certain directory operations. The NPDirectoryNotify function is used by File Manager. This function can be used to perform special operations on certain directories.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "This function should return WN_SUCCESS if it is successful. This indicates to the caller that it should continue and perform the operation. Otherwise, it should return the appropriate code, which may include:  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPDirectoryNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwnd",
        "description": "A handle to a window that should own any messages or dialog boxes in the event the network provider needs to interact with the user."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpDir",
        "description": "Pointer to the fully qualified name of the directory."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOper",
        "description": "Indicates the operation about to be performed. This can be one of the following values.       ValueMeaning  WNDN_MKDIR   File Manager is about to create a directory with the given name.   WNDN_RMDIR   File Manager is about to remove the directory.   WNDN_MVDIR   File Manager is about to rename the directory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Performs an enumeration based on a handle returned by  NPOpenEnum.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. The caller may continue to call NPEnumResource to continue the enumeration. Otherwise, it should return one of the following error codes.  ",
    "remarks": "When this function is called, the provider should fill the buffer with the requested number of entries (or the maximum that can fit). The returned  NETRESOURCE structures should be located contiguously at the head of the buffer, like an array of such structures. The pointers in these structures must point to locations within the buffer. Therefore, data referenced by these pointers should be located at the end of the buffer, after the array of structures. It is the provider's responsibility to package this information correctly. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPEnumResource",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hEnum",
        "description": "Handle obtained from an  NPOpenEnum call."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpcCount",
        "description": "Pointer to the number of entries requested. It may be 0xFFFFFFFF to request as many entries as possible. If the call succeeds, this location will receive the number of entries actually read."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to the buffer to receive the enumeration result, which is returned as an array of  NETRESOURCE entries. The buffer is valid until the next call using hEnum."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpBufferSize",
        "description": "Pointer to the size, in bytes, of the buffer passed to the function call on entry. If the buffer is too small for even one entry, this should contain, on exit, the number of bytes needed to read one entry. This value is  set only if the return code is WN_MORE_DATA."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Opens an enumeration of network resources or existing connections. The NPOpenEnum function must be called to obtain a valid handle for an enumeration.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise, it should return an error code which may include one of the following.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPOpenEnum",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwScope",
        "description": "Determines the scope of the enumeration. This can be one of the following.      \t\t\t\t\t  ValueMeaning  RESOURCE_CONNECTED   All currently connected resources.   RESOURCE_GLOBALNET   All resources on the network.   RESOURCE_CONTEXT   The resources associated with the user's current and default network context (used for a \"Network Neighborhood\" view). The interpretation of this is left to the provider."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "Specifies the type of resources of interest. This is a bitmask, which may be any combination of the following flags.       ValueMeaning  RESOURCETYPE_DISK   All disk resources.   RESOURCETYPE_PRINT   All print resources.   RESOURCEUSAGE_ATTACHED   Specifies that the function should fail if the caller is not authenticated (even if the network permits enumeration without authentication).     If dwType is 0, or is just RESOURCEUSAGE_ATTACHED, all types of resources are returned. If a provider does not have the capability to distinguish between print and disk resources at the same level, it may return all resources."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwUsage",
        "description": "Specifies the usage of resources of interested. This is a bitmask, which may be any combination of the following flags.       ValueMeaning  RESOURCEUSAGE_CONNECTABLE   All connectable resources   RESOURCEUSAGE_CONTAINER   All container resources     The bitmask may be zero to match all of the flags. This parameter may be ignored if dwScope is not set to RESOURCE_GLOBALNET."
      },
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "Pointer to the container to perform the enumeration. The  NETRESOURCE could have been obtained through a previous NPEnumResource call, or constructed by the caller, or it can be NULL. If it is NULL or if the lpRemoteName field of the NETRESOURCE is NULL, the provider should enumerate the top level of its network. Note that this means a provider cannot use an lpRemoteName of NULL to represent any network resource. A caller would normally start off by calling NPOpenEnum with this parameter set to NULL and then use the returned results for further enumeration. If the calling program knows exactly the provider and remote path to enumerate from, it may build its own NETRESOURCE structure to pass in, filling in the lpProvider and lpRemoteName fields. Note that if dwScope is RESOURCE_CONNECTED or RESOURCE_CONTEXT, this parameter will be NULL."
      },
      {
        "in_out": "_Out_",
        "type": "LPHANDLE",
        "name": "lphEnum",
        "description": "Pointer to a handle that can be used by the NPEnumResource function. When you have finished using the handle, release the handle by calling the NPCloseEnum function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Formats a network name in a provider-specific format for display in a control.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. If the function fails, it should return the following value. All other errors will be ignored, and the unformatted network name will be used.  ",
    "remarks": "This function allows network vendors to trim or modify network names before they are presented to the user. For example, in the common Open dialog box, the Drives combo box presents all connected resources and their associated network name. Before each item is displayed, NPFormatNetworkName is called, and the network provider has the option of editing the name so it will fit in the combo box. More important, the network provider can edit the name to present the most significant portion of the network name to the user. Note that NPFormatNetworkName is not routed to each network provider like most of the other network provider functions are. Each network vendor need worry only about formatting their own network name. They can assume that only names produced by their network provider driver will be passed to NPFormatNetworkName. The WNFMT_ flags are typically passed at various places in the user interface as described in the following table. No assumptions should be made about what flags are passed where; this table is provided solely to help each network vendor  decide the best method for modifying their network name.  ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPFormatNetworkName",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpRemoteName",
        "description": "Pointer to the network name to format."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpFormattedName",
        "description": "Pointer to a string that receives the formatted name."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpnLength",
        "description": "Pointer to DWORD that specifies the size, in characters, of the lpFormattedName buffer. If the return value of this function is WN_MORE_DATA, lpnLength contains the required buffer size, in characters."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Bitfield that indicates the type of format being requested. This parameter can be one of the following values.      \t\t\t\t\t\t  \t\t\t\t\t\t \t\t\t\t\t   ValueMeaning  WNFMT_MULTILINE   The provider should place  backslash n (\\n)  where line breaks should appear in the name. The full name should be expressed.   WNFMT_ABBREVIATED   The provider should shorten the network name so that the information most useful for the user will fit in the available space.      In addition, the following flag, which acts as a modifier to the preceding flags, can be included by using a bitwise-OR operation.  ValueMeaning  WNFMT_INENUM   The network name is presented in the context of an enumeration where the name of the \"container\" appears immediately before the network name in the enumeration. This allows network providers to remove redundant information from the formatted name, providing a less cluttered display for the user."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAveCharPerLine",
        "description": "Specifies the average number of characters that will fit on a single line where the network name is being presented. Specifically, this value is defined as the width of the control divided by the tmAveCharWidth field of the  TEXTMETRIC structure from the font used for display in the control."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves information about a connection.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise, it should return an error code, which can be one of the following:  ",
    "remarks": "The NPGetConnection function can return information only about a network connection that is currently connected. To retrieve information about a network connection that is currently disconnected, use  NPGetConnection3. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetConnection",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpLocalName",
        "description": "Pointer to the name of the local device the caller is interested in. The network provider can assume this name is syntactically valid."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpRemoteName",
        "description": "Pointer to a buffer that will receive the remote name used to make the connection. This buffer is allocated by the caller."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpBufferSize",
        "description": "Pointer to the size, in characters, of the lpRemoteName buffer. If the call fails because the buffer is not big enough, lpBufferSize is set to the required buffer size."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves information about a network connection, even if it is currently disconnected.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. If the function fails, it should return one of the following values.  ",
    "remarks": "A network connection can exist in three states: connected, disconnected, and unavailable. The NPGetConnection3 function cannot retrieve information about network connections that are currently unavailable. It can, however, retrieve information about network connections that are currently disconnected because Windows stores the connection information. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetConnection3",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpLocalName",
        "description": "Pointer to the name of the local device the caller is interested in. The provider can assume that this is syntactically valid."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLevel",
        "description": "Value that specifies whether the network connection is currently connected or disconnected.  ValueMeaning  WNGETCON_CONNECTED   The network connection is connected.   WNGETCON_DISCONNECTED   The network connection is disconnected."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Void pointer that receives a buffer that contains the requested information."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpBufferSize",
        "description": "Pointer to the size, in characters, of the lpBuffer buffer. If the call fails because the buffer is not big enough, lpBufferSize is set to the required buffer size."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Returns information about the expected performance of a connection used to access a network resource. The request can only be for a network resource that is currently connected.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise, it should return an error code, which can be one of the following.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetConnectionPerformance",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpRemoteName",
        "description": "Pointer to the local name or remote name for a connected resource."
      },
      {
        "in_out": "_Out_",
        "type": "LPNETCONNECTINFOSTRUCT",
        "name": "lpNetConnectInfo",
        "description": "Pointer to a  NETCONNECTINFOSTRUCT structure, which is filled in by the network provider if the provider has a connection to the network resource. All other fields of this structure, except the cbStructure field, are filled with zeros before the MPR passes the request on to the network providers. As a result, the provider has to write only to fields for which it has information available. Also, for rate values, a value of 1 means that the performance is better than can be represented in the unit. The information returned may be an estimate. If the network cannot obtain information about the resource on the network, it can return information about the network adapter and its associated performance and then set the dwFlags field accordingly."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Determines the type of a network directory. The NPGetDirectoryType function is used by File Manager.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "This function should return WN_SUCCESS if it is successful. Otherwise, it should return an error code, which may include the following.  ",
    "remarks": "File Manager will supply its own icon for all special network directories; that is, when lpType is set to a nonzero value, File Manager will display a special folder icon. The implementation of this function should be high-performance, or fast, since the call occurs while File Manager is painting the directory tree. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetDirectoryType",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpName",
        "description": "Pointer to the fully qualified name of the directory. The network provider returns the type to the address pointed to by lpType. If the value returned in lpType is zero or if the network provider returns an error, File Manager displays the directory as a \"normal\" directory."
      },
      {
        "in_out": "_In_",
        "type": "LPINT",
        "name": "lpType",
        "description": "Pointer to a value defined by the network provider. This value is used to modify the display of the drive tree in File Manager. In this way, the network provider can show special directories to the user."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bFlushCache",
        "description": "Set to TRUE when File Manager calls MPR to get the directory type for the first time while repainting a window on Refresh. Subsequently, it will be FALSE. This gives a provider the opportunity to optimize performance if it wants to just read the data for a drive once and then cache it until the next Refresh."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves the names of buttons to add to a property dialog box for a network resource.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS and lpButtonName can be used. If it points to the empty string, no button corresponds to an index as high as iButton. If the return value is other than WN_SUCCESS, the provider should also call SetLastError to set extended error information. Extended error codes include the following.  ",
    "remarks": "File Manager calls this function each time the property dialog box is brought up, and it does this before displaying the dialog box. If the user clicks a button added through this function by the network provider,  the NPPropertyDialog function is called with the appropriate parameters. Only File Manager calls NPGetPropertyText, and it uses this function for files and directories. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetPropertyText",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "iButton",
        "description": "Indicates the index of the button. File Manager supports a maximum of six buttons. This parameter is numbered 1-6 for each of the possible buttons if only one file is selected, or 11-16 if multiple files are selected."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nPropSel",
        "description": "Specifies what items the property dialog box focuses on. This can be one of the following values.      \t\t\t\t\t  ValueMeaning  WNPS_FILE   A single file.   WNPS_DIR   A single directory.   WNPS_MULT   A selection of multiple files, directories, or both."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpName",
        "description": "Pointer to a null-terminated string that contains the names of the item or items to be viewed or edited by means of the dialog box. The only supported items are files and directories, so the item names are file names. These should be unambiguous, contain no wildcard characters, and be fully qualified (for example, C:\\LOCAL\\EXAMPLE.DOC). Multiple file names should be separated with spaces. A file name that contains spaces may be surrounded by quotes (for example, \"C:\\My File\"). In this case. it is treated as a single name. The caret character '^' may also be used as the quotation mechanism for single characters (for example, C:\\My^\"File, \"C:\\My^\"File\" both refer to the file C:\\My\"File)."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpButtonName",
        "description": "Pointer to a buffer where the network provider should copy the name of the property button. On success, the buffer pointed to by lpButtonName contains the name of the property button. If this buffer, on exit, contains the empty string, then the button corresponding to that name and all succeeding buttons will be removed from the dialog box. The network provider cannot \"skip\" a button."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "nButtonNameLen",
        "description": "Specifies the size of the lpButtonName buffer in characters, including the terminating null character."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nType",
        "description": "Specifies the item type, which must be WNTYPE_FILE."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Separates the part of a network resource accessed through the WNet API from the part accessed through APIs specific to the resource type.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise, it should return an error code, which may be one of the following.  ",
    "remarks": "The enumeration tree can be navigated down from a named network resource by using  NPOpenEnum and its related functions. To navigate up from a named resource, the NPGetResourceInformation function can be called to obtain information about the resource, followed by the  NPGetResourceParent function to obtain the name and type of the parent resource. NPGetResourceInformation determines whether the specified provider is the right provider to respond to a request for a specified network resource. It then returns information about the resource's type. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetResourceInformation",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "Specifies the network resource for which information is required. The lpRemoteName field specifies the remote name of the resource. The calling program should fill in the values for the lpProvider and dwType fields if it knows these values; otherwise, it should set these fields to NULL. All other fields in the NETRESOURCE are ignored and are not initialized.     If the lpRemoteName string contains a portion that is accessed through WNet APIs and a portion that is accessed through other system APIs specific to the resource type, the function should return information only about the network portion of the resource (except for lplpSystem, as described later in this topic). For example, if the resource is \"\\\\server\\share\\dir1\\dir2\", where \"\\\\server\\share\" is accessed through WNet APIs and \"\\dir1\\dir2\" is accessed through file system APIs, the provider should verify that it is the right provider for \"\\\\server\\share\", but need not check whether \"\\dir1\\dir2\" actually exists."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to the buffer to receive the result. The first field in the result is a single  NETRESOURCE structure, and associated strings, representing that portion of the input resource that is accessed through the WNet API, rather than system APIs specific to the resource type. For example, if the input remote resource name was \"\\\\server\\share\\dir1\\dir2\", then the output NETRESOURCE contains information about the resource \"\\\\server\\share\". The lpRemoteName, lpProvider, dwType, dwDisplayType, and dwUsage fields are returned containing values, all other fields being set to NULL.     The lpRemoteName field should be returned in the same format as that returned from an enumeration by the  NPEnumResource function, so that the caller can perform a case-sensitive string comparison. This is necessary to determine whether the output network resource is the same as one returned by NPEnumResource. The provider should not do purely syntactic checking to determine whether it owns the resource. This could produce incorrect results when two networks are running on the client and the provider doing syntactic checking is called first."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpcbBuffer",
        "description": "Pointer to a location that specifies the size, in bytes, of the buffer pointed to by lpBuffer. If the buffer is too small for the result, the function places the required buffer size at this location and returns the error WN_MORE_DATA."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "*lplpSystem",
        "description": "On a successful return, a pointer to a null-terminated string in the output buffer specifying that part of the resource that is accessed through system APIs specific to the resource type, rather than through the WNet API. If there is no such part, lplpSystem is set to NULL. For example, if the input remote resource name was \"\\\\server\\share\\dir\", lpRemoteName is returned pointing to \"\\\\server\\share\" and lplpSystem points to \"\\dir\", both strings being stored in the buffer pointed to by lpBuffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the parent of a specified network resource in the browse hierarchy. This function is typically called for resources that were returned by the same provider from prior calls to  NPEnumResource or  NPGetResourceInformation.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise, it should return an error code, which may be one of the following.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetResourceParent",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "Pointer to the network resource whose parent name is required. The  NETRESOURCE could have been obtained from a previous call to  NPEnumResource or  NPGetResourceInformation, or constructed by the caller.     The lpRemoteName field specifies the remote name of the network resource whose parent is required. The lpProvider field specifies the provider to call. This must be supplied. The dwType field is filled in if the calling program knows its value. Otherwise, it is set to NULL. All other fields in the NETRESOURCE are ignored and are not initialized."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to a buffer to receive the result, which is a single NETRESOURCE structure representing the parent resource. The lpRemoteName, lpProvider, dwType, dwDisplayType, and dwUsage fields are returned; all other fields are set to NULL.     The output lpRemoteName should be in the same format as that returned from an enumeration by  NPEnumResource, so that the caller can perform a case-sensitive string comparison to determine whether the parent resource is the same as one returned by NPEnumResource. If the input resource syntactically has a parent, the provider can return it, without determining whether the input resource or its parent actually exist. If a resource has no browse parent on the network, then lpRemoteName is returned as NULL. The RESOURCEUSAGE_CONNECTABLE bit in the returned dwUsage field does not necessarily indicate that the resource can currently be connected to, only that the resource is connectable when it is available on the network."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpcbBuffer",
        "description": "Pointer to a location that specifies the size, in bytes, of the buffer pointed to by the lpBuffer parameter. If the buffer is too small for the result, the function places the required buffer size at this location and returns the error WN_MORE_DATA."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the universal name of a network resource. The NPGetUniversalName function can retrieve this universal name in UNC format or in the older, remote-name format.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise, it should return an error code, which may be one of the following.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetUniversalName",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpLocalPath",
        "description": "Pointer to the local path of an object on a network resource. This is a drive-based path."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInfoLevel",
        "description": "The level of detail of information the caller is interested in. This can be one of the following values.       ValueMeaning  UNIVERSAL_NAME_INFO_LEVEL   Retrieves the UNC form of the name, for example: \"file:\\\\server\\share\"     If this value is set, the data returned in lpBuffer is stored as a  UNIVERSAL_NAME_INFO structure.   REMOTE_NAME_INFO_LEVEL   Retrieves the remote form of the name, for example: \"\\\\server\\share\"     If this value is set, the data returned in lpBuffer is stored as a  REMOTE_NAME_INFO structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to a buffer to receive the information the user has requested. The specific structure returned depends on the information level specified in dwInfoLevel."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpBufferSize",
        "description": "Pointer to the size, in bytes, of the lpBuffer buffer. If the call fails because the buffer is not big enough, this location will be used to return the required buffer size."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the value of the current default user name or the user name used to establish a network connection.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it should return WN_SUCCESS. Otherwise it should return an error code, which can be one of the following.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPGetUser",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpName",
        "description": "Pointer to the name of the local device the caller is interested in, or a remote name for a resource that the user has made a connection to. This parameter may be NULL or the empty string if the caller is interested in the name of the user currently logged on to the system. If a remote name for a resource is passed in, and the user is connected to that resource using different names, it is possible that a provider cannot resolve which user name to return. In this case the provider may make an arbitrary choice amongst the possible user names."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpUserName",
        "description": "Pointer to a buffer to receive the user name. This should be a name that can be passed into the  NPAddConnection or  NPAddConnection3 function to re-establish the connection with the same user name."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpBufferSize",
        "description": "Pointer to the size, in characters, of the lpUserName buffer. If the call fails because the buffer is not big enough, this location will be used to return the required buffer size."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Called when the user clicks a button added by using the NPPropertyDialog function. The NPPropertyDialog function is called only for file and directory network properties.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, it returns WN_SUCCESS. If the function fails, it returns an error code. Call  SetLastError to set this extended error code, which may include the following return codes.  ",
    "remarks": "This function is  called only on sets of properties for which  NPGetPropertyText has assigned a button name. This function is used in File Manager to view and modify the network properties (for example, permissions) for files on a network device. If this function is not supported, File Manager does not provide any default behavior. In this version of the Network Provider interface, lpFileName can point to only file names. The network provider should return WN_BAD_VALUE if it sees an inappropriate device. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPPropertyDialog",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndParent",
        "description": "A handle to the parent window that should own the file property dialog box."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "iButtonDlg",
        "description": "The index of the button that was pressed.     This index specifies which property dialog box was requested, starting with one for the first button returned from  the NPGetPropertyText function. If there are multiple file names selected, 10 is added to this number. In other words, if there is more than one file selected and the user presses the first provider-defined property button, iButtonDlg will be 11. If there is only one file selected and the user presses the second network property button, iButtonDlg will be two."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nPropSel",
        "description": "Specifies what items the property dialog box should act on. This parameter can be one of the following values.      \t\t\t\t\t  ValueMeaning  WNPS_FILE   A single file.   WNPS_DIR   A single directory.   WNPS_MULT   A selection of multiple files, directories, or both."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpFileName",
        "description": "A pointer to the names of the items that the property dialog box should act on. The only supported items are files and directories, so the item names are file names. These should be unambiguous, contain no wildcard characters, and  be fully qualified, for example, C:\\Local\\Example.doc. Multiple file names should be separated with spaces. A file name that contains spaces can be enclosed in quotation marks, for example, \"C:\\My File\". In this case, it is treated as a single name. A caret  (^) can also be used as the quotation mechanism for single characters, for example, C:\\My^\"File and  \"C:\\My^\"File\" both refer to the file C:\\My\"File."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nType",
        "description": "Specifies the item type, which must be WNTYPE_FILE."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Enables network vendors to supply their own form of browsing and search, beyond the hierarchical view presented in the Connection dialog box. If a network provider supports this function, the Connection dialog box will enable the Search button when the selected item belongs to that provider. If the user hits the Search button, the Connection dialog box calls NPSearchDialog to handle the user request.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds and the user has clicked OK, NPSearchDialog should return WN_SUCCESS. Otherwise, it should return an error value, which can be one of the following. All other errors should be handled or reported directly by the provider's dialog box.  ",
    "remarks": "If the provider does not support enumeration, then the action associated with double-clicking the provider's entry will be to invoke its Search dialog box. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPSearchDialog",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hParent",
        "description": "Handle of the window to be used as the parent window of the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "Pointer to the currently selected item in the Network Connections dialog box. A provider may choose to ignore this field."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to a buffer that will receive the result of the search."
      },
      {
        "in_out": "_Out_",
        "type": "DWORD",
        "name": "cbBuffer",
        "description": "DWORD that will specify the size of the buffer passed in."
      },
      {
        "in_out": "_In_",
        "type": "LPDWORD",
        "name": "lpnFlags",
        "description": "Pointer to a DWORD of flags that the provider can set to force certain actions after the dialog box is dismissed. The only flag supported is WNSRCH_REFRESH_FIRST_LEVEL, which forces MPR to collapse then expand and refresh the first level below this provider after the dialog box is dismissed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Sets extended error information. Network providers should call this function instead of  SetLastError.",
    "library": "Mpr.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "This function does not return a value. ",
    "remarks": "This function is implemented by the Windows operating system and can be called by network providers. A provider should use this function to report errors that contain provider-specific information. The error information is saved until it is overwritten by another call to WNetSetLastError in the same thread. The recommended way for a provider function to handle general errors is to use the following statement. In this statement, providerError is a Windows error code, such as one of the return codes listed for the provider API in this document. For provider-specific errors, a provider should do the following. In this case, providerError is the provider-specific error code. Providers do not need to call SetLastError before returning from a provider function. The MPR calls SetLastError to set the Windows error returned from a provider when necessary to satisfy applications. ",
    "return_type": "void",
    "category": "Authentication",
    "name": "WNetSetLastError",
    "is_callback": 0,
    "dll": "Mpr.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "err",
        "description": "The error that occurred. This is a network-specific error code."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpError",
        "description": "String that describes the network-specific error."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpProvider",
        "description": "String that names the network provider that raised the error."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The AddConnectNotify function is called before and after each add connection operation (WNetAddConnection,  WNetAddConnection2, and  WNetAddConnection3) is attempted by the Multiple Provider Router (MPR).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, the function should return WN_SUCCESS. If the function fails, it should return an error code. This can be any of the error codes specified in  Network Security Return Values. ",
    "remarks": "The AddConnectNotify function is implemented by applications that need to receive notification from the MPR when a network resource is connected or disconnected. For more information about how to write an application that receives such notifications, see  Receiving Connection Notifications. ",
    "return_type": "DWORD APIENTRY",
    "category": "Authentication",
    "name": "AddConnectNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPNOTIFYINFO",
        "name": "lpNotifyInfo",
        "description": "A pointer to a  NOTIFYINFO structure that contains information about the notification."
      },
      {
        "in_out": "_In_",
        "type": "LPNOTIFYADD",
        "name": "lpAddInfo",
        "description": "A pointer to a  NOTIFYADD structure that contains information about the connection being added."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The \t\t\t\tWNetAddConnection function enables the calling application to connect a local device to a network resource. A successful connection is persistent, meaning that the system automatically restores the connection during subsequent logon operations.",
    "library": "Mpr.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnetwk.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is a  system error code, such as one of the following values.  ",
    "remarks": "On Windows Server 2003 and Windows XP, the WNet functions create and delete network drive letters in the MS-DOS device namespace associated with a logon session because MS-DOS devices are identified by AuthenticationID (a   locally unique identifier, or LUID, associated with a logon session.) This can affect applications that call one of the WNet functions to create a network drive letter under one user logon, but query for existing network drive letters under a different user logon. An example of this situation could be when a user's second logon is created within a logon session, for example, by calling the  CreateProcessAsUser function, and the second logon runs an application that calls the  GetLogicalDrives function. The call to the GetLogicalDrives function does not return network drive letters created by WNet function calls under the first logon. Note that in the preceding example the first logon session still exists, and the example could apply to any logon session, including a Terminal Services session. For more information, see  Defining an MS-DOS Device Name. On Windows Server 2003 and Windows XP, if a service that runs as LocalSystem calls the WNetAddConnection function, then the mapped drive is visible to all user logon sessions. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "WNetAddConnection",
    "is_callback": 0,
    "dll": "Mpr.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpRemoteName",
        "description": "A pointer to a constant null-terminated string that specifies the network resource to connect to."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpPassword",
        "description": "A pointer to a constant null-terminated string that specifies the password to be used to make a connection. This parameter is usually the password associated with the current user. If this parameter is NULL, the default password is used. If the string is empty, no password is used. Windows Me/98/95:  This parameter must be NULL or an empty string."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpLocalName",
        "description": "A pointer to a constant null-terminated string that specifies the name of a local device to be redirected, such as \"F:\" or \"LPT1\". The string is treated in a case-insensitive manner. If the string is NULL, a connection to the network resource is made without redirecting the local device."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The \t\t\t\tWNetAddConnection2 function makes a connection to a network resource and can redirect a local device to the network resource.",
    "library": "Mpr.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnetwk.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value can be one of the following error codes or one of the  system error codes.  ",
    "remarks": "On Windows Server 2003 and Windows XP, the WNet functions create and delete network drive letters in the MS-DOS device namespace associated with a logon session because MS-DOS devices are identified by AuthenticationID (a   locally unique identifier, or LUID, associated with a logon session.) This can affect applications that call one of the WNet functions to create a network drive letter under one user logon, but query for existing network drive letters under a different user logon. An example of this situation could be when a user's second logon is created within a logon session, for example, by calling the  CreateProcessAsUser function, and the second logon runs an application that calls the  GetLogicalDrives function. The call to the GetLogicalDrives function does not return network drive letters created by WNet function calls under the first logon. Note that in the preceding example the first logon session still exists, and the example could apply to any logon session, including a Terminal Services session. For more information, see  Defining an MS-DOS Device Name. On Windows Server 2003 and Windows XP, if a service that runs as LocalSystem calls the WNetAddConnection2 function, then the mapped drive is visible to all user logon sessions. For Microsoft network providers, the lpRemoteName member of the NETRESOURCE structure pointed to by the lpNetResource parameter can contain an IPv4 address in dotted-decimal notation. An example for a share might be the following: \\\\192.168.1.1\\share For Microsoft network providers on Windows Vista and later, the lpRemoteName member of the NETRESOURCE structure pointed to by the lpNetResource parameter can contain an IPv6 address. However, the IPv6 literal format must be used so that the IPv6 address is parsed correctly. An IPv6 literal address is of the form: ipv6-address with the ':' characters replaced by '-' characters followed by the \".ipv6-literal.net\" string. For example, for the following IPv6 address: 2001:4898:9:3:c069:aa97:fe76:2449 an example for a share might be the following: \\\\2001-4898-9-3-c069-aa97-fe76-2449.ipv6-literal.net\\share Other network providers may support the lpRemoteName member of the NETRESOURCE structure pointed to by the lpNetResource parameter that contains an IPv4 or IPv6 address, but this is up to specific network provider. Windows 7 and Windows Server 2008 R2:  If the WNetAddConnection2 function is called with explicit user credentials specified in the pUsername and lpPassword to establish a connection with a network resource on a specific server and then called again with either of these parameters as NULL (to use the default user name or default password) to the same server, the call with fail. The error returned will be ERROR_BAD_USERNAME or ERROR_INVALID_PASSWORD. The following code sample illustrates how to use the  WNetAddConnection2 function to make connection to a network resource. For other code samples that illustrates how to make a connection to a network resource using the  WNetAddConnection2 function, see  Adding a Network Connection and Assigning a Drive to a Share. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "WNetAddConnection2",
    "is_callback": 0,
    "dll": "Mpr.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "A pointer to a  NETRESOURCE structure that specifies details of the proposed connection, such as information about the network resource, the local device, and the network resource provider.     You must specify the following members of the  NETRESOURCE structure.  MemberMeaning  dwType   The type of network resource to connect to.     If the lpLocalName member points to a nonempty string, this member can be equal to RESOURCETYPE_DISK or RESOURCETYPE_PRINT. If lpLocalName is NULL, or if it points to an empty string, dwType can be equal to RESOURCETYPE_DISK, RESOURCETYPE_PRINT, or RESOURCETYPE_ANY. Although this member is required, its information may be ignored by the network service provider.   lpLocalName   A pointer to a null-terminated string that specifies the name of a local device to redirect, such as \"F:\" or \"LPT1\". The string is treated in a case-insensitive manner. If the string is empty, or if lpLocalName is NULL, the function makes a connection to the network resource without redirecting a local device.   lpRemoteName   A pointer to a null-terminated string that specifies the network resource to connect to. The string can be up to MAX_PATH characters in length, and must follow the network provider's naming conventions.   lpProvider   A pointer to a null-terminated string that specifies the network provider to connect to.     If lpProvider is NULL, or if it points to an empty string, the operating system attempts to determine the correct provider by parsing the string pointed to by the lpRemoteName member. If this member is not NULL, the operating system attempts to make a connection only to the named network provider. You should set this member only if you know the network provider you want to use. Otherwise, let the operating system determine which provider the network name maps to.     The  WNetAddConnection2 function ignores the other members of the  NETRESOURCE structure."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpPassword",
        "description": "A pointer to a constant null-terminated string that specifies a password to be used in making the network connection. If lpPassword is NULL, the function uses the current default password associated with the user specified by the lpUserName parameter. If lpPassword points to an empty string, the function does not use a password. If the connection fails because of an invalid password and the CONNECT_INTERACTIVE value is set in the dwFlags parameter, the function displays a dialog box asking the user to type the password. Windows Me/98/95:  This parameter must be NULL or an empty string."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpUsername",
        "description": "A pointer to a constant null-terminated string that specifies a user name for making the connection.     If lpUserName is NULL, the function uses the default user name. (The user context for the process provides the default user name.) The lpUserName parameter is specified when users want to connect to a network resource for which they have been assigned a user name or account other than the default user name or account. The user-name string represents a  security context. It may be specific to a network provider. Windows Me/98/95:  This parameter must be NULL or an empty string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of connection options. The possible values for the connection options are defined in the Winnetwk.h header file.  The following values can currently be used.  ValueMeaning  CONNECT_UPDATE_PROFILE 0x00000001   The network resource connection should be remembered.     If this bit flag is set, the operating system automatically attempts to restore the connection when the user logs on.  The operating system remembers only successful connections that redirect local devices. It does not remember connections that are unsuccessful or deviceless connections. (A deviceless connection occurs when the lpLocalName member is NULL or points to an empty string.) If this bit flag is clear, the operating system does not try to restore the connection when the user logs on.   CONNECT_UPDATE_RECENT 0x00000002   The network resource connection should not be put in the recent connection list.    If this flag is set and the connection is successfully added, the network resource connection will be put in the recent connection list only if it has a redirected local device associated with it.    CONNECT_TEMPORARY 0x00000004   The network resource connection should not be remembered.    If this flag is set, the operating system will not attempt to restore the connection when the user logs on again.   CONNECT_INTERACTIVE 0x00000008   If this flag is set, the operating system may interact with the user for authentication purposes.   CONNECT_PROMPT 0x00000010   This flag instructs the system not to use any default settings for user names or passwords without offering the user the opportunity to supply an alternative. This flag is ignored unless CONNECT_INTERACTIVE is also set.   CONNECT_REDIRECT 0x00000080   This flag forces the redirection of a local device when making the connection. If the lpLocalName member of  NETRESOURCE specifies a local device to redirect, this flag has no effect, because the operating system still attempts to redirect the specified device. When the operating system automatically chooses a local device, the dwType member must not be equal to RESOURCETYPE_ANY. If this flag is not set, a local device is automatically chosen for redirection only if the network requires a local device to be redirected. Windows Server 2003 and Windows XP:  When the system automatically assigns network drive letters, letters are assigned beginning with Z:, then Y:, and ending with C:. This reduces collision between per-logon drive letters (such as network drive letters) and global drive letters (such as disk drives). Note that earlier versions of Windows assigned drive letters beginning with C: and ending with Z:.   CONNECT_CURRENT_MEDIA 0x00000200   If this flag is set, then the operating system does  not start to use a new media to try to establish the connection (initiate a new dial up connection, for example).   CONNECT_COMMANDLINE 0x00000800   If this flag is set, the operating system prompts the user for authentication using the command line instead of a graphical user interface (GUI). This flag is ignored unless CONNECT_INTERACTIVE is also set. Windows XP:  This value is supported on Windows XP and later.   CONNECT_CMD_SAVECRED 0x00001000   If this flag is set, and the operating system prompts for a credential, the credential should be saved by the credential manager. If the credential manager is disabled for the caller's logon session, or if the network provider does not support saving credentials, this flag is ignored. This flag is ignored unless CONNECT_INTERACTIVE is also set. This flag is also ignored unless you set the CONNECT_COMMANDLINE flag. Windows XP:  This value is supported on Windows XP and later.   CONNECT_CRED_RESET 0x00002000   If this flag is set, and the operating system prompts for a credential, the credential is reset by the credential manager. If the credential manager is disabled for the caller's logon session, or if the network provider does not support saving credentials, this flag is ignored. This flag is also ignored unless you set the CONNECT_COMMANDLINE flag. Windows Vista:  This value is supported on Windows Vista and later."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The \t\t\t\tWNetAddConnection3 function makes a connection to a network resource. The function can redirect a local device to the network resource.",
    "library": "Mpr.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnetwk.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is a  system error code, such as one of the following values.  ",
    "remarks": "The  WNetUseConnection function is similar to the  WNetAddConnection3 function. The main difference is that  WNetUseConnection can automatically select an unused local device to redirect to the network resource. On Windows Server 2003 and Windows XP, the WNet functions create and delete network drive letters in the MS-DOS device namespace associated with a logon session because MS-DOS devices are identified by AuthenticationID (a   locally unique identifier, or LUID, associated with a logon session.) This can affect applications that call one of the WNet functions to create a network drive letter under one user logon, but query for existing network drive letters under a different user logon. An example of this situation could be when a user's second logon is created within a logon session, for example, by calling the  CreateProcessAsUser function, and the second logon runs an application that calls the  GetLogicalDrives function. The call to the GetLogicalDrives function does not return network drive letters created by WNet function calls under the first logon. Note that in the preceding example the first logon session still exists, and the example could apply to any logon session, including a Terminal Services session. For more information, see  Defining an MS-DOS Device Name. On Windows Server 2003 and Windows XP, if a service that runs as LocalSystem calls the WNetAddConnection3 function, then the mapped drive is visible to all user logon sessions. For Microsoft network providers, the lpRemoteName member of the NETRESOURCE structure pointed to by the lpNetResource parameter can contain an IPv4 address in dotted-decimal notation. An example for a share might be the following: \\\\192.168.1.1\\share For Microsoft network providers on Windows Vista and later, the lpRemoteName member of the NETRESOURCE structure pointed to by the lpNetResource parameter can contain an IPv6 address. However, the IPv6 literal format must be used so that the IPv6 address is parsed correctly. An IPv6 literal address is of the form: ipv6-address with the ':' characters replaced by '-' characters followed by the \".ipv6-literal.net\" string. For example, for the following IPv6 address: 2001:4898:9:3:c069:aa97:fe76:2449 an example for a share might be the following: \\\\2001-4898-9-3-c069-aa97-fe76-2449.ipv6-literal.net\\share Other network providers may support the lpRemoteName member of the NETRESOURCE structure pointed to by the lpNetResource parameter that contains an IPv4 or IPv6 address, but this is up to specific network provider. Windows 7 and Windows Server 2008 R2:  If the WNetAddConnection3 function is called with explicit user credentials specified in the pUsername and lpPassword to establish a connection with a network resource on a specific server and then called again with either of these parameters as NULL (to use the default user name or default password) to the same server, the call with fail. The error returned will be ERROR_BAD_USERNAME or ERROR_INVALID_PASSWORD. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "WNetAddConnection3",
    "is_callback": 0,
    "dll": "Mpr.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndOwner",
        "description": "A handle to a window that the provider of network resources can use as an owner window for dialog boxes. Use this parameter if you set the CONNECT_INTERACTIVE value in the dwFlags parameter. The hwndOwner parameter can be NULL. If it is, a call to  WNetAddConnection3 is equivalent to calling the  WNetAddConnection2 function."
      },
      {
        "in_out": "_In_",
        "type": "LPNETRESOURCE",
        "name": "lpNetResource",
        "description": "A pointer to a  NETRESOURCE structure that specifies details of the proposed connection, such as information about the network resource, the local device, and the network resource provider.     You must specify the following members of the  NETRESOURCE structure.  MemberMeaning  dwType   The type of network resource to connect to.     If the lpLocalName member points to a nonempty string, this member can be equal to RESOURCETYPE_DISK or RESOURCETYPE_PRINT. If lpLocalName is NULL, or if it points to an empty string, dwType can be equal to RESOURCETYPE_DISK, RESOURCETYPE_PRINT, or RESOURCETYPE_ANY. Although this member is required, its information may be ignored by the network service provider.   lpLocalName   A pointer to a null-terminated string that specifies the name of a local device to redirect, such as \"F:\" or \"LPT1\". The string is treated in a case-insensitive manner. If the string is empty or if lpLocalName is NULL, the function makes a connection to the network resource without redirecting a local device.   lpRemoteName   A pointer to a null-terminated string that specifies the network resource to connect to. The string can be up to MAX_PATH characters in length, and must follow the network provider's naming conventions.   lpProvider   A pointer to a null-terminated string that specifies the network provider to connect to. If lpProvider is NULL, or if it points to an empty string, the operating system attempts to determine the correct provider by parsing the string pointed to by the lpRemoteName member. If this member is not NULL, the operating system attempts to make a connection only to the named network provider. You should set this member only if you know which network provider you want to use. Otherwise, let the operating system determine which network provider the network name maps to.     The  WNetAddConnection3 function ignores the other members of the  NETRESOURCE structure."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpPassword",
        "description": "A pointer to a null-terminated string that specifies a password to be used in making the network connection.     If lpPassword is NULL, the function uses the current default password associated with the user specified by the lpUserName parameter. \t\t\t\t\t\t If lpPassword points to an empty string, the function does not use a password. If the connection fails because of an invalid password and the CONNECT_INTERACTIVE value is set in the dwFlags parameter, the function displays a dialog box asking the user to type the password. Windows Me/98/95:  This parameter must be NULL or an empty string."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpUserName",
        "description": "A pointer to a null-terminated string that specifies a user name for making the connection.     If lpUserName is NULL, the function uses the default user name. (The user context for the process provides the default user name.) The lpUserName parameter is specified when users want to connect to a network resource for which they have been assigned a user name or account other than the default user name or account. The user-name string represents a  security context. It may be specific to a network provider. Windows Me/98/95:  This parameter must be NULL or an empty string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of connection options. The following values are currently defined.  ValueMeaning  CONNECT_INTERACTIVE   If this flag is set, the operating system may interact with the user for authentication purposes.   CONNECT_PROMPT   This flag instructs the system not to use any default settings for user names or passwords without offering the user the opportunity to supply an alternative. This flag is ignored unless CONNECT_INTERACTIVE is also set.   CONNECT_REDIRECT   This flag forces the redirection of a local device when making the connection.     If the lpLocalName member of  NETRESOURCE specifies a local device to redirect, this flag has no effect, because the operating system still attempts to redirect the specified device. When the operating system automatically chooses a local device, the dwType member must not be equal to RESOURCETYPE_ANY. If this flag is not set, a local device is automatically chosen for redirection only if the network requires a local device to be redirected. Windows Server 2003 and Windows XP:  When the system automatically assigns network drive letters, letters are assigned beginning with Z:, then Y:, and ending with C:. This reduces collision between per-logon drive letters (such as network drive letters) and global drive letters (such as disk drives). Note that earlier versions of Windows assigned drive letters beginning with C: and ending with Z:.   CONNECT_UPDATE_PROFILE   The network resource connection should be remembered. If this bit flag is set, the operating system automatically attempts to restore the connection when the user logs on. The operating system remembers only successful connections that redirect local devices. It does not remember connections that are unsuccessful or deviceless connections. (A deviceless connection occurs when the lpLocalName member is NULL or when it points to an empty string.) If this bit flag is clear, the operating system does not automatically restore the connection at logon.   CONNECT_COMMANDLINE   If this flag is set, the operating system prompts the user for authentication using the command line instead of a graphical user interface (GUI). This flag is ignored unless CONNECT_INTERACTIVE is also set. Windows 2000/NT and Windows Me/98/95:  This value is not supported.   CONNECT_CMD_SAVECRED   If this flag is set, and the operating system prompts for a credential, the credential should be saved by the credential manager. If the credential manager is disabled for the caller's logon session, or if the network provider does not support saving credentials, this flag is ignored. This flag is also ignored unless you set the CONNECT_COMMANDLINE flag. Windows 2000/NT and Windows Me/98/95:  This value is not supported."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The Multiple Provider Router (MPR) calls CancelConnectNotify before and after each cancel connection operation (WNetCancelConnection and  WNetCancelConnection2).",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, the function should return WN_SUCCESS. If the function fails, it should return an error code. This can be any of the error codes specified in  Network Security Return Values. ",
    "remarks": "The CancelConnectNotify function is implemented by applications that need to receive notification from the MPR when a network resource is connected or disconnected. For more information about how to write an application that receives such notifications, see  Receiving Connection Notifications. ",
    "return_type": "DWORD APIENTRY",
    "category": "Authentication",
    "name": "CancelConnectNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPNOTIFYINFO",
        "name": "lpNotifyInfo",
        "description": "A pointer to a  NOTIFYINFO structure that contains information about the notification."
      },
      {
        "in_out": "_In_",
        "type": "LPNOTIFYCANCEL",
        "name": "lpCancelInfo",
        "description": "A pointer to a  NOTIFYCANCEL structure that contains the cancel connection specific information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The \t\t\t\tWNetCancelConnection function cancels an existing network connection.",
    "library": "Mpr.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnetwk.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is a  system error code, such as one of the following values.  ",
    "remarks": "Windows Server 2003 and Windows XP:  The WNet functions create and delete network drive letters in the MS-DOS device namespace associated with a logon session because MS-DOS devices are identified by AuthenticationID. (An AuthenticationID is the  locally unique identifier, or LUID, associated with a logon session.) This can affect applications that call one of the WNet functions to create a network drive letter under one user logon, but query for existing network drive letters under a different user logon. An example of this situation could be when a user's second logon is created within a logon session, for example, by calling the  CreateProcessAsUser function, and the second logon runs an application that calls the  GetLogicalDrives function. GetLogicalDrives does not return network drive letters created by a WNet function under the first logon. Note that in the preceding example the first logon session still exists, and the example could apply to any logon session, including a Terminal Services session. For more information, see  Defining an MS-DOS Device Name. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "WNetCancelConnection",
    "is_callback": 0,
    "dll": "Mpr.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "Pointer to a constant null-terminated string that specifies the name of either the redirected local device or the remote network resource to disconnect from.     When this parameter specifies a redirected local device, the function cancels only the specified device redirection. If the parameter specifies a remote network resource, only the connections to remote networks without devices are canceled."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fForce",
        "description": "Specifies whether or not the disconnection should occur if there are open files or jobs on the connection. If this parameter is FALSE, the function fails if there are open files or jobs."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The \t\t\t\tWNetCancelConnection2 function cancels an existing network connection. You can also call the function to remove remembered network connections that are not currently connected.",
    "library": "Mpr.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winnetwk.h",
    "return_value": "If the function succeeds, the return value is NO_ERROR. If the function fails, the return value is a  system error code, such as one of the following values.  ",
    "remarks": "Windows Server 2003 and Windows XP:  The WNet functions create and delete network drive letters in the MS-DOS device namespace associated with a logon session because MS-DOS devices are identified by AuthenticationID. (An AuthenticationID is the  locally unique identifier, or LUID, associated with a logon session.) This can affect applications that call one of the WNet functions to create a network drive letter under one user logon, but query for existing network drive letters under a different user logon. An example of this situation could be when a user's second logon is created within a logon session, for example, by calling the  CreateProcessAsUser function, and the second logon runs an application that calls the  GetLogicalDrives function. GetLogicalDrives does not return network drive letters created by a WNet function under the first logon. Note that in the preceding example the first logon session still exists, and the example could apply to any logon session, including a Terminal Services session. For more information, see  Defining an MS-DOS Device Name. For a code sample that illustrates how to cancel a connection to a network resource with a call to the  WNetCancelConnection2 function, see  Canceling a Network Connection. ",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "WNetCancelConnection2",
    "is_callback": 0,
    "dll": "Mpr.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpName",
        "description": "Pointer to a constant null-terminated string that specifies the name of either the redirected local device or the remote network resource to disconnect from.     If  this parameter specifies a redirected local device, the function cancels only the specified device redirection. If the parameter specifies a remote network resource, all connections without devices are canceled."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Connection type. The following values are defined.     ValueMeaning  0   The system does not update information about the connection.     If the connection was marked as persistent in the registry, the system continues to restore the connection at the next logon. If the connection was not marked as persistent, the function ignores the setting of the CONNECT_UPDATE_PROFILE flag.   CONNECT_UPDATE_PROFILE   The system updates the user profile with the information that the connection is no longer a persistent one.     The system will not restore this connection during subsequent logon operations. (Disconnecting resources using remote names has no effect on persistent connections.)"
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fForce",
        "description": "Specifies whether the disconnection should occur if there are open files or jobs on the connection. If this parameter is FALSE, the function fails if there are open files or jobs."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The LsaConnectUntrusted function establishes an untrusted connection to the LSA server.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "LsaConnectUntrusted returns a handle to an untrusted connection; it does not verify any information about the caller. The handle should be closed using the  LsaDeregisterLogonProcess function. If your application simply needs to query information from authentication packages, you can use the handle returned by this function in calls to  LsaCallAuthenticationPackage and  LsaLookupAuthenticationPackage. Applications with the SeTcbPrivilege privilege may create a trusted connection by calling  LsaRegisterLogonProcess. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaConnectUntrusted",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "LsaHandle",
        "description": "Pointer to a handle that receives the connection handle, which must be provided in future authentication services."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The LsaDeregisterLogonProcess function deletes the caller's logon application context and closes the connection to the LSA server.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "If your logon application references the connection handle after calling the LsaDeregisterLogonProcess function, unexpected behavior can result. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaDeregisterLogonProcess",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "LsaHandle",
        "description": "Handle obtained from a  LsaRegisterLogonProcess or  LsaConnectUntrusted call."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The LsaEnumerateLogonSessions function retrieves the set of existing logon session identifiers (LUIDs) and the number of sessions.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason. ",
    "remarks": "To retrieve information about the logon sessions returned by LsaEnumerateLogonSessions, call the  LsaGetLogonSessionData function. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "LsaEnumerateLogonSessions",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "LogonSessionCount",
        "description": "Pointer to a long integer that receives the number of elements returned in the array returned in LogonSessionList parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PLUID",
        "name": "*LogonSessionList",
        "description": "Address of a pointer to a LUID. The pointer receives the first element of an array of logon session identifiers. The memory used by the array is allocated by the LSA. When the array is no longer needed, call the  LSAFreeReturnBuffer function to free it."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The LsaFreeReturnBuffer function frees the memory used by a buffer previously allocated by the LSA.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "Some of the LSA authentication functions allocate memory buffers to hold returned information, for example,  LsaLogonUser and  LsaCallAuthenticationPackage. Your application should call LsaFreeReturnBuffer to free these buffers when they are no longer needed. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaFreeReturnBuffer",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to the buffer to be freed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The LsaGetLogonSessionData function retrieves information about a specified logon session.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code indicating the reason. ",
    "remarks": "To obtain valid logon session identifiers that may be passed to this function's LogonId parameter, call the  LsaEnumerateLogonSessions function. If  LogonID specifies the LocalSystem account (0x0:0x3e7), then this function returns zero for the logon session data retrieved in ppLogonSessionData. The reason is that the LocalSystem account does not get logged on in the typical logon manner. Rather, the LocalSystem account is active after the system starts. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "LsaGetLogonSessionData",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "Specifies a pointer to a LUID that identifies the logon session whose information will be retrieved. For information about valid values for this parameter, see Remarks."
      },
      {
        "in_out": "_Out_",
        "type": "PSECURITY_LOGON_SESSION_DATA",
        "name": "*ppLogonSessionData",
        "description": "Address of a pointer to a  SECURITY_LOGON_SESSION_DATA structure containing information on the logon session specified by LogonId. This structure is allocated by the LSA. When the information is no longer needed, call the  LSAFreeReturnBuffer function to free the memory used by this structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 14,
    "description": "The LsaLogonUser function authenticates a security principal's logon data by using stored credentials information.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the function returns  STATUS_SUCCESS. If the function fails, it returns  an NTSTATUS code, which can be one of the following values.  For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "The OriginName parameter should specify meaningful information. For example, it might contain \"TTY1\" to indicate terminal one or \"NTLM - remote node JAZZ\" to indicate a network logon that uses NTLM through a remote node called \"JAZZ\". You must call LsaLogonUser separately to update PKINIT device credentials for LOCAL_SYSTEM and NETWORK_SERVICE. When there is no PKINIT device credential, a successful call does no operation. When there is a PKINIT device credential, a successful call cleans up the PKINIT device credential so that only the password credential remains. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaLogonUser",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "LsaHandle",
        "description": "A handle obtained from a previous call to  LsaRegisterLogonProcess. The caller is required to have SeTcbPrivilege only if one or more of the following is true:  A Subauthentication package is used.  KERB_S4U_LOGON is used, and the caller requests an impersonation token. The LocalGroups parameter is not NULL.   If SeTcbPrivilege is not required, call LsaConnectUntrusted to obtain the handle."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_STRING",
        "name": "OriginName",
        "description": "A string that identifies the origin of the logon attempt. For more information, see Remarks."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_LOGON_TYPE",
        "name": "LogonType",
        "description": "A  value of the SECURITY_LOGON_TYPE enumeration that specifies the type of logon requested. If LogonType is Interactive or Batch, a primary token is generated to represent the new user. If LogonType is Network, an impersonation token is generated."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationPackage",
        "description": "An identifier of the authentication package to use for the authentication. You can obtain this value by calling  LsaLookupAuthenticationPackage."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "AuthenticationInformation",
        "description": "A pointer to an input buffer that contains authentication information, such as user name and password. The format and content of this buffer are determined by the authentication package. This parameter can be one of the following input buffer structures for the MSV1_0 and Kerberos authentication packages.  ValueMeaning  MSV1_0_INTERACTIVE_LOGON MSV1_0   Authenticating an interactive user logon. The LogonDomainName,  UserName, and Password  members of the MSV1_0_INTERACTIVE_LOGON structure must point to buffers in memory that are contiguous to the structure itself. The value of the AuthenticationInformationLength parameter must take into account the length of these buffers.   KERB_INTERACTIVE_LOGON Kerberos   Authenticating an interactive user logon.   KERB_TICKET_LOGON Kerberos   Authenticating a user on initial network logon or disconnect.   KERB_TICKET_UNLOCK_LOGON Kerberos   Authenticating a user on ticket refresh, a variation of the normal workstation unlock logon.   KERB_CERTIFICATE_LOGON Kerberos   Authenticating a user using an interactive smart card logon.   KERB_CERTIFICATE_S4U_LOGON Kerberos   Authenticating a user using a service for user (S4U) logon.   KERB_CERTIFICATE_UNLOCK_LOGON Kerberos   Authenticating a user to unlock a workstation that has been locked during an interactive smart card logon session.   KERB_SMARTCARD_LOGON Kerberos   Authenticating a user smart card logon using LOGON32_PROVIDER_WINNT50 or LOGON32_PROVIDER_DEFAULT.   KERB_SMARTCARD_UNLOCK_LOGON Kerberos   Authenticating a user to unlock a workstation that has been locked during a smart card logon session.   KERB_S4U_LOGON Kerberos   Authenticating a user using S4U client requests. For constrained delegation, a call to LsaLogonUser is not necessary if the client logged on using an LSA-mode authentication package. On Windows operating systems, these include Kerberos, NTLM, Secure Channel, and Digest. For this call to succeed, the following must be true:  The caller must be a domain account (this includes LOCAL_SYSTEM if the computer is a domain member). If using a service account, the account must have SeTcbPrivilege set on the local computer to get an impersonation token. Otherwise, the identity token is used. The caller must be a member of the Pre-Windows 2000 Compatible Access or have read access to the group memberships of the client. Membership in the Windows Authorization Access group guarantees read access to group membership of the client. For information about how to configure the Windows Authorization Access group, see the Microsoft Knowledge Base.  The ClientUpn and ClientRealm members of the KERB_S4U_LOGON structure must point to buffers in memory that are contiguous to the structure itself. The value of the AuthenticationInformationLength parameter must take into account the length of these buffers.   MSV1_0_LM20_LOGON MSV1_0   Processing the second half of an NTLM 2.0 protocol logon. The first half of this type of logon is performed by calling  LsaCallAuthenticationPackage with the MsV1_0Lm20ChallengeRequest message. For more information, see the description of MsV1_0Lm20ChallengeRequest in  MSV1_0_PROTOCOL_MESSAGE_TYPE. This type of logon can use a subauthentication package.   MSV1_0_SUBAUTH_LOGON MSV1_0   Authenticating a user with subauthentication.     For more information about the buffer used by other authentication packages, see the documentation for those authentication packages."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "AuthenticationInformationLength",
        "description": "The length, in bytes, of the AuthenticationInformation buffer."
      },
      {
        "in_out": "_In_opt_",
        "type": "PTOKEN_GROUPS",
        "name": "LocalGroups",
        "description": "A list of additional group identifiers to add to the token of the authenticated user. These group identifiers will be added, along with the default group WORLD and the logon type group (Interactive, Batch, or Network), which are automatically included in every user token."
      },
      {
        "in_out": "_In_",
        "type": "PTOKEN_SOURCE",
        "name": "SourceContext",
        "description": "A TOKEN_SOURCE structure that identifies the source module\u2014for example, the session manager\u2014and the context that may be useful to that module. ..."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*ProfileBuffer",
        "description": "A pointer to a void pointer that receives the address of an output buffer that contains authentication information, such as the logon shell and home directory. This parameter can be one of the following output buffer structures for the MSV1_0 and Kerberos authentication packages.  ValueMeaning  MSV1_0_INTERACTIVE_PROFILE MSV1_0   An interactive user's logon profile.   KERB_TICKET_PROFILE Kerberos   Logon, disconnect, and ticket refresh authentication output.   MSV1_0_LM20_LOGON MSV1_0   Output when processing the second half of a NTLM 2.0 protocol logon.   MSV1_0_LM20_LOGON_PROFILE MSV1_0   Output when using authentication with subauthentication.     For more information about the buffer used by other authentication packages, see the documentation for that authentication package. When this buffer is no longer needed, the calling application must free this buffer by calling  the LsaFreeReturnBuffer function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "ProfileBufferLength",
        "description": "A pointer to a ULONG that receives the length, in bytes, of the returned profile buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PLUID",
        "name": "LogonId",
        "description": "A pointer to a buffer that receives an  LUID that uniquely identifies the logon session. This LUID is assigned by the domain controller that authenticated the logon information."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "Token",
        "description": "A pointer to a handle that receives the new user token created for this session. When you have finished using the token, release it by calling the CloseHandle function."
      },
      {
        "in_out": "_Out_",
        "type": "PQUOTA_LIMITS",
        "name": "Quotas",
        "description": "When a primary token is returned, this parameter receives a  QUOTA_LIMITS structure that contains the process quota limits assigned to the newly logged on user's initial process."
      },
      {
        "in_out": "_Out_",
        "type": "PNTSTATUS",
        "name": "SubStatus",
        "description": "If the logon failed due to account restrictions, this parameter receives information about why the logon failed. This value is set only if the account information of the user is valid and the logon is rejected. This parameter can be one of the following SubStatus values for the MSV1_0 authentication package.  ValueMeaning  STATUS_INVALID_LOGON_HOURS   The user account has time restrictions and cannot be used to log on at this time.   STATUS_INVALID_WORKSTATION   The user account has workstation restrictions and cannot be used to log on from the current workstation.   STATUS_PASSWORD_EXPIRED   The user-account password has expired.   STATUS_ACCOUNT_DISABLED   The user account is currently disabled and cannot be used to log on."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LsaLookupAuthenticationPackage function obtains the unique identifier of an authentication package.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. The following are possible error codes.  For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "The authentication package identifier is used in calls to authentication functions such as  LsaLogonUser and  LsaCallAuthenticationPackage. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaLookupAuthenticationPackage",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "LsaHandle",
        "description": "Handle obtained from a previous call to  LsaRegisterLogonProcess or  LsaConnectUntrusted."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_STRING",
        "name": "PackageName",
        "description": "Pointer to an  LSA_STRING structure that specifies the name of the authentication package. The package name must not exceed 127 bytes in length. The following table lists the names of the Microsoft-provided authentication packages.  ValueMeaning  MSV1_0_PACKAGE_NAME   ANSI version of the MSV1_0 authentication package name.   MICROSOFT_KERBEROS_NAME_A   ANSI version of the Kerberos authentication package name.   NEGOSSP_NAME_A   ANSI version of the Negotiate authentication package name."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "AuthenticationPackage",
        "description": "Pointer to a ULONG that receives the authentication package identifier."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LsaQueryDomainInformationPolicy function retrieves domain information from the  Policy     object.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be the following value or one of the LSA Policy Function Return Values.  ",
    "remarks": "The POLICY_VIEW_LOCAL_INFORMATION access type is required to retrieve domain information from the  Policy     object. For more information, see Policy Object Access Rights. ",
    "return_type": "NTSTATUS NTAPI LsaQueryDomainInformationPolicy",
    "category": "Authentication",
    "name": "LsaQueryDomainInformationPolicy",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_HANDLE",
        "name": "PolicyHandle",
        "description": "A handle to the Policy object for the system."
      },
      {
        "in_out": "_In_",
        "type": "POLICY_DOMAIN_INFORMATION_CLASS",
        "name": "InformationClass",
        "description": "POLICY_DOMAIN_INFORMATION_CLASS enumeration that specifies the information to be returned from the  Policy     object. The following table shows the possible values.  ValueMeaning  PolicyDomainEfsInformation   The information is for Encrypting File System.   PolicyDomainKerberosTicketInformation   The information is for a Kerberos ticket."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*Buffer",
        "description": "Pointer to a buffer that receives the requested information."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LsaQueryForestTrustInformation function retrieves forest trust information     for the specified Local Security Authority TrustedDomain object.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be one of the following values or one of the LSA Policy Function Return Values.  ",
    "remarks": "Access to this function is protected by a securable object. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "LsaQueryForestTrustInformation",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_HANDLE",
        "name": "PolicyHandle",
        "description": "A handle to the Policy object for the system."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_UNICODE_STRING",
        "name": "TrustedDomainName",
        "description": "Pointer to an LSA_UNICODE_STRING structure that contains the name of the TrustedDomain object for which to retrieve forest trust information."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_FOREST_TRUST_INFORMATION",
        "name": "*ForestTrustInfo",
        "description": "Pointer to an LSA_FOREST_TRUST_INFORMATION structure that returns the forest trust information for the TrustedDomain object specified by the TrustedDomainName parameter."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 3,
    "description": "The LsaRegisterLogonProcess function establishes a connection to the LSA server and verifies that the caller is a logon application.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. The following are possible error codes.  For more information, see  LSA Policy Function Return Values. The  LsaNtStatusToWinError function converts an NTSTATUS code to a Windows error code. ",
    "remarks": "This function must be called before a logon process may use any other logon authentication functions provided by the LSA. The LsaRegisterLogonProcess function verifies that the application making the function call is a logon process by checking that it has the SeTcbPrivilege privilege set. It also opens the application's process for PROCESS_DUP_HANDLE access in anticipation of future LSA authentication calls. For more information, see  DuplicateHandle. When you have finished using the connection to the LSA server, delete the caller's logon application context and close the connection by calling the LsaDeregisterLogonProcess function. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaRegisterLogonProcess",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_STRING",
        "name": "LogonProcessName",
        "description": "Pointer to an  LSA_STRING structure identifying the logon application. This should be a printable name suitable for display to administrators. For example, the Windows logon application might use the name \"User32LogonProcess\". This name is used by the LSA during auditing. LsaRegisterLogonProcess does not check whether the name is already in use.     This string must not exceed 127 bytes."
      },
      {
        "in_out": "_Out_",
        "type": "PHANDLE",
        "name": "LsaHandle",
        "description": "Pointer that receives a handle used in future authentication function calls."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_OPERATIONAL_MODE",
        "name": "SecurityMode",
        "description": "The value returned is not meaningful and should be ignored."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LsaSetDomainInformationPolicy function sets domain information to the  Policy     object.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be the following value or one of the LSA Policy Function Return Values.  ",
    "remarks": "The POLICY_TRUST_ADMIN access type is required to set domain information to the  Policy     object. For more information, see Policy Object Access Rights. ",
    "return_type": "NTSTATUS NTAPI LsaSetDomainInformationPolicy",
    "category": "Authentication",
    "name": "LsaSetDomainInformationPolicy",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_HANDLE",
        "name": "PolicyHandle",
        "description": "A handle to the Policy object for the system."
      },
      {
        "in_out": "_In_",
        "type": "POLICY_DOMAIN_INFORMATION_CLASS",
        "name": "InformationClass",
        "description": "POLICY_DOMAIN_INFORMATION_CLASS enumeration that specifies the information to be set to the  Policy     object. The following table shows the possible values.  ValueMeaning  PolicyDomainEfsInformation   The information is for Encrypting File System.   PolicyDomainKerberosTicketInformation   The information is for a Kerberos ticket."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a buffer that contains  the  information to set to the  Policy     object."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The LsaSetForestTrustInformation function sets the forest trust information for a specified Local Security Authority TrustedDomain object.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code, which can be one of the following values or one of the LSA Policy Function Return Values.  ",
    "remarks": "",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "LsaSetForestTrustInformation",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_HANDLE",
        "name": "PolicyHandle",
        "description": "A handle to the Policy object for the system."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_UNICODE_STRING",
        "name": "TrustedDomainName",
        "description": "Pointer to an LSA_UNICODE_STRING structure that contains the name of the TrustedDomain object to which to set the forest trust information specified by the ForestTrustInfo parameter."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_FOREST_TRUST_INFORMATION",
        "name": "ForestTrustInfo",
        "description": "Pointer to an LSA_FOREST_TRUST_INFORMATION structure that contains the forest trust information to set to the TrustedDomain object specified by the TrustedDomainName parameter."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "CheckOnly",
        "description": "Boolean value that specifies whether changes to the TrustedDomain object are persisted. If this value is TRUE, this function will check for collisions with the specified parameters but will not set the  forest trust information specified by the ForestTrustInfo parameter to the TrustedDomain object specified by the TrustedDomainName parameter. If this value is FALSE, the forest trust information will be set to the  TrustedDomain object."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_FOREST_TRUST_COLLISION_INFORMATION",
        "name": "*CollisionInfo",
        "description": "Pointer to a pointer to an LSA_FOREST_TRUST_COLLISION_INFORMATION structure that returns information about any collisions that occurred."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 9,
    "description": "The Msv1_0SubAuthenticationFilter function performs user logon authentication that is specific to domain controllers.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Subauth.h",
    "return_value": "This function must return one of the following values.  When the Msv1_0SubAuthenticationFilter function is used with the Kerberos authentication package, if the function call returns STATUS_SUCCESS and one of the two parameters LogoffTime or KickoffTime has a nonzero value, this value is used as the ticket lifetime. If, on the other hand, the values of both parameters are nonzero, the smaller of these two values is used. If the value that is used for the ticket lifetime (the sooner of LogoffTime and KickoffTime) is greater than the default ticket lifetime, then that value will be used as the maximum renewal time for the ticket. Conversely, if the larger of the two values (the later of LogoffTime and KickoffTime) is less than the default ticket lifetime, this value will be used as the ticket lifetime. For more information, see  Microsoft Kerberos. When used with the Kerberos authentication package, if this function returns an error, the Key Distribution Center (KDC) will return the Kerberos error KDC_ERR_POLICY, with the status value as the extended error code. ",
    "remarks": "Implementations of this function should not execute any operations that cause Lightweight Directory Access Protocol (LDAP) traffic. For example, do not connect to and query the Active Directory database. After the MSV1_0 or Kerberos authentication package has validated a logon, the Msv1_0SubAuthenticationFilter function can perform additional validation to determine whether a user can log on to a network account. This function is called if the subauthentication package DLL is properly registered as 'Auth0' in the domain controller's registry. The registry path is different depending on whether the function is in a MSV1_0 or Kerberos Subauthentication package DLL. This filter routine may return STATUS_SUCCESS, which indicates that the logon should proceed, or a failure code, which indicates that the additional validation failed. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "Msv1_0SubAuthenticationFilter",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NETLOGON_LOGON_INFO_CLASS",
        "name": "LogonLevel",
        "description": "Specifies the level of information given in LogonInformation. This parameter is normally set to NetlogonInteractiveInformation."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "LogonInformation",
        "description": "A pointer to a  NETLOGON_LOGON_IDENTITY_INFO structure. Members of this structure contain information about the user who is logging on. The LogonDomainName member is ignored."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Optional. Contains flags that describe the circumstances of the logon. This parameter can be one of the following values.  ValueMeaning  MSV1_0_PASSTHRU   Pass-through authentication. The user is not connecting to this machine.   MSV1_0_GUEST_LOGON   This is a retry of the logon using the Guest account."
      },
      {
        "in_out": "_In_",
        "type": "PUSER_ALL_INFORMATION",
        "name": "UserAll",
        "description": "A pointer to a  USER_ALL_INFORMATION structure that contains the description of the user as returned from the SAM database."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "WhichFields",
        "description": "Returns the members of the USER_ALL_INFORMATION structure that need to be written back to the SAM database. These members will be written only if Msv1_0SubAuthenticationFilter returns success. Only the following value is valid.  ValueMeaning  USER_ALL_PARAMETERS   Write the data contained in the Parameters member of the UserAll structure back to the SAM database. If the size of the Parameters member's UNICODE_STRING buffer is changed, Msv1_0SubAuthenticationFilter must delete the buffer by using the MIDL_user_free function and reallocate it by using the MIDL_user_allocate function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "UserFlags",
        "description": "Values to be returned from the  LsaLogonUser function in that function's ProfileBuffer parameter. This parameter can be one of the following values.  ValueMeaning  LOGON_GUEST   This was a guest logon.   LOGON_NOENCRYPTION   The caller did not specify encrypted credentials.     Note  By convention, subauthentication packages return bits only in the high order byte of the UserFlags parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "Authoritative",
        "description": "A pointer to a Boolean value that indicates whether the status returned is an authoritative status that should be returned to the original caller. If the value returned is FALSE, the logon request can be tried again on another domain controller. This parameter should return valid information regardless of the return value of the function call. This parameter is not used with the Kerberos authentication package."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "LogoffTime",
        "description": "A pointer to a value that receives the time at which the user should log off the system. This time is used to control the logon lifetime and is specified as a GMT-relative Windows system time."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "KickoffTime",
        "description": "A pointer to a value that receives the time at which the user should be logged off the system. This time is used to control the logon lifetime and is specified as a GMT-relative system time. If the user is not to be automatically logged off, specify a large positive value, as follows:   C++     Copy      KickoffTime->HighPart = 0x7FFFFFFF; KickoffTime->LowPart = 0xFFFFFFFF;"
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The Msv1_0SubAuthenticationRoutine function performs client/server-specific authentication.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Subauth.h",
    "return_value": "This function must return one of the following values.  ",
    "remarks": "This function is called by the MSV1_0 authentication package if part of the AuthenticationInformation parameter indicates that subauthentication is to be done and if a subauthentication DLL that exports the Msv1_0SubAuthenticationRoutine function is correctly registered on the workstation. The MSV1_0 authentication package does not support subauthentication for interactive logons, which require the  MSV1_0_INTERACTIVE_LOGON structure. Network logons, which require the  MSV1_0_LM20_LOGON structure, can use subauthentication. The Msv1_0SubAuthenticationRoutine function is called after the correct domain controller has been located and all information about the security principal to be authenticated has been retrieved from the SAM database. When subauthentication is used, authentication is the responsibility of the subauthentication DLL and must be done by the Msv1_0SubAuthenticationRoutine function exported by that DLL. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "Msv1_0SubAuthenticationRoutine",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "NETLOGON_LOGON_INFO_CLASS",
        "name": "LogonLevel",
        "description": "Specifies the level of information given in the LogonInformation parameter. This parameter is normally set to NetlogonInteractiveInformation."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "LogonInformation",
        "description": "A pointer to a  NETLOGON_LOGON_IDENTITY_INFO structure. Members of this structure contain information about the user who is logging on. The LogonDomainName member of this structure is ignored."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Flags",
        "description": "Optional. Contains flags that describe the circumstances of the logon. This parameter can be one of the following values.  ValueMeaning  MSV1_0_PASSTHRU   Pass-through authentication. The user is not connecting to this machine.   MSV1_0_GUEST_LOGON   This is a retry of the logon using the GUEST user account."
      },
      {
        "in_out": "_In_",
        "type": "PUSER_ALL_INFORMATION",
        "name": "UserAll",
        "description": "A pointer to a  USER_ALL_INFORMATION structure that contains the description of the user as returned from the SAM database."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "WhichFields",
        "description": "Returns the members of the USER_ALL_INFORMATION structure that need to be written back to the SAM database. These members will be written only if Msv1_0SubAuthenticationRoutine returns success to the caller. Only the following value is valid.  ValueMeaning  USER_ALL_PARAMETERS   Write the data contained in the Parameters member of the UserAll structure back to the SAM database. If the size of the Parameters member's UNICODE_STRING buffer is changed, Msv1_0SubAuthenticationRoutine must delete the buffer by using the MIDL_user_free function and reallocate it by using the MIDL_user_allocate function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "UserFlags",
        "description": "Values to be returned from the  LsaLogonUser function's ProfileBuffer parameter, when it contains a  MSV1_0_LM20_LOGON_PROFILE structure. The following values are currently defined for the UserFlags member of the structure.  ValueMeaning  LOGON_GUEST   This is a guest logon.   LOGON_NOENCRYPTION   The caller did not specify encrypted credentials.     Note  By convention, subauthentication packages return bits in only the high order byte of UserFlags; however, this convention is not enforced."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "Authoritative",
        "description": "A pointer to a Boolean value that indicates whether the status returned is an authoritative status that should be returned to the original caller. If the returned value is FALSE, the logon request can be tried again on another domain controller. This parameter should return valid information regardless of the return value of the function call."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "LogoffTime",
        "description": "A pointer to a value that receives the time at which the user should log off the system. This time is used to control the logon lifetime and is specified as a GMT-relative system time."
      },
      {
        "in_out": "_Out_",
        "type": "PLARGE_INTEGER",
        "name": "KickoffTime",
        "description": "A pointer to a value that receives the time at which the user should be logged off the system. This time is used to control the logon lifetime and is specified as a GMT-relative system time. If the user is not to be logged off, specify a large positive value, such as:   C++     Copy      KickoffTime->HighPart = 0x7FFFFFFF; KickoffTime->LowPart = 0xFFFFFFFF;"
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The CredUICmdLinePromptForCredentials function prompts for and accepts credential information from a user working in a command-line (console) application. The name and password typed by the user are passed back to the calling application for verification.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The return value is a DWORD and can be one of the following values.  ",
    "remarks": "The CREDUI_FLAGS_REQUIRE_SMARTCARD, CREDUI_FLAGS_REQUIRE_CERTIFICATE, and CREDUI_FLAGS_EXCLUDE_CERTIFICATE flags are mutually exclusive. If CREDUI_FLAGS_DO_NOT_PERSIST is specified, either pszTargetName must be specified or  uiInfo->pszMessageText and uiInfo->pszCaption must be specified. The CREDUI_FLAG_USERNAME_TARGET_CREDENTIALS and CREDUI_FLAGS_GENERIC_CREDENTIALS flags are mutually exclusive. If neither is specified, the credential is a domain credential. If CREDUI_FLAGS_GENERIC_CREDENTIALS is not specified or CREDUI_FLAGS_COMPLETE_USERNAME is specified, the typed name is syntax checked. Syntax checked means that the same rules are used as are implied by CredUIParseUserName. If the typed name is not valid, the user is prompted for a valid one. If the domain portion of the typed name is missing, one will be supplied based on the target name. If CREDUI_FLAGS_GENERIC_CREDENTIALS is specified and CREDUI_FLAGS_VALIDATE_USERNAME is also specified, the typed name is syntax checked. If the typed name is not valid, the user is prompted for a valid one. If CREDUI_FLAGS_GENERIC_CREDENTIALS is specified and neither CREDUI_FLAGS_COMPLETE_USERNAME nor CREDUI_FLAGS_VALIDATE_USERNAME is specified, the typed name is not syntax checked in any way. If neither CREDUI_FLAGS_PERSIST nor CREDUI_FLAGS_DO_NOT_PERSIST are set, the save message is shown, and it controls whether the credential is saved or not. If CREDUI_FLAGS_PROMPT_FOR_SAVE is specified, the pfSave parameter must not be NULL. The CREDUI_FLAGS_REQUIRE_SMARTCARD and CREDUI_FLAGS_EXCLUDE_CERTIFICATES flags are mutually exclusive. CredUICmdLinePromptForCredentials supports prompting for a smart card certificate or a password-based credential. It does not support certificates that are not smart card certificates or prompting for both on a single call. Calling Modes Target Information Target Information is  information about the location of the resource to be accessed. For a list of all potential target names for a resource, call  CredGetTargetInfo. CredGetTargetInfo returns information that was cached by the Negotiate, NTLM, or Kerberos authentication package when one of those packages was used to authenticate to the named target. CredGetTargetInfo returns some or all of the following names for the target: Any piece of this information can be missing if the information does not apply to the target computer. For instance, a computer that is a member of a workgroup does not have a NetBIOS domain name. A computer that is a member of a Windows domain does not have a DNS domain name or DNS tree name. Credentials are stored in the credential manager based on target name. Each target name is stored as generally as possible without colliding with credentials already stored in the credential manager. An important effect of storing credentials by target name is that a particular user can  have only one credential per target stored in the credential manager. ",
    "return_type": "DWORD WINAPI",
    "category": "Authentication",
    "name": "CredUICmdLinePromptForCredentials",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pszTargetName",
        "description": "A pointer to a null-terminated string that contains the name of the target for the credentials, typically a server name. For DFS connections, this string is of the form ServerName\\ShareName. The pszTargetName parameter is used to identify the target information and is used to store and retrieve the credential."
      },
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "Reserved",
        "description": "Currently reserved and must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "dwAuthError",
        "description": "Specifies why prompting for credentials is needed. A caller can pass this Windows error parameter, returned by another authentication call, to allow the dialog box to accommodate certain errors. For example, if the password expired status code is passed, the dialog box prompts the user to change the password on the account."
      },
      {
        "in_out": "_Inout_",
        "type": "PTSTR",
        "name": "pszUserName",
        "description": "A pointer to a null-terminated string that contains the credential user name. If a nonzero-length string is specified for pszUserName, the user will be prompted only for the password. In the case of credentials other than user name/password, a marshaled format of the credential can be passed in. This string is created by calling  CredMarshalCredential.     This function writes the user-supplied name to this buffer, copying a maximum of ulUserNameMaxChars characters. The string in this format can be converted to the user name/password format by calling the  CredUIParseUsername function. The string in its marshaled format can be passed directly to a security support provider (SSP). If the CREDUI_FLAGS_DO_NOT_PERSIST flag is not specified, the value returned in this parameter is of a form that should not be inspected, printed, or persisted other than passing it to CredUIParseUsername. The subsequent results of CredUIParseUsername can  be passed only to a client-side authentication API such as WNetAddConnection or the SSP API."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulUserNameMaxChars",
        "description": "The maximum number of characters that can be copied to pszUserName including the terminating null character.     Note  CREDUI_MAX_USERNAME_LENGTH does not include the terminating null character."
      },
      {
        "in_out": "_Inout_",
        "type": "PTSTR",
        "name": "pszPassword",
        "description": "A pointer to a null-terminated string that contains the password for the credentials. If a nonzero-length string is specified for pszPassword, the password parameter will be prefilled with the string.     This function writes the user-supplied password to this buffer, copying a maximum of ulPasswordMaxChars characters. If the CREDUI_FLAGS_DO_NOT_PERSIST flag is not specified, the value returned in this parameter is of a form that should not be inspected, printed, or persisted other than passing it to a client-side authentication function such as WNetAddConnection or an SSP function. When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulPasswordMaxChars",
        "description": "The maximum number of characters that can be copied to pszPassword including the terminating null character.     Note  CREDUI_MAX_PASSWORD_LENGTH does not include the terminating null character."
      },
      {
        "in_out": "_Inout_",
        "type": "PBOOL",
        "name": "pfSave",
        "description": "A pointer to a BOOL that specifies the initial state of the Save message and receives the state of the Save message after the user has responded to the command prompt. If pfSave is not NULL and CredUIPromptForCredentials returns NO_ERROR, pfSave returns the state of the Save message. If the CREDUI_FLAGS_PERSIST flag is specified, the Save message is not displayed but is considered to be \"y\". If the CREDUI_FLAGS_DO_NOT_PERSIST flag is specified and CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX is not specified, the Save message is not displayed but is considered to be \"n\"."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A DWORD value that specifies special behavior for this function. This value can be a bitwise-OR combination of zero or more of the following values.  ValueMeaning  CREDUI_FLAGS_ALWAYS_SHOW_UI    Display a user interface if the credentials can be returned from an existing credential in credential manager. This flag is  permitted only if CREDUI_FLAGS_GENERIC_CREDENTIALS is also specified and is  used only in conjunction with CREDUI_FLAGS_GENERIC_CREDENTIALS.   CREDUI_FLAGS_DO_NOT_PERSIST    Do not display the save message or store credentials. CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX can also be passed to display the save message only and return the result in pfSave.   CREDUI_FLAGS_EXCLUDE_CERTIFICATES    Prompt for user name/password. If the pszUserName parameter is specified, the user name is omitted. If the credential is persisted, store the passed-in user name with the credential.   CREDUI_FLAGS_EXPECT_CONFIRMATION    Specifies that the caller will call  CredUIConfirmCredentials to determine whether the returned credentials are actually valid. This ensures that credentials that are not valid are not saved to the credential manager. Specify this flag unless CREDUI_FLAGS_DO_NOT_PERSIST is specified.   CREDUI_FLAGS_GENERIC_CREDENTIALS    Consider the credentials entered by the user a generic credential.   CREDUI_FLAGS_INCORRECT_PASSWORD    Silently ignore this flag.   CREDUI_FLAGS_PERSIST    Do not show the save message, but save the credential as though the user answered \"y\".   CREDUI_FLAGS_REQUEST_ADMINISTRATOR    Silently ignore this flag.   CREDUI_FLAGS_REQUIRE_CERTIFICATE    Reserved for future use; do not pass this flag.   CREDUI_FLAGS_REQUIRE_SMARTCARD    Use a smart card and prompt for a PIN. If more than one smart card is available, select one of them. If the pszUserName parameter passes a string that is not empty, the string must match the UPN associated with the certificate on one of the smart cards. A UPN matches if the string matches the whole UPN on the certificate or the string matches the part to the left of the at sign (@) in the UPN of the certificate. If there is a match, the matching smart card is selected.   CREDUI_FLAGS_SERVER_CREDENTIAL    This flag is meaningful only in locating a matching credential to prefill the dialog box, should authentication fail.  When this flag is specified, wildcard credentials will not be matched. It has no effect when writing a credential. CredUI does not create credentials that contain wildcard characters.  Any found were either created explicitly by the user or created programmatically, as happens when a RAS connection is made.   CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX    Display the save message and return TRUE in the pfSave out parameter if the user answers \"y\", FALSE if the user answers \"n\". CREDUI_FLAGS_DO_NOT_PERSIST must be specified to use this flag.   CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS    The credential is a run-as credential. The pszTargetName parameter specifies the name of the command or program being run. It is used for prompting purposes only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CredUIConfirmCredentials function is called after  CredUIPromptForCredentials or  CredUICmdLinePromptForCredentials, to confirm the validity of the credential harvested. CredUIConfirmCredentials must be called if the CREDUI_FLAGS_EXPECT_CONFIRMATION flag was passed to the \"prompt\" function, either CredUIPromptForCredentials or CredUICmdLinePromptForCredentials, and the \"prompt\" function returned NO_ERROR.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "Status of the operation is returned. The caller can check this status to determine whether the credential confirm operation succeeded. Most applications ignore this status code because the application's connection to the resource has already been done. The operation can fail because the credential was not found on the list of credentials awaiting confirmation, or because the attempt to write or delete the credential failed. Failure to find the credential on the list can occur because the credential was never queued or as a result of too many credentials being queued. Up to five credentials can be queued before older ones are discarded as newer ones are queued.  ",
    "remarks": "",
    "return_type": "DWORD WINAPI",
    "category": "Authentication",
    "name": "CredUIConfirmCredentials",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pszTargetName",
        "description": "Pointer to a null-terminated string that contains the name of the target for the credentials, typically a domain or server application name. This must be the same value passed as pszTargetName to CredUIPromptForCredentials or CredUICmdLinePromptForCredentials"
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bConfirm",
        "description": "Specifies whether the credentials returned from the prompt function are valid. If TRUE, the credentials are stored in the credential manager as defined by CredUIPromptForCredentials or CredUICmdLinePromptForCredentials. If FALSE, the credentials are not stored and various pieces of memory are cleaned up."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 10,
    "description": "The CredUIPromptForCredentials function creates and displays a configurable dialog box that accepts credentials information from a user.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The return value is a DWORD and can be one of the following values.  ",
    "remarks": "The CredUIPromptForCredentials function creates and displays an application modal dialog box. After the dialog box is displayed and until it is closed by the user or application, no other window in the application can become active. The flags CREDUI_FLAGS_REQUIRE_SMARTCARD, CREDUI_FLAGS_REQUIRE_CERTIFICATE, and CREDUI_FLAGS_EXCLUDE_CERTIFICATE are mutually exclusive. If CREDUI_FLAGS_DO_NOT_PERSIST is specified, either pszTargetName must be specified or uiInfo->pszMessageText and uiInfo->pszCaption must be specified. The flags CREDUI_FLAG_USERNAME_TARGET_CREDENTIALS and CREDUI_FLAGS_GENERIC_CREDENTIALS are mutually exclusive. If neither is specified, the credential is a domain credential. An X509 certificate must have an enhanced key usage (EKU) value of szOID_KP_SMARTCARD_LOGON (1.3.6.1.4.1.311.20.2.2) to be displayed. Windows XP:  This EKU value is not required to display X509 certificates. If CREDUI_FLAGS_GENERIC_CREDENTIALS is not specified or CREDUI_FLAGS_COMPLETE_USERNAME is specified, the typed name is syntax checked. Syntax checking applies the same rules as applied by CredUIParseUserName. If the typed name is not valid, the user is prompted for a valid one. If the domain portion of the typed name is missing, one will be supplied based on the target name. If CREDUI_FLAGS_GENERIC_CREDENTIALS is specified and CREDUI_FLAGS_VALIDATE_USERNAME is also specified, the typed name is syntax checked. If the typed name is not valid, the user is prompted for a valid one. If CREDUI_FLAGS_GENERIC_CREDENTIALS is specified and neither CREDUI_FLAGS_COMPLETE_USERNAME nor CREDUI_FLAGS_VALIDATE_USERNAME is specified, the typed name is not syntax checked in any way. If neither CREDUI_FLAGS_PERSIST nor CREDUI_FLAGS_DO_NOT_PERSIST is set, the Save check box is shown, and it controls whether the credential is saved. Calling Modes Target Information Target Information is  information about the location of the resource to be accessed. For a list of all potential target names for a resource, call  CredGetTargetInfo. CredGetTargetInfo returns information that was cached by the Negotiate, NTLM, or Kerberos authentication package when one of those packages was used to authenticate to the named target. CredGetTargetInfo returns some or all of the following names for the target: Any piece of this information can be missing if the information does not apply to the target computer. For instance, a computer that is a member of a workgroup does not have a NetBIOS domain name. Credentials are stored in the credential manager based on target name. Each target name is stored as generally as possible without colliding with credentials already stored in the credential manager. Because credentials are stored by target name, a particular user can only have one credential per target stored in the credential manager. ",
    "return_type": "DWORD WINAPI",
    "category": "Authentication",
    "name": "CredUIPromptForCredentials",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PCREDUI_INFO",
        "name": "pUiInfo",
        "description": "A pointer to a CREDUI_INFO structure that contains information for customizing the appearance of the dialog box."
      },
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pszTargetName",
        "description": "A pointer to a null-terminated string that contains  the name of the target for the credentials, typically a server name. For Distributed File System (DFS) connections, this string is of the form ServerName\\ShareName. This parameter is used to identify target information when storing and retrieving credentials."
      },
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "Reserved",
        "description": "This parameter is reserved for future use. It must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "dwAuthError",
        "description": "Specifies why the credential dialog box is needed. A caller can pass this Windows error parameter, returned by another authentication call, to allow the dialog box to accommodate certain errors. For example, if the password expired status code is passed, the dialog box could prompt the user to change the password on the account."
      },
      {
        "in_out": "_Inout_",
        "type": "PCTSTR",
        "name": "pszUserName",
        "description": "A pointer to a null-terminated string that contains the user name for the credentials. If a nonzero-length string is passed, the UserName option of the dialog box is prefilled with the string. In the case of credentials other than UserName/Password, a marshaled format of the credential can be passed in. This string is created by calling  CredMarshalCredential. This function copies the user-supplied name to this buffer, copying a maximum of ulUserNameMaxChars characters. This format can be converted to UserName/Password format by using  CredUIParseUsername. A marshaled format can be passed directly to a security support provider (SSP). If the CREDUI_FLAGS_DO_NOT_PERSIST flag is not specified, the value returned in this parameter is of a form that should not be inspected, printed, or persisted other than passing it to CredUIParseUsername. The subsequent results of CredUIParseUsername can  be passed only to a client-side authentication function such as WNetAddConnection or an SSP function. If no domain or server is specified as part of this parameter, the value of the  pszTargetName parameter is used as the domain to form a DomainName\\UserName pair. On output, this parameter receives a string that contains that DomainName\\UserName pair."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulUserNameMaxChars",
        "description": "The maximum number of characters that can be copied to pszUserName including the terminating null character. Note  CREDUI_MAX_USERNAME_LENGTH does not include the terminating null character."
      },
      {
        "in_out": "_Inout_",
        "type": "PCTSTR",
        "name": "pszPassword",
        "description": "A pointer to a null-terminated string that contains the password for the credentials. If a nonzero-length string is specified for pszPassword, the password option of the dialog box will be prefilled with the string. This function copies the user-supplied password to this buffer, copying a maximum of ulPasswordMaxChars characters. If the CREDUI_FLAGS_DO_NOT_PERSIST flag is not specified, the value returned in this parameter is of a form that should not be inspected, printed, or persisted other than passing it to a client-side authentication function such as WNetAddConnection or an SSP function. When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulPasswordMaxChars",
        "description": "The maximum number of characters that can be copied to pszPassword including the terminating null character. Note  CREDUI_MAX_PASSWORD_LENGTH does not include the terminating null character."
      },
      {
        "in_out": "_Inout_",
        "type": "PBOOL",
        "name": "pfSave",
        "description": "A pointer to a BOOL that specifies the initial state of the Save check box and receives the state of the Save check box after the user has responded to the dialog box. If this value is not NULL  and CredUIPromptForCredentials returns NO_ERROR, then pfSave returns the state of the Save check box when the user chose OK in the dialog box. If the CREDUI_FLAGS_PERSIST flag is specified, the Save check box is not displayed, but is considered to be selected. If the CREDUI_FLAGS_DO_NOT_PERSIST flag is specified and CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX is not specified, the Save check box is not displayed, but is considered to be cleared. An application that needs to use CredUI to prompt the user for credentials, but does not need the credential management services provided by the credential manager, can use pfSave to receive the state of the Save check box after the user closes the dialog box. To do this, the caller must specify CREDUI_FLAGS_DO_NOT_PERSIST and  CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX in dwFlags. When CREDUI_FLAGS_DO_NOT_PERSIST and  CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX are set, the application is responsible for examining *pfSave after the function returns, and if *pfSave is TRUE,  then the application must take the appropriate action to save the user credentials within the resources of the application."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A DWORD value that specifies special behavior for this function. This value can be a bitwise-OR combination of zero or more of the following values. \t\t\t\t\t  ValueMeaning  CREDUI_FLAGS_ALWAYS_SHOW_UI 0x00080   Specifies that a user interface will be shown even if the credentials can be returned from an existing credential in credential manager. This flag is  permitted only if CREDUI_FLAGS_GENERIC_CREDENTIALS is also specified.   CREDUI_FLAGS_COMPLETE_USERNAME 0x00800   Populate the combo box with the prompt for a user name.   CREDUI_FLAGS_DO_NOT_PERSIST 0x00002   Do not store credentials or display check boxes. You can pass CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX with this flag to display the Save check box only, and the result is returned in the pfSave output parameter.   CREDUI_FLAGS_EXCLUDE_CERTIFICATES 0x00008   Populate the combo box with user name/password only. Do not display certificates or smart cards in the combo box.   CREDUI_FLAGS_EXPECT_CONFIRMATION 0x20000   Specifies that the caller will call CredUIConfirmCredentials after checking to determine whether the returned credentials are actually valid. This mechanism ensures that credentials that are not valid are not saved to the credential manager. Specify this flag in all cases unless CREDUI_FLAGS_DO_NOT_PERSIST is specified.   CREDUI_FLAGS_GENERIC_CREDENTIALS 0x40000   Consider the credentials entered by the user to be generic credentials.   CREDUI_FLAGS_INCORRECT_PASSWORD 0x00001   Notify the user of insufficient credentials by displaying the \"Logon unsuccessful\" balloon tip.   CREDUI_FLAGS_KEEP_USERNAME 0x100000   Do not allow the user to change the supplied user name.   CREDUI_FLAGS_PASSWORD_ONLY_OK 0x00200   Populate the combo box with the password only. Do not allow a user name to be entered.   CREDUI_FLAGS_PERSIST 0x01000   Do not show the Save check box, but the credential is saved as though the box were shown and selected.   CREDUI_FLAGS_REQUEST_ADMINISTRATOR 0x00004   Populate the combo box with local administrators only.Windows XP Home Edition:  This flag will filter out the well-known Administrator account.   CREDUI_FLAGS_REQUIRE_CERTIFICATE 0x00010   Populate the combo box with certificates and smart cards only. Do not allow a user name to be entered.   CREDUI_FLAGS_REQUIRE_SMARTCARD 0x00100   Populate the combo box with certificates or smart cards only. Do not allow a user name to be entered.   CREDUI_FLAGS_SERVER_CREDENTIAL )X04000   This flag is meaningful only in locating a matching credential to prefill the dialog box, should authentication fail.  When this flag is specified, wildcard credentials will not be matched. It has no effect when writing a credential. CredUI does not create credentials that contain wildcard characters.  Any found were either created explicitly by the user or created programmatically, as happens when a RAS connection is made.   CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX 0x00040   If the check box is selected, show the Save check box and return TRUE in the pfSave output parameter, otherwise, return FALSE. Check box uses the value in pfSave by default.   CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS 0x80000   The credential is a \"runas\" credential. The TargetName parameter specifies the name of the command or program being run. It is used for prompting purposes only.   CREDUI_FLAGS_VALIDATE_USERNAME 0x00400   Check that the user name is valid."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The CredUIParseUserName function extracts the domain and user account name from a fully qualified user name.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "This function returns the following: ",
    "remarks": "This function parses the user name information returned by the  CredUIPromptForCredentials and  CredUICmdLinePromptForCredentials functions so that the resulting credentials can be passed to functions, such as LogonUser, that require the user name and domain as separate strings. The following formats are supported: ",
    "return_type": "DWORD WINAPI",
    "category": "Authentication",
    "name": "CredUIParseUserName",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pszUserName",
        "description": "Pointer to a null-terminated string that contains the user name to be parsed. The name must be in UPN or down-level format, or a certificate. Typically, pszUserName is received from the  CredUIPromptForCredentials or  CredUICmdLinePromptForCredentials."
      },
      {
        "in_out": "_Out_",
        "type": "PTSTR",
        "name": "pszUser",
        "description": "Pointer to a null-terminated string that receives the user account name."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulUserMaxChars",
        "description": "Maximum number of characters to write to the pszUser string including the terminating null character.     Note  CREDUI_MAX_USERNAME_LENGTH does NOT include the terminating null character."
      },
      {
        "in_out": "_Out_",
        "type": "PTSTR",
        "name": "pszDomain",
        "description": "Pointer to a null-terminated string that receives the domain name. If pszUserName specifies a certificate, pszDomain will be NULL."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulDomainMaxChars",
        "description": "Maximum number of characters to write to the pszDomain string including the terminating null character.     Note  CREDUI_MAX_DOMAIN_TARGET_LENGTH does NOT include the terminating null character."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The CredUIPromptForWindowsCredentials function creates and displays a configurable dialog box that allows users to supply credential information by using any credential provider installed on the local computer.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "If the function succeeds, the function returns ERROR_SUCCESS. If the function is canceled by the user, it returns ERROR_CANCELLED. Any other return value indicates that the function failed to load. ",
    "remarks": "This function does not save credentials. Applications that use SSPI to authenticate users should not call this function. Instead, call SspiPromptForCredentials. ",
    "return_type": "DWORD WINAPI",
    "category": "Authentication",
    "name": "CredUIPromptForWindowsCredentials",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PCREDUI_INFO",
        "name": "pUiInfo",
        "description": "A pointer to a CREDUI_INFO structure that contains information for customizing the appearance of the dialog box that this function displays.       If the hwndParent member of the CREDUI_INFO structure is not NULL, this function displays a modal dialog box centered on the parent window. If the hwndParent member of the CREDUI_INFO structure is NULL, the function displays a dialog box centered on the screen. This function ignores the  hbmBanner member of the CREDUI_INFO structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAuthError",
        "description": "A Windows error code, defined in Winerror.h, that is displayed in the dialog box. If credentials previously collected were not valid, the caller uses this parameter to pass the error message from the API that collected the credentials (for example, Winlogon) to this function. The corresponding error message is formatted and displayed in the dialog box. Set the  value of this parameter to zero to display no error message."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG",
        "name": "*pulAuthPackage",
        "description": "On input, the value of this parameter is used to specify the authentication package for which the credentials in the pvInAuthBuffer buffer are serialized. If the value of pvInAuthBuffer is NULL and the CREDUIWIN_AUTHPACKAGE_ONLY flag is set in the dwFlags parameter, only credential providers capable of serializing credentials for the specified authentication package are to be enumerated.    To get the appropriate value to use for this parameter on input, call the LsaLookupAuthenticationPackage function and use the value of the AuthenticationPackage parameter  of that function. On output, this parameter specifies the authentication package for which the credentials in the ppvOutAuthBuffer buffer are serialized."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCVOID",
        "name": "pvInAuthBuffer",
        "description": "A pointer to a credential BLOB that is used to populate the credential fields in the dialog box. Set the value of this parameter to NULL to leave the credential fields empty."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulInAuthBufferSize",
        "description": "The size, in bytes, of the pvInAuthBuffer buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "*ppvOutAuthBuffer",
        "description": "The address of a pointer that, on output, specifies the credential BLOB. For Kerberos, NTLM, or Negotiate credentials, call the CredUnPackAuthenticationBuffer function to convert this BLOB to string representations of the credentials.   When you have finished using the credential BLOB, clear it from memory by calling the SecureZeroMemory function, and free it by calling the CoTaskMemFree function."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG",
        "name": "*pulOutAuthBufferSize",
        "description": "The size, in bytes, of the ppvOutAuthBuffer buffer."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "BOOL",
        "name": "*pfSave",
        "description": "A pointer to a Boolean value that, on input, specifies whether the Save check box is selected in the dialog box that this function displays. On output, the value of this parameter specifies whether the Save check box was selected when the user clicks the Submit button in the dialog box. Set this parameter to NULL to ignore the Save check box. This parameter is ignored if the CREDUIWIN_CHECKBOX flag is not set in the dwFlags parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A value that specifies behavior for this function. This value can be a bitwise-OR combination of one or more of the following values.  ValueMeaning  CREDUIWIN_GENERIC 0x1   The caller is requesting that the credential provider return the user name and password in plain text. This value cannot be combined with SECURE_PROMPT.   CREDUIWIN_CHECKBOX 0x2   The Save check box is displayed in the dialog box.   CREDUIWIN_AUTHPACKAGE_ONLY 0x10   Only credential providers that support the authentication package specified by the pulAuthPackage parameter should be enumerated. This value cannot be combined with CREDUIWIN_IN_CRED_ONLY.   CREDUIWIN_IN_CRED_ONLY 0x20   Only the credentials specified by the pvInAuthBuffer parameter for the authentication package specified by the pulAuthPackage parameter should be enumerated. If this flag is set, and the pvInAuthBuffer parameter is NULL, the function fails. This value cannot be combined with CREDUIWIN_AUTHPACKAGE_ONLY.   CREDUIWIN_ENUMERATE_ADMINS 0x100   Credential providers should enumerate only administrators. This value is intended for User Account Control (UAC) purposes only. We recommend that external callers not set this flag.   CREDUIWIN_ENUMERATE_CURRENT_USER 0x200   Only the incoming credentials for the authentication package specified by the pulAuthPackage parameter should be enumerated.   CREDUIWIN_SECURE_PROMPT 0x1000   The credential dialog box should be displayed on the secure desktop. This value cannot be combined with CREDUIWIN_GENERIC. Windows Vista:  This value is supported beginning with Windows Vista with SP1.   CREDUIWIN_PREPROMPTING 0x2000   The credential dialog box is invoked by the SspiPromptForCredentials function, and the client is prompted before a prior handshake. If SSPIPFC_NO_CHECKBOX is passed in the pvInAuthBuffer parameter, then the credential provider should not display the check box. Windows Vista:  This value is supported beginning with Windows Vista with SP1.   CREDUIWIN_PACK_32_WOW 0x10000000   The credential provider should align the credential BLOB pointed to by the ppvOutAuthBuffer parameter to a 32-bit boundary, even if the provider is running on a 64-bit system."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CredUIReadSSOCredW function retrieves the user name for a single logon credential.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The return value is a DWORD. The following table lists the possible values.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "CredUIReadSSOCredW",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszRealm",
        "description": "Pointer to a null-terminated string that specifies the realm. If this parameter is NULL, the default realm is used."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR",
        "name": "*ppszUsername",
        "description": "Pointer to a pointer to a null-terminated string. When you have finished using the string, free ppszUsername by calling the  LocalFree function."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CredUIStoreSSOCredW function stores a single logon credential.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The return value is a DWORD. A return value of ERROR_SUCCESS indicates the function was successful. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "CredUIStoreSSOCredW",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszRealm",
        "description": "Pointer to a null-terminated string that specifies the realm. If this parameter is NULL, the default realm is used."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszUsername",
        "description": "Pointer to a null-terminated string that specifies the user's name."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszPassword",
        "description": "Pointer to a null-terminated string that specifies the user's password. When you have finished using the password, clear the password from memory by calling the SecureZeroMemory function. For more information about protecting passwords, see Handling Passwords."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bPersist",
        "description": "Boolean value that specifies whether the credentials are persisted. If this value is TRUE, the credentials are persisted. If this value is FALSE, the credentials are not persisted."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CredDelete function deletes a credential from the user's credential set. The credential set used is the one associated with the logon session of the current token. The token must not have the user's SID disabled.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status codes can be returned: ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredDelete",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "TargetName",
        "description": "Pointer to a null-terminated string that contains the name of the credential to delete."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Type",
        "description": "Type of the credential to delete. Must be one of the CRED_TYPE_* defined types. For a list of the defined types, see the Type member of the CREDENTIAL structure. If the value of this parameter is CRED_TYPE_DOMAIN_EXTENDED, this function can delete a credential that specifies a user name when there are multiple credentials for the same target. The value of the TargetName parameter must specify the user name as Target|UserName."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Reserved and must be zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CredEnumerate function enumerates the credentials from the user's credential set. The credential set used is the one associated with the logon session of the current token. The token must not have the user's SID disabled.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status codes can be returned.  ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredEnumerate",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "Filter",
        "description": "Pointer to a null-terminated string that contains the filter for the returned credentials. Only credentials with a TargetName matching the filter will be returned. The filter specifies a name prefix followed by an asterisk. For instance, the filter \"FRED*\" will return all credentials with a TargetName beginning with the string \"FRED\".  If NULL is specified, all credentials will be returned."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "The value of this parameter can be zero or more of the following values combined with a bitwise-OR operation.  ValueMeaning  CRED_ENUMERATE_ALL_CREDENTIALS 0x1   This function enumerates all of the credentials in the user's credential set. The target name of each credential is returned in the \"namespace:attribute=target\" format. If this flag is set and the Filter parameter is not NULL, the function fails and returns ERROR_INVALID_FLAGS. Windows Server 2003 and Windows XP:  This flag is not supported."
      },
      {
        "in_out": "_Out_",
        "type": "DWORD",
        "name": "*Count",
        "description": "Count of the credentials returned in the Credentials array."
      },
      {
        "in_out": "_Out_",
        "type": "PCREDENTIAL",
        "name": "**Credentials",
        "description": "Pointer to an array of pointers to credentials. The returned credential is a single allocated block. Any pointers contained within the buffer are pointers to locations within this single allocated block. The single returned buffer must be freed by calling CredFree."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CredFindBestCredential function searches the Credentials Management (CredMan) database for the set of generic credentials that are associated with the current logon session and that best match the specified target resource.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "CredFindBestCredential",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "TargetName",
        "description": "A pointer to a null-terminated string that contains the name of the target resource for which to find credentials."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Type",
        "description": "The type of credentials to search for. Currently, this function supports only CRED_TYPE_GENERIC."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Reserved."
      },
      {
        "in_out": "_Out_",
        "type": "PCREDENTIAL",
        "name": "*Credential",
        "description": "The address of a pointer to a CREDENTIAL structure that specifies the set of credentials this function finds. When you have finished using this structure, free it by calling the CredFree function."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CredFree function frees a buffer returned by any of the credentials management functions.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "CredFree",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to the buffer to be freed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CredGetSessionTypes function returns the maximum persistence supported by the current logon session. A separate maximum persistence is returned for each credential type.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "This function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status code can be returned: ERROR_NO_SUCH_LOGON_SESSION The logon session does not exist or there is no credential set associated with this logon session. Network logon sessions do not have an associated credential set. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredGetSessionTypes",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "MaximumPersistCount",
        "description": "Number of elements in the MaximumPersist array. Use CRED_TYPE_MAXIMUM to return all of the currently defined credential types."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "MaximumPersist",
        "description": "Pointer to an array to return the persistence values in. The passed in array should be MaximumPersistCount elements long. On return, each element specifies the maximum persistence supported by the corresponding credential type. The caller should use one of the following defines to index into the array:  CRED_TYPE_GENERIC CRED_TYPE_DOMAIN_PASSWORD CRED_TYPE_DOMAIN_CERTIFICATE  That is, MaximumPersist[CRED_TYPE_GENERIC] specifies the maximum persistence supported for generic credentials.   The following values can be returned in each element of the array.  ValueMeaning  CRED_PERSIST_NONE   No credential can be stored. This value will be returned if the credential type is not supported or has been disabled by policy.   CRED_PERSIST_SESSION   Only a session-specific credential can be stored.   CRED_PERSIST_LOCAL_MACHINE   Session-specific and computer-specific credentials can be stored.  Windows XP:  This credential cannot be stored for sessions in which the profile is not loaded.   CRED_PERSIST_ENTERPRISE   Any credential can be stored.  Windows XP:  This credential cannot be stored for sessions in which the profile is not loaded."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CredGetTargetInfo function retrieves all known target name information for the named target computer. This executed locally and does not need any particular privilege. The information returned is expected to be passed to the  CredReadDomainCredentials and  CredWriteDomainCredentials functions. The information should not be used for any other purpose.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status code can be returned: ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredGetTargetInfo",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "TargetName",
        "description": "Pointer to a null-terminated string that contains the name of the target computer for which information is to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Flags controlling the operation of the function. The following flag can be used:     CRED_ALLOW_NAME_RESOLUTION If no target information can be found for TargetName name resolution is done on TargetName to convert it to other forms. If target information exists for any of those other forms, it is returned. Currently only DNS name resolution is done. This is useful if the application does not call an authentication package directly. The application can pass the TargetName to another layer of software to authenticate to the server, and that layer of software might resolve the name and pass the resolved name to the authentication package. As such, there will be no target information for the original TargetName."
      },
      {
        "in_out": "_Out_",
        "type": "PCREDENTIAL_TARGET_INFORMATION",
        "name": "*TargetInfo",
        "description": "Pointer to a single allocated block buffer to contain the target information. At least one of the returned members of TargetInfo will be non-NULL. Any pointers contained within the buffer are pointers to locations within this single allocated block. The single returned buffer must be freed by calling CredFree."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CredIsMarshaledCredential function determines whether a specified user name string is a marshaled credential previously marshaled by  CredMarshalCredential.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "This function returns TRUE if MarshaledCredential is a marshaled credential and FALSE if it is not. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredIsMarshaledCredential",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "MarshaledCredential",
        "description": "Pointer to a null-terminated string that contains the marshaled credential."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CredMarshalCredential function transforms a credential into a text string. Historically, many functions, such as NetUseAdd, take a domain name, user name, and password as credentials. These functions do not accept certificates as credentials. The CredMarshalCredential function converts such credentials into a form that can be passed into these APIs.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "This function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status code can be returned: ERROR_INVALID_PARAMETER CredType is not valid. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredMarshalCredential",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CRED_MARSHAL_TYPE",
        "name": "CredType",
        "description": "Type of the credential to marshal."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Credential",
        "description": "Credential to marshal.    This is one of the CRED_MARSHAL_TYPE values. If CredType is CertCredential, Credential points to a CERT_CREDENTIAL_INFO structure. If CredType is UsernameTargetCredential, Credential points to a USERNAME_TARGET_CREDENTIAL_INFO structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "*MarshaledCredential",
        "description": "Pointer to a null-terminated  \t\t\t\t\t\tstring that contains the marshaled credential. The caller should free the returned buffer using CredFree."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CredIsProtected function specifies whether the specified credentials are encrypted by a previous call to the CredProtect function.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "TRUE if the function succeeds; otherwise, FALSE. For extended error information, call the  GetLastError function. ",
    "remarks": "",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "CredIsProtected",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszProtectedCredentials",
        "description": "A pointer to a null-terminated string that specifies the credentials to test."
      },
      {
        "in_out": "_Out_",
        "type": "CRED_PROTECTION_TYPE",
        "name": "*pProtectionType",
        "description": "A pointer to a value from the CRED_PROTECTION_TYPE enumeration that specifies whether the credentials specified in the pszProtectedCredentials parameter are protected."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The CredProtect function encrypts the specified credentials so that only the current security context can decrypt them.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "TRUE if the function succeeds; otherwise, FALSE. For extended error information, call the  GetLastError function. ",
    "remarks": "Note that the output of the CredProtect function is not integrity protected, so if the output is modified, the CredUnprotect function is not updated and may produce incorrect results. ",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "CredProtect",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fAsSelf",
        "description": "Set to TRUE to specify that the credentials are encrypted in the security context of the current process. Set to FALSE to specify that credentials are encrypted in the security context of the calling thread security context."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszCredentials",
        "description": "A pointer to a string that specifies the credentials to encrypt. The function encrypts the number of characters provided in the cchCredentials parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cchCredentials",
        "description": "The size, in characters, of the pszCredentials buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszProtectedCredentials",
        "description": "A pointer to a string that, on output, receives the encrypted credentials."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "*pcchMaxChars",
        "description": "The size, in characters of the pszProtectedCredentials buffer. On output, if the pszProtectedCredentials is not of sufficient size to receive the encrypted credentials, this parameter specifies the required size, in characters, of the pszProtectedCredentials buffer."
      },
      {
        "in_out": "_Out_",
        "type": "CRED_PROTECTION_TYPE",
        "name": "*ProtectionType",
        "description": "A pointer to a CRED_PROTECTION_TYPE enumeration type that, on output, specifies the type of protection provided."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The CredPackAuthenticationBuffer function converts a string user name and password into an authentication buffer.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "TRUE if the function succeeds; otherwise, FALSE. For extended error information, call the  GetLastError function, which may return the following error codes.  ",
    "remarks": "",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "CredPackAuthenticationBuffer",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Specifies how the credential should be packed. This can be a combination of the following flags.   ValueMeaning  CRED_PACK_PROTECTED_CREDENTIALS   Encrypts the credential so that it can only be decrypted by processes in the caller's logon session.   CRED_PACK_WOW_BUFFER   Encrypts the credential in a WOW buffer.   CRED_PACK_GENERIC_CREDENTIALS   Encrypts the credential in a CRED_GENERIC buffer.   CRED_PACK_ID_PROVIDER_CREDENTIALS    Encrypts the credential of an online identity into a SEC_WINNT_AUTH_IDENTITY_EX2 structure.  If CRED_PACK_GENERIC_CREDENTIALS and CRED_PACK_ID_PROVIDER_CREDENTIALS are not set, encrypts the credentials in a KERB_INTERACTIVE_LOGON buffer. Windows 7, Windows Server 2008 R2, Windows Vista, Windows Server 2008:  This value is not supported."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszUserName",
        "description": "A pointer to a null-terminated string that specifies the user name to be converted. For domain users, the string must be in the following format: DomainName\\UserName For online identities, if the credential is a plaintext password, the user name format is ProviderName\\UserName. If the credential is a SEC_WINNT_AUTH_IDENTITY_EX2 structure, the user name is an encoded string that is the UserName parameter output of a function call to SspiEncodeAuthIdentityAsStrings. For smart card or certificate credentials, the user name is an encoded string that is the output of a function call to CredMarshalCredential with the CertCredential option. Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  Online identities are not supported."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszPassword",
        "description": "A pointer to a null-terminated string that specifies the password to be converted. For SEC_WINNT_AUTH_IDENTITY_EX2 credentials, the password is an encoded string that is in the ppszPackedCredentialsString output of a function call to SspiEncodeAuthIdentityAsStrings. For smart card  credentials, this is the smart card PIN. Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  Online identities are not supported."
      },
      {
        "in_out": "_Out_",
        "type": "PBYTE",
        "name": "pPackedCredentials",
        "description": "A pointer to an array of bytes that, on output, receives the packed authentication buffer. This parameter can be NULL to receive the required buffer size in the pcbPackedCredentials parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "*pcbPackedCredentials",
        "description": "A pointer to a DWORD value that specifies the size, in bytes, of the pPackedCredentials buffer. On output, if the buffer is not of sufficient size, specifies the required size, in bytes, of the  pPackedCredentials buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CredRead function reads a credential from the user's credential set. The credential set used is the one associated with the logon session of the current token. The token must not have the user's SID disabled.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status codes can be returned: ",
    "remarks": "If the value of the Type member of the CREDENTIAL structure specified by the Credential  parameter is CRED_TYPE_DOMAIN_EXTENDED, a namespace must be specified in the target name. This function can return only one credential of the specified type. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredRead",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "TargetName",
        "description": "Pointer to a null-terminated string that contains the name of the credential to read."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Type",
        "description": "Type of the credential to read. Type must be one of the CRED_TYPE_* defined types."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Currently reserved and must be zero."
      },
      {
        "in_out": "_Out_",
        "type": "PCREDENTIAL",
        "name": "*Credential",
        "description": "Pointer to a single allocated block buffer to return the credential. Any pointers contained within the buffer are pointers to locations within this single allocated block. The single returned buffer must be freed by calling CredFree."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CredReadDomainCredentials function reads the domain credentials from the user's credential set. The credential set used is the one associated with the logon session of the current token. The token must not have the user's SID disabled.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status codes can be returned: ",
    "remarks": "This function returns the most specific credentials matching the naming parameters. For instance, if there is a credential that matches the target server name and a credential that matches the target domain name, only the server specific credential is returned. This is the credential that would be used. The following list specifies the order (from most specific to least specific) of what credential is returned if more than one matches: CredReadDomainCredentials differs from CredRead in that it handles the idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE) credentials. Domain credentials contain more than one target member. If the value of the Type member of the CREDENTIAL structure specified by the Credentials  parameter is CRED_TYPE_DOMAIN_EXTENDED, a namespace must be specified in the target name. This function can return only one credential of the specified type. This function can return multiple credentials of this type, but CRED_TYPE_DOMAIN_EXTENDED cannot be mixed with other types in the CredTypes member of the CREDENTIAL_TARGET_INFORMATION structure specified by the TargetInfo parameter. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredReadDomainCredentials",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCREDENTIAL_TARGET_INFORMATION",
        "name": "TargetInfo",
        "description": "Target information that identifies the target server. At least one of the naming members must not be NULL: NetbiosServerName, DnsServerName, NetbiosDomainName, DnsDomainName or DnsTreeName."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Flags controlling the operation of the function.     The following flag is defined: CRED_CACHE_TARGET_INFORMATION Cache the TargetInfo for a subsequent read using CredGetTargetInfo."
      },
      {
        "in_out": "_Out_",
        "type": "DWORD",
        "name": "*Count",
        "description": "Count of the credentials returned in the Credentials array."
      },
      {
        "in_out": "_Out_",
        "type": "PCREDENTIAL",
        "name": "**Credentials",
        "description": "Pointer to an array of pointers to credentials. The most specific existing credential matching the TargetInfo is returned. If credentials of various types (for example, CRED_TYPE_DOMAIN_PASSWORD and CRED_TYPE_DOMAIN_CERTIFICATE credentials) exist, one of each type is returned. If a connection were to be made to the named target, this most-specific credential would be used.     Only those credential types specified by the TargetInfo.CredTypes array are returned. The returned Credentials array is sorted in the same order as the TargetInfo.CredTypes array. That is, authentication packages specify a preferred credential type by specifying it earlier in the TargetInfo.CredTypes array.If TargetInfo.CredTypeCount is zero, the Credentials array is returned in the following sorted order:  CRED_TYPE_DOMAIN_CERTIFICATE CRED_TYPE_DOMAIN_PASSWORD  The returned buffer is a single allocated block. Any pointers contained within the buffer are pointers to locations within this single allocated block. The single returned buffer must be freed by calling CredFree."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[CredRename is no longer supported. Starting with Windows Vista, calls to CredRename always return ERROR_NOT_SUPPORTED.]",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "The function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status codes can be returned: ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredRename",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "OldTargetName",
        "description": "Pointer to a null-terminated string that contains the current name of the credential to be renamed."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "NewTargetName",
        "description": "Pointer to a null-terminated string that contains the new name for the credential."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Type",
        "description": "Type of the credential to rename. Must be one of the CRED_TYPE_* defines."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Flags to control the operation of the function. Currently reserved and must be zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CredUnmarshalCredential function transforms a marshaled credential back into its original form.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "This function returns TRUE on success and FALSE on failure. The GetLastError function can be called to get a more specific status code. The following status code can be returned: ERROR_INVALID_PARAMETER MarshaledCredential is not valid. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredUnmarshalCredential",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "MarshaledCredential",
        "description": "Pointer to a null-terminated string that contains the marshaled credential."
      },
      {
        "in_out": "_Out_",
        "type": "PCRED_MARSHAL_TYPE",
        "name": "CredType",
        "description": "Type of credential specified by MarshaledCredential.    This is one of the CRED_MARSHAL_TYPE values."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*Credential",
        "description": "Pointer to the unmarshaled credential. If CredType returns CertCredential, the returned pointer is to a CERT_CREDENTIAL_INFO structure. If CredType returns UsernameTargetCredential, the returned pointer is to a USERNAME_TARGET_CREDENTIAL_INFO structure. The caller should free the returned buffer using CredFree."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The CredUnPackAuthenticationBuffer function converts an authentication buffer returned by a call to the CredUIPromptForWindowsCredentials function into a string user name and password.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "TRUE if the function succeeds; otherwise, FALSE. For extended error information, call the  GetLastError function. The following table shows common values for the GetLastError function.  ",
    "remarks": "Beginning with  Windows 8 and Windows Server 2012, the authentication buffer can be a SEC_WINNT_AUTH_IDENTITY_EX2 structure, which can be optionally encrypted by using the SspiEncryptAuthIdentityEx function with the SEC_WINNT_AUTH_IDENTITY_ENCRYPT_SAME_LOGON option. This credential format is returned by a Credential Provider of an Identity Provider by using the CredUIPromptForWindowsCredentials or SspiPromptForCredentials function. This structure can also be constructed by using the CredPackAuthenticationBuffer function.  If the authentication buffer pAuthBuffer represents a nonpassword credential, such as KERB_CERTIFICATE_LOGON or SEC_WINNT_AUTH_IDENTITY_EX2, the function must marshal the credential as character strings, returned as user name, domain name, and password strings. The marshaling is done by using a specific procedure. When dwFlags contains the CRED_PACK_PROTECTED_CREDENTIALS flag, the caller must run in the same logon session in which the credential was encrypted. ",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "CredUnPackAuthenticationBuffer",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Setting the value of this parameter to CRED_PACK_PROTECTED_CREDENTIALS specifies that the function attempts to decrypt the credentials in the authentication buffer. If the credential  cannot be decrypted, the function returns FALSE, and a call to the GetLastError function will return the value ERROR_NOT_CAPABLE. How the decryption is done depends on the format of the authentication buffer. If the authentication buffer is a SEC_WINNT_AUTH_IDENTITY_EX2 structure, the function can decrypt the buffer if it is encrypted by using SspiEncryptAuthIdentityEx with the SEC_WINNT_AUTH_IDENTITY_ENCRYPT_SAME_LOGON option. If the authentication buffer is one of the marshaled KERB_*_LOGON structures, the function decrypts the password before returning it in the pszPassword buffer."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pAuthBuffer",
        "description": "A pointer to the authentication buffer to be converted. This buffer is typically the output of the CredUIPromptForWindowsCredentials or CredPackAuthenticationBuffer function. This must be one of the following types: A SEC_WINNT_AUTH_IDENTITY_EX2 structure for identity credentials. The function does not accept other SEC_WINNT_AUTH_IDENTITY structures. A KERB_INTERACTIVE_LOGON or KERB_INTERACTIVE_UNLOCK_LOGON  structure for password credentials. A KERB_CERTIFICATE_LOGON or KERB_CERTIFICATE_UNLOCK_LOGON  structure for smart card certificate credentials. GENERIC_CRED for generic credentials."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbAuthBuffer",
        "description": "The size, in bytes, of the pAuthBuffer buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszUserName",
        "description": "A pointer to a null-terminated string that receives the user name. This string can be a marshaled credential. See Remarks."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "*pcchMaxUserName",
        "description": "A pointer to a DWORD value that specifies the size, in characters, of the pszUserName buffer. On output, if the buffer is not of sufficient size, specifies the required size, in characters, of the  pszUserName buffer. The size includes terminating null character."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszDomainName",
        "description": "A pointer to a null-terminated string that receives the name of the user's domain."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "*pcchMaxDomainname",
        "description": "A pointer to a DWORD value that specifies the size, in characters, of the pszDomainName buffer. On output, if the buffer is not of sufficient size, specifies the required size, in characters, of the  pszDomainName buffer. The size includes the terminating null character. The required size can be zero if there is no domain name."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszPassword",
        "description": "A pointer to a null-terminated string that receives the password."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "*pcchMaxPassword",
        "description": "A pointer to a DWORD value that specifies the size, in characters, of the pszPassword buffer. On output, if the buffer is not of sufficient size, specifies the required size, in characters, of the  pszPassword buffer. The size includes the terminating null character.   This string can be a marshaled credential. See Remarks."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The CredUnprotect function decrypts credentials that were previously encrypted by using the CredProtect function. The credentials must have been encrypted in the same security context in which CredUnprotect is called.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "TRUE if the function succeeds; otherwise, FALSE. For extended error information, call the  GetLastError function. The following table shows common values for the GetLastError function.  ",
    "remarks": "",
    "return_type": "BOOL WINAPI",
    "category": "Authentication",
    "name": "CredUnprotect",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fAsSelf",
        "description": "Set to TRUE to specify that the credentials were encrypted in the security context of the current process. Set to FALSE to specify that credentials were encrypted in the security context of the calling thread security context."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszProtectedCredentials",
        "description": "A pointer to a string that specifies the encrypted credentials."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cchCredentials",
        "description": "The size, in characters, of the pszProtectedCredentials buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszCredentials",
        "description": "A pointer to a string that, on output, receives the decrypted credentials."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "*pcchMaxChars",
        "description": "The size, in characters of the pszCredentials buffer. On output, if the pszCredentials is not of sufficient size to receive the encrypted credentials, this parameter specifies the required size, in characters, of the pszCredentials buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CredWrite function creates a new credential or modifies an existing credential in the user's credential set. The new credential is associated with the logon session of the current token. The token must not have the user's security identifier (SID) disabled.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "If the function succeeds, the function returns TRUE. If the function fails, it returns FALSE. Call the GetLastError function to get a more specific status code. The following status codes can be returned. Other smart card errors can be returned when writing a CRED_TYPE_CERTIFICATE credential.  ",
    "remarks": "This function creates a credential if a credential with the specified TargetName and Type does not exist. If a credential with the specified TargetName and Type exists, the new specified credential replaces the existing one. When this function writes a CRED_TYPE_CERTIFICATE credential, the Credential->CredentialBlob member specifies the PIN protecting the private key of the certificate specified by the Credential->UserName member. The credential manager does not maintain the PIN. Rather, the PIN is passed to the cryptographic service provider (CSP) indicated on the certificate for later use by the CSP and the authentication packages. The CSP defines the lifetime of the PIN. Most CSPs flush the PIN when the smart card removal from the smart card reader. If the value of the Type member of the CREDENTIAL structure specified by the Credential  parameter is CRED_TYPE_DOMAIN_EXTENDED, a namespace must be specified in the target name. This function does not support writing to target names that contain wildcards. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredWrite",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCREDENTIAL",
        "name": "Credential",
        "description": "A pointer to the CREDENTIAL structure to be written."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Flags that control the function's operation. The following flag is defined.  ValueMeaning  CRED_PRESERVE_CREDENTIAL_BLOB    The credential BLOB from an existing credential is preserved with the same credential name and credential type. The CredentialBlobSize of the passed in Credential structure must be zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CredWriteDomainCredentials function writes domain credentials to the user's credential set. The credential set used is the one associated with the logon session of the current token. The token must not have the user's SID disabled.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "WinCred.h",
    "return_value": "If the function succeeds, the function returns TRUE. If the function fails, it returns FALSE. Call the GetLastError function to get a more specific status code. The following status codes can be returned. Other smart card errors can be returned when writing a CRED_TYPE_CERTIFICATE credential.  ",
    "remarks": "When this function writes a CRED_TYPE_CERTIFICATE credential, the Credential->CredentialBlob member specifies the PIN that protects the private key of the certificate specified by the Credential->UserName. The credential manager does not maintain the PIN. Rather, the PIN is passed to the CSP of the certificate for later use by the CSP and authentication packages. The CSP defines the lifetime of the PIN. For instance, most CSPs flush the PIN upon smart card removal. CredWriteDomainCredentials differs from CredWrite in that it handles the idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE) credentials. Domain credentials contain more than one target member. If the value of the Type member of the CREDENTIAL structure specified by the Credential  parameter is CRED_TYPE_DOMAIN_EXTENDED, a namespace must be specified in the target name. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "CredWriteDomainCredentials",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCREDENTIAL_TARGET_INFORMATION",
        "name": "TargetInfo",
        "description": "Identifies the target server. At least one of the naming members must be non-NULL and can be NetbiosServerName, DnsServerName, NetbiosDomainName, DnsDomainName, or DnsTreeName."
      },
      {
        "in_out": "_In_",
        "type": "PCREDENTIAL",
        "name": "Credential",
        "description": "Credential to be written.     The credential must be one that matches TargetInfo For instance, if the TargetName is a wildcard DNS name, then the TargetName member of the credential must be a postfix of the DnsServerName member from the TargetInfo."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "Flags to control the operation of the API. The following flag is defined.  ValueMeaning  CRED_PRESERVE_CREDENTIAL_BLOB    The credential BLOB should be preserved from the already existing credential with the same credential name and credential type. The CredentialBlobSize of the passed in Credential structure must be zero."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "MPR calls this function to notify the credential manager that a logon event has occurred, allowing the credential manager to return a logon script. The NPLogonNotify function is implemented by a credential manager DLL.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, the function returns WN_SUCCESS. If the function fails, it returns an error code, which can be one of the following.  ",
    "remarks": "The  NPLogonNotify function is implemented by credential managers to receive notifications when authentication information changes. Each credential manager is allowed to return a single command-line string that can be used to execute a logon script. The buffer of this string is allocated by the credential manager. MPR is responsible for freeing it. The string returned in lpLogonScript should contain all the information necessary to run the script as a command line passed to  CreateProcess. If the string requires the command processor to process the string, as in the case of commands or batch files, then the string should be prefixed with cmd /C. Logon scripts will be run in the user context when the user profile is available. However, environment variables that are set will not be global and will not be available to the initial shell (for example, Program Manager) or any other program run on behalf of the user. ",
    "return_type": "DWORD APIENTRY",
    "category": "Authentication",
    "name": "NPLogonNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLUID",
        "name": "lpLogon",
        "description": "Pointer to the identifier of the session that just logged on."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpAuthentInfoType",
        "description": "Pointer to a string that identifies the type of structure pointed to by lpAuthentInfo.     When Microsoft is the primary authenticator, one of the following strings is specified for interactive and service controller logons.       Copy     MSV1_0:Interactive Kerberos:Interactive"
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAuthentInfo",
        "description": "Pointer to a structure that contains the credentials used to successfully log the user on through the primary authenticator.     When Microsoft is the primary authenticator (that is, when lpAuthentifoType is \"MSV1_0:Interactive\" or \"Kerberos:Interactive\"), the structure used is  MSV1_0_INTERACTIVE_LOGON or  KERB_INTERACTIVE_LOGON."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpPreviousAuthentInfoType",
        "description": "Pointer to a string that identifies the type of structure pointed to by lpPreviousAuthentInfo. If the pointer is NULL, there was no previous information. The values that are expected here are the same as those in lpAuthentInfoType.     When Microsoft is the primary authenticator, the following string is specified for interactive and service controller logons.   C++     Copy      MSV1_0:Interactive"
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpPreviousAuthentInfo",
        "description": "Pointer to a structure that contains the credentials used before the authentication information change. Prior information is provided if the user was forced to change the password (or other authentication information) before logging on. If the user was not forced to change authentication information, this pointer is NULL. The values that are expected here are the same as those in lpAuthentInfo.     When Microsoft is the primary authenticator, the structure used is  MSV1_0_INTERACTIVE_LOGON or  KERB_INTERACTIVE_LOGON."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpStationName",
        "description": "Pointer to a string that specifies the name of the station that the user has logged on to. The station name may be used to determine whether additional (provider-specific) information can be obtained.     When Microsoft is the primary authenticator, one of the following strings will be specified.  ValueMeaning  WinSta_0   Indicates that this is an interactive logon through the window station. In this case, StationHandle is an HWND to the parent dialog box.   SvcCtl   Indicates that this is a logon initiated by the Service controller. StationHandle is not used in this case."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "StationHandle",
        "description": "A 32-bit value whose meaning is dependent upon the name (and consequently, the type) of the station specified in lpStationName.  ValueMeaning  WinSta_0   A handle to the owner dialog box (hwndOwner) currently displayed on the screen.   SvcCtl   Random data. Do not use."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "*lpLogonScript",
        "description": "Pointer to a location where a pointer to a null-terminated string may be returned.     After the function completes, this value may point to a null-terminated string that contains the name of a program to execute plus any parameters the program requires.  LocalAlloc should be used to allocate the memory for the returned string. This memory will be freed by MPR when it is no longer needed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "MPR calls this function to notify the credential manager of a password change event. The NPPasswordChangeNotify function is implemented by a credential manager DLL.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, the function returns WN_SUCCESS. If the function fails, it returns an error code, which can be one of the following values.  ",
    "remarks": "The  NPPasswordChangeNotify function is implemented by credential managers to receive notifications when authentication information changes. Windows Server 2003 and Windows XP:  NPPasswordChangeNotify is called on a computer a user is logging into if the password has been changed somewhere else. Note that this behavior is not supported beginning with Windows Vista and Windows Server 2008. ",
    "return_type": "DWORD APIENTRY",
    "category": "Authentication",
    "name": "NPPasswordChangeNotify",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpAuthentInfoType",
        "description": "Pointer to a string that identifies the type of structure pointed to by lpAuthentInfo.     When Microsoft is the primary authenticator, the following string is specified for interactive and service controller logons.   C++     Copy      MSV1_0:Interactive  Kerberos:Interactive"
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpAuthentInfo",
        "description": "Pointer to an structure that contains the new credentials.     When Microsoft is the primary authenticator (that is, when lpAuthentifoType is \"MSV1_0:Interactive\" or \"Kerberos:Interactive\"), the structure used is  MSV1_0_INTERACTIVE_LOGON or  KERB_INTERACTIVE_LOGON."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "lpPreviousAuthentInfoType",
        "description": "Pointer to a string that identifies the type of structure pointed to by lpPreviousAuthentInfo. If the pointer is NULL, there was no previous information. The values that are expected here are the same as those in lpAuthentInfoType.     When Microsoft is the primary authenticator, the following string is specified for interactive and service controller logons.   C++     Copy      MSV1_0:Interactive"
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpPreviousAuthentInfo",
        "description": "Pointer to a structure that contains the credentials used before the authentication information change. Prior information is provided if the user was forced to change the password (or other authentication information) before logging on. If the user was not forced to change authentication information, this pointer is NULL. The values expected here are the same as those in lpAuthentInfo.     When Microsoft is the primary authenticator, the structure used is  MSV1_0_INTERACTIVE_LOGON or  KERB_INTERACTIVE_LOGON."
      },
      {
        "in_out": "_In_",
        "type": "LPWSTR",
        "name": "lpStationName",
        "description": "Pointer to a string that specifies the name of the station the user has logged on to. The station name may be used to determine whether additional provider-specific information can be obtained.     When Microsoft is the primary authenticator, one of the following strings will be specified.  ValueMeaning  WinSta_0   Indicates that this is an interactive logon through the window station. In this case, StationHandle is an HWND to the parent dialog box.   SvcCtl   Indicates that this is a logon initiated by the service controller. StationHandle is not used in this case."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "StationHandle",
        "description": "A 32-bit value whose meaning is dependent upon the name (and consequently, the type) of the station specified in lpStationName.      \t\t\t\t\t  ValueMeaning  WinSta_0   A handle to the owner dialog box (hwndOwner) currently displayed on the screen.   SvcCtl   Random data. Do not use."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwChangeInfo",
        "description": "If set, specifies a flag that provides change information. This parameter can be one of the flags.  ValueMeaning  WN_VALID_LOGON_ACCOUNT   This flag indicates that the authentication information changed will affect all future logons. The user belongs to a trusted domain.   WN_NT_PASSWORD_CHANGED   This flag indicates that the password was changed.     Some authentication information changes will only affect connections made in untrusted domains. These are the accounts that the user cannot use to log onto this computer anyway. In these cases, dwChangeInfo is not set."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetOpenCardName function displays the smart card \"select card\" dialog box. Call the function  SCardUIDlgSelectCard instead of GetOpenCardName. The GetOpenCardName function is maintained for backward compatibility with version 1.0 of the Microsoft Smart Card Base Components, but calls to GetOpenCardName are mapped to SCardUIDlgSelectCard.",
    "library": "Scarddlg.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "The function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Authentication",
    "name": "GetOpenCardName",
    "is_callback": 0,
    "dll": "Scarddlg.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOPENCARDNAME",
        "name": "pDlgStruc",
        "description": "A pointer to the  OPENCARDNAME structure for the \"select card\" dialog box."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SCardUIDlgSelectCard function displays the smart card Select Card dialog box.",
    "library": "Scarddlg.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function successfully displays the  \t\t\t\t\t\tSelect Card dialog box, the return value is SCARD_S_SUCCESS. If the function fails, it returns an error code. For more information, see  Smart Card Return Values. ",
    "remarks": "The SCardUIDlgSelectCard function provides a method for connecting to a specific smart card. When called, this function performs a search for appropriate smart cards matching the OPENCARD_SEARCH_CRITERIA member specified by the pDlgStruc parameter. Depending on the dwFlags member of pDlgStruc, this function takes the following actions.  This function replaces  GetOpenCardName. The GetOpenCardName function is maintained for backward compatibility with version 1.0 of the Microsoft Smart Card Base Components. The following example  shows how to display the smart card Select Card dialog box. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardUIDlgSelectCard",
    "is_callback": 0,
    "dll": "Scarddlg.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPOPENCARDNAME_EX",
        "name": "pDlgStruc",
        "description": "Pointer to the  OPENCARDNAME_EX structure for the Select Card dialog box."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The SCardAccessStartedEvent function returns an event handle when an event signals that the smart card resource manager is started. The event-object handle can be specified in a call to one of the wait functions.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "The function returns an event HANDLE if it succeeds or NULL if it fails. If the function fails, the GetLastError function provides information on the cause of the failure. ",
    "remarks": "The event-object handle returned can be specified in a call to one of the wait functions.  Do not close the handle returned by this function. When you have finished using the handle, decrement the reference count by calling the SCardReleaseStartedEvent function. ",
    "return_type": "HANDLE WINAPI",
    "category": "Authentication",
    "name": "SCardAccessStartedEvent",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SCardAddReaderToGroup function adds a reader to a reader group.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "SCardAddReaderToGroup automatically creates the reader group specified if it does not already exist. The SCardAddReaderToGroup function is a database management function. For more information on other database management functions, see  Smart Card Database Management Functions. The following example demonstrates how to add a smart card reader to a    group.     The example assumes that lReturn is an existing variable of type LONG, that hContext is a valid handle received from a previous call to the SCardEstablishContext function, and that \"MyReader\" and \"MyReaderGroup\"  are known by the system through previous calls to the SCardIntroduceReader and SCardIntroduceReaderGroup functions, respectively. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardAddReaderToGroup",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReaderName",
        "description": "Display name of the reader that you are adding."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szGroupName",
        "description": "Display name of the group to which you are adding the reader.  ValueMeaning  SCARD_ALL_READERS TEXT(\"SCard$AllReaders\\000\")   Group used when no group name is provided when listing readers. Returns a list of all readers, regardless of what group or groups the readers are in.   SCARD_DEFAULT_READERS TEXT(\"SCard$DefaultReaders\\000\")   Default group to which all readers are added when introduced into the system.   SCARD_LOCAL_READERS TEXT(\"SCard$LocalReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only.   SCARD_SYSTEM_READERS TEXT(\"SCard$SystemReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardAudit function writes event messages to the Windows application log Microsoft-Windows-SmartCard-Audit/Authentication.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected. An application calling the SCardAudit function from within a Remote Desktop session will log the event on the remote system. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardAudit",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context can be set by a previous call to the SCardEstablishContext function. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwEvent",
        "description": "The event to log.  ValueMeaning  SCARD_AUDIT_CHV_FAILURE 0x0   A smart card holder verification (CHV) attempt failed.   SCARD_AUDIT_CHV_SUCCESS 0x1   A smart card holder verification (CHV) attempt succeeded."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SCardBeginTransaction function starts a transaction.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function succeeds, it returns SCARD_S_SUCCESS. If the function fails, it returns an error code. For more information, see Smart Card Return Values. If another process or thread has reset the card, SCARD_W_RESET_CARD is returned as expected. Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  This function returns SCARD_S_SUCCESS even if another process or thread has reset the card. To determine whether the card has been reset, call the SCardStatus function immediately after calling this function. ",
    "remarks": "If a transaction is held on the card for more than five seconds with no operations happening on that card, then the card is reset. Calling any of the Smart Card and Reader Access Functions or Direct Card Access Functions on the card that is transacted results in the timer being reset to continue allowing the transaction to be used. The SCardBeginTransaction function is a smart card and reader access function. For more information about other access functions, see  Smart Card and Reader Access Functions. The following example demonstrates how to begin a smart card transaction. The example assumes that lReturn is an existing variable of type LONG and that hCard is a valid handle received from a previous call to SCardConnect. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardBeginTransaction",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "A reference value obtained from a previous call to  SCardConnect."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SCardCancel function terminates all outstanding actions within a specific resource manager context.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardCancel function is a smart card tracking function. For a description of other tracking functions, see  Smart Card Tracking Functions. The following example cancels all outstanding actions in the specified context.  The example assumes that lReturn is an existing variable of type LONG and that hContext is a valid handle received from a previous call to SCardEstablishContext. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardCancel",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The SCardConnect function establishes a connection (using a specific resource manager context) between the calling application and a smart card contained by a specific reader. If no card exists in the specified reader, an error is returned.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardConnect function is a smart card and reader access function. For more information about other access functions, see  Smart Card and Reader Access Functions. The following example creates a connection to a reader. The example assumes that hContext is a valid handle of type SCARDCONTEXT received from a previous call to SCardEstablishContext. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardConnect",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "A handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReader",
        "description": "The name of the reader that contains the target card."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwShareMode",
        "description": "A flag that indicates whether other applications may form connections to the card.  ValueMeaning  SCARD_SHARE_SHARED   This application is willing to share the card with other applications.   SCARD_SHARE_EXCLUSIVE   This application is not willing to share the card with other applications.   SCARD_SHARE_DIRECT   This application is allocating the reader for its private use, and will be controlling it directly. No other applications are allowed access to it."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwPreferredProtocols",
        "description": "A bitmask of acceptable protocols for the connection. Possible values may be combined with the OR operation.  ValueMeaning  SCARD_PROTOCOL_T0   T=0 is an acceptable protocol.   SCARD_PROTOCOL_T1   T=1 is an acceptable protocol.   0   This parameter may be zero only if dwShareMode is set to SCARD_SHARE_DIRECT. In this case, no protocol negotiation will be performed by the drivers until an IOCTL_SMARTCARD_SET_PROTOCOL control directive is sent with SCardControl."
      },
      {
        "in_out": "_Out_",
        "type": "LPSCARDHANDLE",
        "name": "phCard",
        "description": "A handle that identifies the connection to the smart card in the designated reader."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "pdwActiveProtocol",
        "description": "A flag that indicates the established active protocol.  ValueMeaning  SCARD_PROTOCOL_T0   T=0 is the active protocol.   SCARD_PROTOCOL_T1   T=1 is the active protocol.   SCARD_PROTOCOL_UNDEFINED   SCARD_SHARE_DIRECT has been specified, so that no protocol negotiation has occurred. It is possible that there is no card in the reader."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The SCardControl function gives you direct control of the reader. You can call it any time after a successful call to SCardConnect and before a successful call to SCardDisconnect. The effect on the state of the reader depends on the control code.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardControl function is a direct card access function. For more information on other direct access functions, see  Direct Card Access Functions. The following example issues a control code. The example assumes that hCardHandle is a valid handle received from a previous call to SCardConnect and that dwControlCode is a variable of type DWORD previously initialized to a valid control code. This particular control code requires no input data and expects no output data. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardControl",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "Reference value returned from  SCardConnect."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwControlCode",
        "description": "Control code for the operation. This value identifies the specific operation to be performed."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "lpInBuffer",
        "description": "Pointer to a buffer that contains the data required to perform the operation. This parameter can be NULL if the dwControlCode parameter specifies an operation that does not require input data."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nInBufferSize",
        "description": "Size, in bytes, of the buffer pointed to by lpInBuffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpOutBuffer",
        "description": "Pointer to a buffer that receives the operation's output data. This parameter can be NULL if the dwControlCode parameter specifies an operation that does not produce output data."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nOutBufferSize",
        "description": "Size, in bytes, of the buffer pointed to by lpOutBuffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpBytesReturned",
        "description": "Pointer to a DWORD that receives the size, in bytes, of the data stored into the buffer pointed to by lpOutBuffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardDisconnect function terminates a connection previously opened between the calling application and a smart card in the target reader.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "If an application (which previously called  SCardConnect) exits without calling SCardDisconnect, the card is automatically reset. The SCardDisconnect function is a smart card and reader access function. For more information on other access functions, see  Smart Card and Reader Access Functions. The following example terminates the specified smart card connection. The example assumes that lReturn is a variable of type LONG, and that hCardHandle is a valid handle received from a previous call to SCardConnect. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardDisconnect",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "Reference value obtained from a previous call to  SCardConnect."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDisposition",
        "description": "Action to take on the card in the connected reader on close.  \t\t\t\t\t  ValueMeaning  SCARD_LEAVE_CARD   Do not do anything special.   SCARD_RESET_CARD   Reset the card.   SCARD_UNPOWER_CARD   Power down the card.   SCARD_EJECT_CARD   Eject the card."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardEndTransaction function completes a previously declared transaction, allowing other applications to resume interactions with the card.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function succeeds, the function returns SCARD_S_SUCCESS. If the function fails, it returns an error code. For more information, see Smart Card Return Values.   Possible error codes follow.  ",
    "remarks": "The SCardEndTransaction function is a smart card and reader access function. For more information on other access functions, see  Smart Card and Reader Access Functions. The following example ends a smart card transaction. The example assumes that lReturn is a valid variable of type LONG, that hCard is a valid handle received from a previous call to the SCardConnect function, and that hCard was passed to a previous call to the SCardBeginTransaction function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardEndTransaction",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "Reference value obtained from a previous call to  SCardConnect. This value would also have been used in an earlier call to  SCardBeginTransaction."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDisposition",
        "description": "Action to take on the card in the connected reader on close.  \t\t\t\t\t  ValueMeaning  SCARD_EJECT_CARD   Eject the card.   SCARD_LEAVE_CARD   Do not do anything special.   SCARD_RESET_CARD   Reset the card.   SCARD_UNPOWER_CARD   Power down the card."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardEstablishContext function establishes the resource manager context (the scope) within which database operations are performed.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function succeeds, the function returns SCARD_S_SUCCESS. If the function fails, it returns an error code. For more information, see Smart Card Return Values. ",
    "remarks": "The context handle returned by SCardEstablishContext can be used by database query and management functions. For more information, see  Smart Card Database Query Functions and  Smart Card Database Management Functions. To release an established resource manager context, use  SCardReleaseContext. If the client attempts a smart card operation in a remote session, such as a client session running on a terminal server, and the operating system in use does not support smart card redirection, this function returns ERROR_BROKEN_PIPE. The following example establishes a resource manager context. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardEstablishContext",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwScope",
        "description": "Scope of the resource manager context. This parameter can be one of the following values.  ValueMeaning  SCARD_SCOPE_USER   Database operations are performed within the domain of the user.   SCARD_SCOPE_SYSTEM   Database operations are performed within the domain of the system. The calling application must have appropriate access permissions for any database actions."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "pvReserved1",
        "description": "Reserved for future use and must be NULL. This parameter will allow a suitably privileged management application to act on behalf of another user."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "pvReserved2",
        "description": "Reserved for future use and must be NULL."
      },
      {
        "in_out": "_Out_",
        "type": "LPSCARDCONTEXT",
        "name": "phContext",
        "description": "A handle to the established resource manager context. This handle can now be supplied to other functions attempting to do work within this context."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardForgetCardType function removes an introduced smart card from the smart card subsystem.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected, but calling the function SCardForgetCardType when inside a Remote Desktop session  will not result in an error. It only means that the result will be from the remote computer instead of the local computer. The SCardForgetCardType function is a database management function. For more information about other database management functions, see  Smart Card Database Management Functions. The following example removes the specified card type from the system. The example assumes that lReturn is a valid variable of type LONG,  that hContext is a valid handle received from a previous call to the SCardEstablishContext function, and that \"MyCardName\" was  previously introduced by a call to the SCardIntroduceCardType function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardForgetCardType",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szCardName",
        "description": "Display name of the card to be removed from the smart card database."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardForgetReader function removes a previously introduced reader from control by the smart card subsystem. It is removed from the smart card database, including from any reader group that it may have been added to.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "If the specified reader is the last member of a reader group, the reader group is automatically removed as well. The SCardForgetReader function is a database management function. For more information on other database management functions, see  Smart Card Database Management Functions. The following example removes the display name of the specified card reader from the system. The example assumes that lReturn is a valid variable of type LONG and that hContext is a valid handle received from a previous call to the SCardEstablishContext function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardForgetReader",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReaderName",
        "description": "Display name of the reader to be removed from the smart card database."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardForgetReaderGroup function removes a previously introduced smart card reader group from the smart card subsystem. Although this function automatically clears all readers from the group, it does not affect the existence of the individual readers in the database.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardForgetReaderGroup function is a database management function. For more information on other database management functions, see  Smart Card Database Management Functions. The following example shows how to remove a reader group from the system. The example assumes that lReturn is an existing variable of type LONG, and that hContext is a valid handle to a resource manager context previously obtained from a call to the SCardEstablishContext function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardForgetReaderGroup",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szGroupName",
        "description": "Display name of the reader group to be removed. System-defined reader groups cannot be removed from the database.  ValueMeaning  SCARD_ALL_READERS TEXT(\"SCard$AllReaders\\000\")   Group used when no group name is provided when listing readers. Returns a list of all readers, regardless of what group or groups the readers are in.   SCARD_DEFAULT_READERS TEXT(\"SCard$DefaultReaders\\000\")   Default group to which all readers are added when introduced into the system.   SCARD_LOCAL_READERS TEXT(\"SCard$LocalReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only.   SCARD_SYSTEM_READERS TEXT(\"SCard$SystemReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardFreeMemory function releases memory that has been returned from the resource manager using the SCARD_AUTOALLOCATE length designator.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  The following example shows how to free memory allocated by the resource manager. The example assumes that lReturn is an existing variable of type LONG, that hSC is a valid handle to a resource manager context obtained from a previous call to the SCardEstablishContext function, and that pmszReaders is a string initialized in a previous call to the SCardListReaders function. ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardFreeMemory",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context returned from SCardEstablishContext, or NULL if the creating function also specified NULL for its hContext parameter. For more information, see  Smart Card Database Query Functions."
      },
      {
        "in_out": "_In_",
        "type": "LPCVOID",
        "name": "pvMem",
        "description": "Memory block to be released."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardGetAttrib function retrieves the current reader attributes for the given handle. It does not affect the state of the reader, driver, or card.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardGetAttrib function is a direct card access function. For more information on other direct access functions, see  Direct Card Access Functions. The following example shows how to retrieve an attribute for a card reader. The example assumes that hCardHandle is a valid handle obtained from a previous call to the SCardConnect function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetAttrib",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "Reference value returned from SCardConnect."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAttrId",
        "description": "Identifier for the attribute to get. The following table lists possible values for dwAttrId. These values are read-only. Note that vendors may not support all attributes.      \t\t\t\t\t  ValueMeaning  SCARD_ATTR_ATR_STRING   Answer to reset (ATR) string.   SCARD_ATTR_CHANNEL_ID   DWORD encoded as 0xDDDDCCCC, where DDDD = data channel type and CCCC = channel number:      The following encodings are defined for DDDD: 0x01 serial I/O; CCCC is a port number. 0x02 parallel I/O; CCCC is a port number. 0x04 PS/2 keyboard port; CCCC is zero. 0x08 SCSI; CCCC is SCSI ID number. 0x10 IDE; CCCC is device number. 0x20 USB; CCCC is device number. 0xFy vendor-defined interface with y in the range zero through 15; CCCC is vendor defined.    SCARD_ATTR_CHARACTERISTICS   DWORD indicating which mechanical characteristics are supported. If zero, no special characteristics are supported. Note that multiple bits can be set:      0x00000001 Card swallowing mechanism 0x00000002 Card ejection mechanism 0x00000004 Card capture mechanism  All other values are reserved for future use (RFU).   SCARD_ATTR_CURRENT_BWT   Current block waiting time.   SCARD_ATTR_CURRENT_CLK   Current clock rate, in kHz.   SCARD_ATTR_CURRENT_CWT   Current character waiting time.   SCARD_ATTR_CURRENT_D   Bit rate conversion factor.   SCARD_ATTR_CURRENT_EBC_ENCODING   Current error block control encoding.     0 = longitudinal redundancy check (LRC) 1 = cyclical redundancy check (CRC)   SCARD_ATTR_CURRENT_F   Clock conversion factor.   SCARD_ATTR_CURRENT_IFSC   Current byte size for information field size card.   SCARD_ATTR_CURRENT_IFSD   Current byte size for information field size device.   SCARD_ATTR_CURRENT_N   Current guard time.   SCARD_ATTR_CURRENT_PROTOCOL_TYPE   DWORD encoded as 0x0rrrpppp where rrr is RFU and should be 0x000. pppp encodes the current protocol type. Whichever bit has been set indicates which ISO protocol is currently in use. (For example, if bit zero is set, T=0 protocol is in effect.)   SCARD_ATTR_CURRENT_W   Current work waiting time.   SCARD_ATTR_DEFAULT_CLK   Default clock rate, in kHz.   SCARD_ATTR_DEFAULT_DATA_RATE   Default data rate, in bps.   SCARD_ATTR_DEVICE_FRIENDLY_NAME   Reader's display name.   SCARD_ATTR_DEVICE_IN_USE   Reserved for future use.   SCARD_ATTR_DEVICE_SYSTEM_NAME   Reader's system name.   SCARD_ATTR_DEVICE_UNIT   Instance of this vendor's reader attached to the computer. The first instance will be device unit 0, the next will be unit 1 (if it is the same brand of reader) and so on. Two different brands of readers will both have zero for this value.   SCARD_ATTR_ICC_INTERFACE_STATUS   Single byte. Zero if smart card electrical contact is not active; nonzero if contact is active.   SCARD_ATTR_ICC_PRESENCE   Single byte indicating smart card presence:     0 = not present 1 = card present but not swallowed (applies only if reader supports smart card swallowing) 2 = card present (and swallowed if reader supports smart card swallowing) 4 = card confiscated.   SCARD_ATTR_ICC_TYPE_PER_ATR   Single byte indicating smart card type:     0 = unknown type 1 = 7816 Asynchronous 2 = 7816 Synchronous Other values RFU.   SCARD_ATTR_MAX_CLK   Maximum clock rate, in kHz.   SCARD_ATTR_MAX_DATA_RATE   Maximum data rate, in bps.   SCARD_ATTR_MAX_IFSD   Maximum bytes for information file size device.   SCARD_ATTR_POWER_MGMT_SUPPORT   Zero if device does not support power down while smart card is inserted. Nonzero otherwise.   SCARD_ATTR_PROTOCOL_TYPES   DWORD encoded as 0x0rrrpppp where rrr is RFU and should be 0x000. pppp encodes the supported protocol types. A '1' in a given bit position indicates support for the associated ISO protocol, so if bits zero and one are set, both T=0 and T=1 protocols are supported.   SCARD_ATTR_VENDOR_IFD_SERIAL_NO   Vendor-supplied interface device serial number.   SCARD_ATTR_VENDOR_IFD_TYPE   Vendor-supplied interface device type (model designation of reader).   SCARD_ATTR_VENDOR_IFD_VERSION   Vendor-supplied interface device version (DWORD in the form 0xMMmmbbbb where MM = major version, mm = minor version, and bbbb = build number).   SCARD_ATTR_VENDOR_NAME   Vendor name."
      },
      {
        "in_out": "_Out_",
        "type": "LPBYTE",
        "name": "pbAttr",
        "description": "Pointer to a buffer that receives the attribute whose ID is supplied in dwAttrId. If this value is NULL, SCardGetAttrib ignores the buffer length supplied in pcbAttrLen, writes the length of the buffer that would have been returned if this parameter had not been NULL to pcbAttrLen, and returns a success code."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcbAttrLen",
        "description": "Length of the pbAttr buffer in bytes, and receives the actual length of the received attribute If the buffer length is specified as SCARD_AUTOALLOCATE, then pbAttr is converted to a pointer to a byte pointer, and receives the address of a block of memory containing the attribute. This block of memory must be deallocated with  SCardFreeMemory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The SCardGetCardTypeProviderName function returns the name of the module (dynamic link library) that contains the provider for a given card name and provider type.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected, but calling the function when inside a Remote Desktop session  will not result in an error. It only means that the result will be from the remote computer instead of the local computer. Upon successful completion of this function, the value in szProvider can be used as the third parameter in a call to  CryptAcquireContext. The following example shows how to retrieve the provider name for the specified reader context. The example assumes that hContext is a valid handle obtained from a previous call to the SCardEstablishContext function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetCardTypeProviderName",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context can be set by a previous call to  SCardEstablishContext. This value can be NULL if the call to SCardGetCardTypeProviderName is not directed to a specific context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szCardName",
        "description": "Name of the card type with which this provider name is associated."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwProviderId",
        "description": "Identifier for the provider associated with this card type.  \t\t\t\t\t  ValueMeaning  SCARD_PROVIDER_PRIMARY 1   The function retrieves the name of the smart card's primary service provider as a GUID string.   SCARD_PROVIDER_CSP 2   The function retrieves the name of the cryptographic service provider.   SCARD_PROVIDER_KSP 3   The function retrieves the name of the smart card key storage provider (KSP).   SCARD_PROVIDER_CARD_MODULE 0x80000001   The function retrieves the name of the card module."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "szProvider",
        "description": "String variable to receive the provider name upon successful completion of this function."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcchProvider",
        "description": "Pointer to DWORD value. On input, pcchProvider supplies the length of the szProvider buffer in characters. If this value is SCARD_AUTOALLOCATE, then szProvider is converted to a pointer to a byte pointer and receives the address of a block of memory containing the string. This block of memory must be deallocated by calling  SCardFreeMemory.     On output, this value represents the actual number of characters, including the null terminator, in the szProvider variable."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SCardGetDeviceTypeId function gets the device type identifier of the card reader for the given reader name. This function does not affect the state of the reader.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetDeviceTypeId",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. You can set the resource manager context by calling the SCardEstablishContext function. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReaderName",
        "description": "Reader name. You can get this value by calling the SCardListReaders function."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pdwDeviceTypeId",
        "description": "The actual device type identifier. The list of reader types returned by this function are listed under ReaderType member in the SCARD_READER_CAPABILITIES structure."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SCardGetProviderId function returns the identifier (GUID) of the primary service provider for a given card.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected, but calling the function when inside a Remote Desktop session  will not result in an error. It only means that the result will be from the remote computer instead of the local computer. The SCardGetProviderId function is a database query function. For more information on other database query functions, see  Smart Card Database Query Functions. The following example shows how to get the provider ID for the specified card. The example assumes that hContext is a valid handle obtained from a previous call to the SCardEstablishContext function and that \"MyCardName\" was introduced by a previous call to the SCardIntroduceCardType function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetProviderId",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. The resource manager context can be set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szCard",
        "description": "Name of the card defined to the system."
      },
      {
        "in_out": "_Out_",
        "type": "LPGUID",
        "name": "pguidProviderId",
        "description": "Identifier (GUID) of the primary service provider. This provider may be activated using COM, and will supply access to other services in the card."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardGetReaderDeviceInstanceId function gets the device instance identifier of  the card reader for the given reader name. This function does not affect the state of the reader.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected. Calling the SCardGetReaderDeviceInstanceId function when inside a Remote Desktop session fails with the SCARD_E_READER_UNAVAILABLE error code. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetReaderDeviceInstanceId",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. You can set the resource manager context by a previous call to the SCardEstablishContext function. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReaderName",
        "description": "Reader name. You can get this value by calling the SCardListReaders function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "szDeviceInstanceId",
        "description": "Buffer that receives the device instance ID of the reader. If this value is NULL, the function ignores the buffer length supplied in cchDeviceInstanceId parameter, writes the length of the buffer that would have been returned if this parameter had not been NULL to cchDeviceInstanceId, and returns a success code."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "cchDeviceInstanceId",
        "description": "Length, in characters, of the szDeviceInstanceId buffer, including the NULL terminator. If the buffer length is specified as SCARD_AUTOALLOCATE, then the szDeviceInstanceId parameter is converted to a pointer to a byte pointer, and receives the address of a block of memory containing the instance id. This block of memory must be deallocated with the SCardFreeMemory function."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardGetReaderIcon function gets an icon of the smart card reader for a given reader's name. This function does not affect the state of the card reader.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The icon should be 256 \u00c3\u0097 256 pixels with no alpha channel. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetReaderIcon",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. You can set the resource manager context by a previous call to the SCardEstablishContext function. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReaderName",
        "description": "Reader name. You can get this value by calling the SCardListReaders function."
      },
      {
        "in_out": "_Out_",
        "type": "LPBYTE",
        "name": "pbIcon",
        "description": "Pointer to a buffer that contains a BLOB of the smart card reader icon as read from the icon file. If this value is NULL, the function ignores the buffer length supplied in the pcbIcon parameter, writes the length of the buffer that would have been returned to pcbIcon if this parameter had not been NULL, and returns a success code."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcbIcon",
        "description": "Length, in characters, of the pbIcon buffer. This parameter receives the actual length of the received attribute. If the buffer length is specified as SCARD_AUTOALLOCATE, then pbIcon is converted from a pointer to a byte pointer and receives the address of a block of memory that contains the attribute. This block of memory must be deallocated with the SCardFreeMemory function."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardGetStatusChange function blocks execution until the current availability of the cards in a specific set of readers changes.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardGetStatusChange function is a smart card tracking function. For more information about other tracking functions, see  Smart Card Tracking Functions. For information about how to call this function, see the  example in  SCardLocateCards. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetStatusChange",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "A handle that identifies the resource manager context. The resource manager context is set by a previous call to  the SCardEstablishContext function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTimeout",
        "description": "The maximum amount of time, in milliseconds, to wait for an action. A value of zero causes the function to return immediately. A value of INFINITE causes this function never to time out."
      },
      {
        "in_out": "_Inout_",
        "type": "LPSCARD_READERSTATE",
        "name": "rgReaderStates",
        "description": "An array of  SCARD_READERSTATE structures that specify the readers to watch, and that receives the result. To be notified of the arrival of a new smart card reader, set the szReader member of a SCARD_READERSTATE structure to \"\\\\\\\\?PnP?\\\\Notification\", and set all of the other members of that structure to zero. Important  Each member of each structure in this array must be initialized to zero and then set to specific values as necessary. If this is not done, the function will fail in situations that involve remote card readers."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cReaders",
        "description": "The number of elements in the rgReaderStates array."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardGetTransmitCount function retrieves the number of transmit operations that have completed since the specified card reader was inserted.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function succeeds, it returns SCARD_S_SUCCESS. If the function fails, it returns an error code. For more information, see Smart Card Return Values. ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardGetTransmitCount",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "A handle to a smart card obtained from a previous call to  SCardConnect."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "pcTransmitCount",
        "description": "A pointer to the number of transmit operations that have completed since the specified card reader was inserted."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "The SCardIntroduceCardType function introduces a smart card to the smart card subsystem (for the active user) by adding it to the smart card database.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected, but calling the function when inside a Remote Desktop session  will not result in an error. It only means that the result will be from the remote computer instead of the local computer. The SCardIntroduceCardType function is a database management function. For more information on other database management functions, see  Smart Card Database Management Functions. To remove a smart card, use  SCardForgetCardType. The following example shows how to introduce a card type. The example assumes that hContext is a valid handle obtained from a previous call to the SCardEstablishContext function. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardIntroduceCardType",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szCardName",
        "description": "Name by which the user can recognize the card."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCGUID",
        "name": "pguidPrimaryProvider",
        "description": "Pointer to the identifier (GUID) for the smart card's primary service provider."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCGUID",
        "name": "rgguidInterfaces",
        "description": "Array of identifiers (GUIDs) that identify the interfaces supported by the smart card."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInterfaceCount",
        "description": "Number of identifiers in the rgguidInterfaces array."
      },
      {
        "in_out": "_In_",
        "type": "LPCBYTE",
        "name": "pbAtr",
        "description": "ATR string that can be used for matching purposes when querying the smart card database (for more information, see  SCardListCards). The length of this string is determined by normal ATR parsing."
      },
      {
        "in_out": "_In_",
        "type": "LPCBYTE",
        "name": "pbAtrMask",
        "description": "Optional bitmask to use when comparing the ATRs of smart cards to the ATR supplied in pbAtr. If this value is non-NULL, it must point to a string of bytes the same length as the ATR string supplied in pbAtr. When a given ATR string A is compared to the ATR supplied in pbAtr, it matches if and only if A & M = pbAtr, where M is the supplied mask, and & represents bitwise AND."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbAtrLen",
        "description": "Length of the ATR and optional ATR mask. If this value is zero, then the length of the ATR is determined by normal ATR parsing. This value cannot be zero if a pbAtr value is supplied."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SCardIntroduceReader function introduces a new name for an existing smart card reader.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "All readers installed on the system are automatically introduced by their system name. Typically, SCardIntroduceReader is called only to change the name of an existing reader. The SCardIntroduceReader function is a database management function. For more information on other database management functions, see  Smart Card Database Management Functions. To remove a reader, use  SCardForgetReader. The following example  shows introducing a smart card reader. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardIntroduceReader",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReaderName",
        "description": "Display name to be assigned to the reader."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szDeviceName",
        "description": "System name of the smart card reader, for example, \"MyReader 01\"."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SCardIntroduceReaderGroup function introduces a reader group to the smart card subsystem. However, the reader group is not created until the group is specified when adding a reader to the smart card database.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardIntroduceReaderGroup function is provided for PC/SC specification compatibility. Reader groups are not stored until a reader is added to the group. The SCardIntroduceReaderGroup function is a database management function. For a description of other database management functions, see  Smart Card Database Management Functions. To remove a reader group, use  SCardForgetReaderGroup. The following example  shows introducing a smart card reader group. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardIntroduceReaderGroup",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Supplies the handle that identifies the resource manager context. The resource manager context is set by a previous call to  the SCardEstablishContext function. If this parameter is NULL, the scope of the resource manager is SCARD_SCOPE_SYSTEM."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szGroupName",
        "description": "Supplies the display name to be assigned to the new reader group.  ValueMeaning  SCARD_ALL_READERS TEXT(\"SCard$AllReaders\\000\")   Group used when no group name is provided when listing readers. Returns a list of all readers, regardless of what group or groups the readers are in.   SCARD_DEFAULT_READERS TEXT(\"SCard$DefaultReaders\\000\")   Default group to which all readers are added when introduced into the system.   SCARD_LOCAL_READERS TEXT(\"SCard$LocalReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only.   SCARD_SYSTEM_READERS TEXT(\"SCard$SystemReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SCardIsValidContext function determines whether a smart card context handle is valid.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns one of the following values.  ",
    "remarks": "Call this function to determine whether a smart card context handle is still valid. After a smart card context handle has been set by  SCardEstablishContext, it may become not valid if the resource manager service has been shut down. The following example  shows determining whether a smart card context handle is valid. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardIsValidContext",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context can be set by a previous call to  SCardEstablishContext."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The SCardListCards function searches the smart card database and provides a list of named cards previously introduced to the system by the user.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected, but calling the function when inside a Remote Desktop session  will not result in an error. It only means that the result will be from the remote computer instead of the local computer. To return all smart cards introduced to the subsystem, set pbAtr and rgguidInterfaces to NULL. The SCardListCards function is a database query function. For more information on other database query functions, see  Smart Card Database Query Functions. Calling this function should be done outside of a transaction. If an application begins a transaction with the SCardBeginTransaction function and then calls this function, it resets the hCard parameter (of type SCARDHANDLE) of the SCardBeginTransaction function. Windows Server 2008 R2 and Windows 7:  Calling this function within a transaction could result in your computer becoming unresponsive. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  Not applicable. The following example  shows listing of the smart cards. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardListCards",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. The resource manager context can be set by a previous call to SCardEstablishContext. If this parameter is set to NULL, the search for cards is not limited to any context."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCBYTE",
        "name": "pbAtr",
        "description": "Address of an ATR string to compare to known cards, or NULL if no ATR matching is to be performed."
      },
      {
        "in_out": "_In_",
        "type": "LPCGUID",
        "name": "rgguidInterfaces",
        "description": "Array of identifiers (GUIDs), or NULL if no interface matching is to be performed. When an array is supplied, a card name will be returned only if all the specified identifiers are supported by the card."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cguidInterfaceCount",
        "description": "Number of entries in the rgguidInterfaces array. If rgguidInterfaces is NULL, then this value is ignored."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "mszCards",
        "description": "Multi-string that lists the smart cards found. If this value is NULL, SCardListCards ignores the buffer length supplied in pcchCards, returning the length of the buffer that would have been returned if this parameter had not been NULL to pcchCards and a success code."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcchCards",
        "description": "Length of the mszCards buffer in characters. Receives the actual length of the multi-string structure, including all trailing null characters. If the buffer length is specified as SCARD_AUTOALLOCATE, then mszCards is converted to a pointer to a byte pointer, and receives the address of a block of memory containing the multi-string structure. This block of memory must be deallocated with  SCardFreeMemory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardListInterfaces function provides a list of interfaces supplied by a given card.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected, but calling the function when attempting a Remote Desktop session  will not result in an error. It only means that the result will be from the remote computer instead of the local computer. The SCardListInterfaces function is a database query function. For more information on other database query functions, see  Smart Card Database Query Functions. The following example  shows listing the interfaces for a smart card. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardListInterfaces",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. The resource manager context can be set by a previous call to SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szCard",
        "description": "Name of the smart card already introduced to the smart card subsystem."
      },
      {
        "in_out": "_Out_",
        "type": "LPGUID",
        "name": "pguidInterfaces",
        "description": "Array of interface identifiers (GUIDs) that indicate the interfaces supported by the smart card. If this value is NULL, SCardListInterfaces ignores the array length supplied in pcguidInterfaces, returning the size of the array that would have been returned if this parameter had not been NULL to pcguidInterfaces and a success code."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcguidInterfaces",
        "description": "Size of the pcguidInterfaces array, and receives the actual size of the returned array. If the array size is specified as SCARD_AUTOALLOCATE, then pcguidInterfaces is converted to a pointer to a GUID pointer, and receives the address of a block of memory containing the array. This block of memory must be deallocated with  SCardFreeMemory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SCardListReaderGroups function provides the list of reader groups that have previously been introduced to the system.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "A group is returned only if it contains at least one reader. This includes the group SCard$DefaultReaders. The group SCard$AllReaders cannot be returned, since it only exists implicitly. The SCardListReaderGroups function is a database query function. For more information on other database query functions, see  Smart Card Database Query Functions. The following example  shows listing the reader groups. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardListReaderGroups",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. The resource manager context can be set by a previous call to SCardEstablishContext.  If this parameter is set to NULL, the search for reader groups is not limited to any context."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "mszGroups",
        "description": "Multi-string that lists the reader groups defined to the system and available to the current user on the current terminal. If this value is NULL, SCardListReaderGroups ignores the buffer length supplied in pcchGroups, writes the length of the buffer that would have been returned if this parameter had not been NULL to pcchGroups, and returns a success code.  ValueMeaning  SCARD_ALL_READERS TEXT(\"SCard$AllReaders\\000\")   Group used when no group name is provided when listing readers. Returns a list of all readers, regardless of what group or groups the readers are in.   SCARD_DEFAULT_READERS TEXT(\"SCard$DefaultReaders\\000\")   Default group to which all readers are added when introduced into the system.   SCARD_LOCAL_READERS TEXT(\"SCard$LocalReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only.   SCARD_SYSTEM_READERS TEXT(\"SCard$SystemReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcchGroups",
        "description": "Length of the mszGroups buffer in characters, and receives the actual length of the multi-string structure, including all trailing null characters. If the buffer length is specified as SCARD_AUTOALLOCATE, then mszGroups is converted to a pointer to a byte pointer, and receives the address of a block of memory containing the multi-string structure. This block of memory must be deallocated with  SCardFreeMemory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardListReaders function provides the list of readers within a set of named reader groups, eliminating duplicates.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardListReaders function is a database query function. For more information on other database query functions, see  Smart Card Database Query Functions. The following example  shows listing the readers. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardListReaders",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. The resource manager context can be set by a previous call to SCardEstablishContext.  If this parameter is set to NULL, the search for readers is not limited to any context."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "mszGroups",
        "description": "Names of the reader groups defined to the system, as a multi-string. Use a NULL value to list all readers in the system (that is, the SCard$AllReaders group).  ValueMeaning  SCARD_ALL_READERS TEXT(\"SCard$AllReaders\\000\")   Group used when no group name is provided when listing readers. Returns a list of all readers, regardless of what group or groups the readers are in.   SCARD_DEFAULT_READERS TEXT(\"SCard$DefaultReaders\\000\")   Default group to which all readers are added when introduced into the system.   SCARD_LOCAL_READERS TEXT(\"SCard$LocalReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only.   SCARD_SYSTEM_READERS TEXT(\"SCard$SystemReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "mszReaders",
        "description": "Multi-string that lists the card readers within the supplied reader groups. If this value is NULL, SCardListReaders ignores the buffer length supplied in pcchReaders, writes the length of the buffer that would have been returned if this parameter had not been NULL to pcchReaders, and returns a success code."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcchReaders",
        "description": "Length of the mszReaders buffer in characters. This parameter receives the actual length of the multi-string structure, including all trailing null characters. If the buffer length is specified as SCARD_AUTOALLOCATE, then mszReaders is converted to a pointer to a byte pointer, and receives the address of a block of memory containing the multi-string structure. This block of memory must be deallocated with SCardFreeMemory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardListReadersWithDeviceInstanceId function gets the list of readers that have provided a device instance identifier. This function does not affect the state of the reader.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected. Calling the SCardListReadersWithDeviceInstanceId function when inside a Remote Desktop session fails with the SCARD_E_READER_UNAVAILABLE error code. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardListReadersWithDeviceInstanceId",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context for the query. You can set the resource manager context by a previous call to the SCardEstablishContext function. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szDeviceInstanceId",
        "description": "Device instance ID of the reader. You can get this value by calling the SCardGetReaderDeviceInstanceId function with the reader name or by calling the SetupDiGetDeviceInstanceId function from the DDK."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "mszReaders",
        "description": "A multi-string that contain the smart card readers within the supplied device instance identifier. If this value is NULL, then the function ignores the buffer length supplied in the pcchReaders parameter, writes the length of the buffer that would have been returned if this parameter had not been NULL to pcchReaders, and returns a success code."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcchReaders",
        "description": "The length, in characters, of the mszReaders buffer. This parameter receives the actual length of the multiple-string structure, including all terminating null characters. If the buffer length is specified as SCARD_AUTOALLOCATE, then mszReaders is converted to a pointer to a byte pointer, and receives the address of a block of memory that contains the multiple-string structure. When you have finished using this memory, deallocated it by using the SCardFreeMemory function."
      }
    ],
    "min_client": "Windows 8 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardLocateCards function searches the readers listed in the rgReaderStates parameter for a card with an ATR string that matches one of the card names specified in mszCards, returning immediately with the result.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This service is especially useful when used in conjunction with  SCardGetStatusChange. If no matching cards are found by means of SCardLocateCards, the calling application may use SCardGetStatusChange to wait for card availability changes. The SCardLocateCards function is a smart card tracking function. For more information on other tracking functions, see  Smart Card Tracking Functions. Calling this function should be done outside of a transaction. If an application begins a transaction with the SCardBeginTransaction function and then calls this function, it resets the hCard parameter (of type SCARDHANDLE) of the SCardBeginTransaction function. Windows Server 2008 R2 and Windows 7:  Calling this function within a transaction could result in your computer becoming unresponsive. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  Not applicable. The following example  shows locating smart cards. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardLocateCards",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "A handle that identifies the resource manager context. The resource manager context is set by a previous call to SCardEstablishContext."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "mszCards",
        "description": "A multiple string that contains the names of the cards to search for."
      },
      {
        "in_out": "_Inout_",
        "type": "LPSCARD_READERSTATE",
        "name": "rgReaderStates",
        "description": "An array of SCARD_READERSTATE structures that, on input, specify the readers to search and that, on output, receives the result."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cReaders",
        "description": "The number of elements in the rgReaderStates array."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The SCardLocateCardsByATR function searches the readers listed in the rgReaderStates parameter for a card with a name that matches one of the card names contained in one of the SCARD_ATRMASK structures specified by the rgAtrMasks parameter.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This service is especially useful when used in conjunction with  SCardGetStatusChange. If no matching cards are found by means of SCardLocateCards, the calling application may use SCardGetStatusChange to wait for card availability changes. The SCardLocateCardsByATR function is a smart card tracking function. For information about other tracking functions, see  Smart Card Tracking Functions. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardLocateCardsByATR",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to SCardEstablishContext."
      },
      {
        "in_out": "_In_",
        "type": "LPSCARD_ATRMASK",
        "name": "rgAtrMasks",
        "description": "Array of  SCARD_ATRMASK structures that contain the names of the cards for which to search."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cAtrs",
        "description": "Number of elements in the rgAtrMasks array."
      },
      {
        "in_out": "_Inout_",
        "type": "LPSCARD_READERSTATE",
        "name": "rgReaderStates",
        "description": "Array of SCARD_READERSTATE structures that specify the readers to search, and receive the result."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cReaders",
        "description": "Number of elements in the rgReaderStates array."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The SCardReadCache function retrieves the value portion of a name-value pair from the global cache maintained by the Smart Card Resource Manager.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function succeeds, it returns SCARD_S_SUCCESS. If the function fails, it returns one of the following error codes. For more information, see Smart Card Return Values.  ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardReadCache",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "A handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext."
      },
      {
        "in_out": "_In_",
        "type": "UUID",
        "name": "*CardIdentifier",
        "description": "A pointer to a value that uniquely identifies a smart card. The name-value pair that this function reads from the global cache is associated with this smart card."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "FreshnessCounter",
        "description": "The current revision of the cached data."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "LookupName",
        "description": "A pointer to a null-terminated string that contains the name portion of the name-value pair for which to retrieve the value portion."
      },
      {
        "in_out": "_Out_",
        "type": "PBYTE",
        "name": "Data",
        "description": "A pointer to an array of byte values that contain the value portion of the name-value pair specified by the LookupName parameter."
      },
      {
        "in_out": "_Out_",
        "type": "DWORD",
        "name": "*DataLen",
        "description": "A pointer to the size, in bytes, of the Data buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The SCardReconnect function reestablishes an existing connection between the calling application and a smart card. This function moves a card handle from direct access to general access, or acknowledges and clears an error condition that is preventing further access to the card.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "SCardReconnect is a smart card and reader access function. For information about other access functions, see  Smart Card and Reader Access Functions. The following example  shows reestablishing a connection. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardReconnect",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "Reference value obtained from a previous call to  SCardConnect."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwShareMode",
        "description": "Flag that indicates whether other applications may form connections to this card.  ValueMeaning  SCARD_SHARE_SHARED   This application will share this card with other applications.   SCARD_SHARE_EXCLUSIVE   This application will not share this card with other applications."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwPreferredProtocols",
        "description": "Bitmask of acceptable protocols for this connection. Possible values may be combined with the OR operation.     The value of this parameter should include the current protocol. Attempting to reconnect with a protocol other than the current protocol will result in an error.  ValueMeaning  SCARD_PROTOCOL_T0   T=0 is an acceptable protocol.   SCARD_PROTOCOL_T1   T=1 is an acceptable protocol."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwInitialization",
        "description": "Type of initialization that should be performed on the card.  ValueMeaning  SCARD_LEAVE_CARD   Do not do anything special on reconnect.   SCARD_RESET_CARD   Reset the card (Warm Reset).   SCARD_UNPOWER_CARD   Power down the card and reset it (Cold Reset)."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwActiveProtocol",
        "description": "Flag that indicates the established active protocol.  ValueMeaning  SCARD_PROTOCOL_T0   T=0 is the active protocol.   SCARD_PROTOCOL_T1   T=1 is the active protocol."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SCardReleaseContext function closes an established resource manager context, freeing any resources allocated under that context, including SCARDHANDLE objects and memory allocated using the SCARD_AUTOALLOCATE length designator.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  The following example  shows releasing a context. ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardReleaseContext",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to SCardEstablishContext."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The SCardReleaseStartedEvent function decrements the reference count for  a handle acquired by a previous call to the  SCardAccessStartedEvent function.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "void WINAPI",
    "category": "Authentication",
    "name": "SCardReleaseStartedEvent",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SCardRemoveReaderFromGroup function removes a reader from an existing reader group. This function has no effect on the reader.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "When the last reader is removed from a group, the group is automatically forgotten. The SCardRemoveReaderFromGroup function is a database management function. For information about other database management functions, see  Smart Card Database Management Functions. To add a reader to a reader group, use  SCardAddReaderToGroup. The following example  shows how to remove a reader from the group. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardRemoveReaderFromGroup",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szReaderName",
        "description": "Display name of the reader to be removed."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szGroupName",
        "description": "Display name of the group from which the reader should be removed.  ValueMeaning  SCARD_ALL_READERS TEXT(\"SCard$AllReaders\\000\")   Group used when no group name is provided when listing readers. Returns a list of all readers, regardless of what group or groups the readers are in.   SCARD_DEFAULT_READERS TEXT(\"SCard$DefaultReaders\\000\")   Default group to which all readers are added when introduced into the system.   SCARD_LOCAL_READERS TEXT(\"SCard$LocalReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only.   SCARD_SYSTEM_READERS TEXT(\"SCard$SystemReaders\\000\")   Unused legacy value. This is an internally managed group that cannot be modified by using any reader group APIs. It is intended to be used for enumeration only."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardSetAttrib function sets the given reader attribute for the given handle. It does not affect the state of the reader, reader driver, or smart card. Not all attributes are supported by all readers (nor can they be set at all times) as many of the attributes are under direct control of the transport protocol.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "The SCardSetAttrib function is a direct card access function. For information about other direct access functions, see  Direct Card Access Functions. The following example  shows how to set an attribute. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardSetAttrib",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "Reference value returned from  SCardConnect."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAttrId",
        "description": "Identifier for the attribute to set. The values are write-only. Note that vendors may not support all attributes.      \t\t\t\t\t  ValueMeaning  SCARD_ATTR_SUPRESS_T1_IFS_REQUEST   Suppress sending of T=1 IFSD packet from the reader to the card. (Can be used if the currently inserted card does not support an IFSD request.)"
      },
      {
        "in_out": "_In_",
        "type": "LPCBYTE",
        "name": "pbAttr",
        "description": "Pointer to a buffer that supplies the attribute whose ID is supplied in dwAttrId."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbAttrLen",
        "description": "Length (in bytes) of the attribute value in the pbAttr buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SCardSetCardTypeProviderName function specifies the name of the module (dynamic link library) containing the provider for a given card name and provider type.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "This function returns different values depending on whether it succeeds or fails.  ",
    "remarks": "This function is not redirected, but calling the function  when inside a Remote Desktop session  will not result in an error. It only means that the result will be from the remote computer instead of the local computer. This function sets the provider name, while  SCardGetCardTypeProviderName can be used to retrieve the provider name. The following example  shows how to specify the card type provider name. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardSetCardTypeProviderName",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "Handle that identifies the resource manager context. The resource manager context can be set by a previous call to  SCardEstablishContext. This value can be NULL if the call to SCardSetCardTypeProviderName is not directed to a specific context."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szCardName",
        "description": "Name of the card type with which this provider name is associated."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwProviderId",
        "description": "Identifier for the provider associated with this card type.  \t\t\t\t\t  ValueMeaning  SCARD_PROVIDER_PRIMARY 1   The function retrieves the name of the smart card's primary service provider as a GUID string.   SCARD_PROVIDER_CSP 2   The function retrieves the name of the cryptographic service provider (CSP).   SCARD_PROVIDER_KSP 3   The function retrieves the name of the smart card key storage provider (KSP).   SCARD_PROVIDER_CARD_MODULE 0x80000001   The function retrieves the name of the card module."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szProvider",
        "description": "A string that contains the provider name that is representing the CSP."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The SCardStatus function provides the current status of a smart card in a reader. You can call it any time after a successful call to SCardConnect and before a successful call to SCardDisconnect. It does not affect the state of the reader or reader driver.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function successfully provides the current status of a smart card in a reader, the return value is SCARD_S_SUCCESS. If the function fails, it returns an error code. For more information, see  Smart Card Return Values. ",
    "remarks": "The SCardStatus function is a smart card and reader access function. For information about other access functions, see  Smart Card and Reader Access Functions. The following example  shows how to determine the state of the smart card. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardStatus",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "Reference value returned from  SCardConnect."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "szReaderName",
        "description": "List of display names (multiple string) by which the currently connected reader is known."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcchReaderLen",
        "description": "On input, supplies the length of the szReaderName buffer.     On output, receives the actual length (in characters) of the reader name list, including the trailing NULL character. If this buffer length is specified as SCARD_AUTOALLOCATE, then szReaderName is converted to a pointer to a byte pointer, and it receives the address of a block of memory that contains the multiple-string structure."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwState",
        "description": "Current state of the smart card in the reader. Upon success, it receives one of the following state indicators.      \t\t\t\t\t  ValueMeaning  SCARD_ABSENT   There is no card in the reader.   SCARD_PRESENT   There is a card in the reader, but it has not been moved into position for use.   SCARD_SWALLOWED   There is a card in the reader in position for use. The card is not powered.   SCARD_POWERED   Power is being provided to the card, but the reader driver is unaware of the mode of the card.   SCARD_NEGOTIABLE   The card has been reset and is awaiting PTS negotiation.   SCARD_SPECIFIC   The card has been reset and specific communication protocols have been established."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwProtocol",
        "description": "Current protocol, if any. The returned value is meaningful only if the returned value of pdwState is SCARD_SPECIFICMODE.  ValueMeaning  SCARD_PROTOCOL_RAW   The Raw Transfer protocol is in use.   SCARD_PROTOCOL_T0   The ISO 7816/3 T=0 protocol is in use.   SCARD_PROTOCOL_T1   The ISO 7816/3 T=1 protocol is in use."
      },
      {
        "in_out": "_Out_",
        "type": "LPBYTE",
        "name": "pbAtr",
        "description": "Pointer to a 32-byte buffer that receives the ATR string from the currently inserted card, if available."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcbAtrLen",
        "description": "On input, supplies the length of the pbAtr buffer. On output, receives the number of bytes in the ATR string (32 bytes maximum). If this buffer length is specified as SCARD_AUTOALLOCATE, then pbAtr is converted to a pointer to a byte pointer, and it receives the address of a block of memory that contains the multiple-string structure."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The SCardTransmit function sends a service request to the smart card and expects to receive data back from the card.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function successfully sends a service request to the smart card, the return value is SCARD_S_SUCCESS. If the function fails, it returns an error code. For more information, see  Smart Card Return Values. ",
    "remarks": "The SCardTransmit function is a smart card and reader access function. For information about other access functions, see  Smart Card and Reader Access Functions. For the T=0 protocol, the data received back are the SW1 and SW2 status codes, possibly preceded by response data. The following paragraphs provide information about the send and receive buffers used to transfer data and issue a command.  The following example  shows sending a service request to the smart card. ",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardTransmit",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDHANDLE",
        "name": "hCard",
        "description": "A reference value returned from  the SCardConnect function."
      },
      {
        "in_out": "_In_",
        "type": "LPCSCARD_IO_REQUEST",
        "name": "pioSendPci",
        "description": "A pointer to the protocol header structure for the instruction. This buffer is in the format of an SCARD_IO_REQUEST structure, followed by the specific protocol control information (PCI).     For the T=0, T=1, and Raw protocols, the PCI structure is constant. The smart card subsystem supplies a global T=0, T=1, or Raw PCI structure, which you can reference by using the symbols SCARD_PCI_T0, SCARD_PCI_T1, and SCARD_PCI_RAW respectively."
      },
      {
        "in_out": "_In_",
        "type": "LPCBYTE",
        "name": "pbSendBuffer",
        "description": "A pointer to the actual data to be written to the card.  For T=0, the data parameters are placed into the address pointed to by pbSendBuffer according to the following structure:   C++     Copy      struct {     BYTE         bCla,   // the instruction class         bIns,   // the instruction code          bP1,    // parameter to the instruction         bP2,    // parameter to the instruction         bP3;    // size of I/O transfer } CmdBytes;        The data sent to the card should immediately follow the send buffer. In the special case where no data is sent to the card and no data is expected in return, bP3 is not sent.  MemberMeaning  bCla   The T=0 instruction class.   bIns   An instruction code in the T=0 instruction class.   bP1, bP2   Reference codes that complete the instruction code.   bP3   The number of data bytes to be transmitted during the command, per ISO 7816-4, Section 8.2.1."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbSendLength",
        "description": "The length, in bytes, of the pbSendBuffer parameter.     For T=0, in the special case where no data is sent to the card and no data expected in return, this length must reflect that the bP3 member is not being sent; the length should be sizeof(CmdBytes)  - sizeof(BYTE)."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPSCARD_IO_REQUEST",
        "name": "pioRecvPci",
        "description": "Pointer to the protocol header structure for the instruction, followed by a buffer in which to receive any returned protocol control information (PCI) specific to the protocol in use. This parameter can be NULL if no  PCI is returned."
      },
      {
        "in_out": "_Out_",
        "type": "LPBYTE",
        "name": "pbRecvBuffer",
        "description": "Pointer to any data returned from the card.     For T=0, the data is immediately followed by the SW1 and SW2 status bytes. If no data is returned from the card, then this buffer will only contain the SW1 and SW2 status bytes."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcbRecvLength",
        "description": "Supplies the length, in bytes, of the pbRecvBuffer parameter and receives the actual number of bytes received from the smart card.    This value cannot be SCARD_AUTOALLOCATE because SCardTransmit does not support SCARD_AUTOALLOCATE. For T=0, the receive buffer must be at least two bytes long to receive the SW1 and SW2 status bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The SCardWriteCache function writes a name-value pair from a smart card to the global cache maintained by the Smart Card Resource Manager.",
    "library": "Winscard.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winscard.h",
    "return_value": "If the function succeeds, it returns SCARD_S_SUCCESS. If the function fails, it returns one of the following error codes. For more information, see Smart Card Return Values.  ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Authentication",
    "name": "SCardWriteCache",
    "is_callback": 0,
    "dll": "Winscard.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SCARDCONTEXT",
        "name": "hContext",
        "description": "A handle that identifies the resource manager context. The resource manager context is set by a previous call to  SCardEstablishContext."
      },
      {
        "in_out": "_In_",
        "type": "UUID",
        "name": "*CardIdentifier",
        "description": "A pointer to a value that uniquely identifies the smart card from which the name-value pair was read."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "FreshnessCounter",
        "description": "The current revision of the cached data."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "LookupName",
        "description": "A pointer to a null-terminated string that contains the name portion of the name-value pair to write to the global cache."
      },
      {
        "in_out": "_In_",
        "type": "PBYTE",
        "name": "Data",
        "description": "A pointer to an array of byte values that contain the value portion of the name-value pair to write to the global cache."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "DataLen",
        "description": "The size, in bytes, of the Data buffer."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The SaslAcceptSecurityContext function wraps a standard call to the Security Support Provider Interface AcceptSecurityContext (General) function and includes creation of SASL server cookies.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the call is completed successfully, this function returns SEC_E_OK. The following table shows some possible failure return values.  ",
    "remarks": "The final call of the AcceptSecurityContext (General) function that returns SEC_E_OK is identified.  If a return token is produced, SASL processing is suspended for one round trip back to the client to allow the final  token to be processed. After the  exchange is completed, SEC_E_CONTINUE_NEEDED is returned to the application with an additional SASL server cookie encrypted with SSPI message functions. The initial server cookie indicates if INTEGRITY and PRIVACY are supported.  This initial server cookie is processed by the client, and the client returns a client cookie to indicate which services the client requests.  The client cookie is then decrypted by the server and the final services are determined for the following message traffic. ",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SaslAcceptSecurityContext",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCredHandle",
        "name": "phCredential",
        "description": "A handle to the server's credentials. The server calls the  AcquireCredentialsHandle function with the INBOUND flag set to retrieve this handle."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "Pointer to a  CtxtHandle structure. On the first call to AcceptSecurityContext (General), this pointer is NULL. On subsequent calls, phContext is the handle to the partially formed context that was returned in the phNewContext parameter by the first call."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "pInput",
        "description": "Pointer to a  SecBufferDesc structure generated by a client call to  the InitializeSecurityContext (General) function that contains the input buffer descriptor. SASL requires a single buffer of type SECBUFFER_TOKEN. The buffer is empty for the first call to the AcceptSecurityContext (General) function and contains the challenge response received from the client for the second call."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "fContextReq",
        "description": "Bit flags that specify the attributes required by the server to establish the context. Bit flags can be combined using bitwise-OR operations. The following table shows the possible values.  ValueMeaning  ASC_REQ_CONFIDENTIALITY   Encrypt and decrypt messages.  Valid with the Digest SSP for SASL only.   ASC_REQ_HTTP   Use Digest for HTTP. Omit this flag to use Digest as an SASL mechanism."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "TargetDataRep",
        "description": "Indicates the data representation, such as byte ordering, on the target. This value can be either SECURITY_NATIVE_DREP or SECURITY_NETWORK_DREP."
      },
      {
        "in_out": "_Out_",
        "type": "PCtxtHandle",
        "name": "phNewContext",
        "description": "Pointer to a CtxtHandle structure. On the first call to AcceptSecurityContext (General), this pointer receives the new context handle. On subsequent calls, phNewContext can be the same as the handle specified in the phContext parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "pOutput",
        "description": "Pointer to a  SecBufferDesc structure that contains the output buffer descriptor. This buffer is sent to the client for input into additional calls to InitializeSecurityContext (General). An output buffer may be generated even if the function returns SEC_E_OK. Any buffer generated must be sent back to the client application."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned long SEC_FAR",
        "name": "*pfContextAttr",
        "description": "Pointer to a variable that receives a set of bit flags indicating the attributes of the established context. For a description of the various attributes, see  Context Requirements. Flags used for this parameter are prefixed with ASC_RET, such as ASC_RET_DELEGATE. Do not check for security-related attributes until the final function call returns successfully. Attribute flags not related to security, such as the ASC_RET_ALLOCATED_MEMORY flag, can be checked before the final return."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PTimeStamp",
        "name": "ptsExpiry",
        "description": "Pointer to a TimeStamp structure that receives the expiration time of the context. It is recommended that the security package always return this value in local time.     Note  Until the last call of the authentication process, the expiration time for the context can be incorrect because more information will be provided during later stages of the negotiation. Therefore, ptsTimeStamp must be NULL until the last call to the function."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 2,
    "description": "The SaslEnumerateProfiles function lists the packages that provide a SASL interface.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the call is completed successfully, this function returns SEC_E_OK. If the function fails, the return value is a nonzero error code. ",
    "remarks": "The current list is maintained in the registry under A terminating NULL character is appended to the end of the list. ",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SaslEnumerateProfiles",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "*ProfileList",
        "description": "Pointer to a list of Unicode or ANSI strings that contain the names of the packages with SASL wrapper support."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG",
        "name": "*ProfileCount",
        "description": "Pointer to an unsigned LONG value that contains the number of packages with SASL wrapper support."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 5,
    "description": "The SaslGetContextOption function retrieves the specified property of the specified SASL context.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the call is completed successfully, this function returns SEC_E_OK. The following table shows some possible error return values.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SaslGetContextOption",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "ContextHandle",
        "description": "Handle of the SASL context."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Option",
        "description": "Property to return from the SASL context. The following table lists the possible values.  ValueMeaning  SASL_OPTION_AUTHZ_PROCESSING   Data type of buffer: ULONG State of SASL processing of the Authz value provided by the SASL application. The valid states for processing are Sasl_AuthZIDForbidden  and Sasl_AuthZIDProcessed.   SASL_OPTION_AUTHZ_STRING   Data type of buffer: Array of binary characters String of characters passed from the SASL client to the server.  If the AuthZ_Processing state is Sasl_AuthZIDForbidden, the  return value SEC_E_UNSUPPORTED_FUNCTION is returned.   SASL_OPTION_RECV_SIZE   Data type of buffer: ULONG Maximum size of the receiving buffer on the local computer.   SASL_OPTION_SEND_SIZE   Data type of buffer: ULONG Maximum message data size that can be transmitted.  This value is  the maximum buffer size that can be transmitted to the remote SASL process minus the block size, the trailer size, and the maximum signature size."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "Value",
        "description": "A pointer to a buffer that receives the requested property. For the data type of the buffer for each value of the Option parameter, see the Option parameter."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG",
        "name": "Size",
        "description": "The size, in bytes, of the buffer specified by the Value parameter."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PULONG",
        "name": "Needed",
        "description": "A pointer to an unsigned LONG value that returns the value if the buffer specified by the Value parameter is not large enough to contain the data value of the property specified by the Option parameter."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 2,
    "description": "The SaslGetProfilePackage function returns the package information for the specified package.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the call is completed successfully, this function returns SEC_E_OK. The following table shows some possible failure return values.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SaslGetProfilePackage",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "ProfileName",
        "description": "Unicode or ANSI string that contains the name of the SASL package."
      },
      {
        "in_out": "_Out_",
        "type": "PSecPkgInfo",
        "name": "*PackageInfo",
        "description": "Pointer to a pointer to a SecPkgInfo structure that returns the package information for the package specified by the ProfileName parameter."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 2,
    "description": "The SaslIdentifyPackage function returns the  negotiate prefix that matches the specified SASL negotiation buffer.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the call is completed successfully, this function returns SEC_E_OK. If the function fails, the return value is a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SaslIdentifyPackage",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "pInput",
        "description": "Pointer to a SecBufferDesc structure that specifies the SASL negotiation buffer for which to find the negotiate prefix."
      },
      {
        "in_out": "_Out_",
        "type": "PSecPkgInfo",
        "name": "*PackageInfo",
        "description": "Pointer to a pointer to a SecPkgInfo structure that returns the negotiate prefix for the negotiation buffer specified by the pInput parameter."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 12,
    "description": "The SaslInitializeSecurityContext function wraps a standard call to the Security Support Provider Interface InitializeSecurityContext (General) function and processes  SASL server cookies from the server.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the call is completed successfully, this function returns SEC_E_OK. The following table shows some possible failure return values.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SaslInitializeSecurityContext",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCredHandle",
        "name": "phCredential",
        "description": "A handle to the credentials returned by the   AcquireCredentialsHandle function used to build the security context. Using the SaslInitializeSecurityContext function requires at least OUTBOUND credentials."
      },
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "phContext",
        "description": "Pointer to a CtxtHandle structure. On the first call to the SaslInitializeSecurityContext function, this pointer is NULL. On the second call, this parameter is a pointer to the handle to the partially formed context returned in the phNewContext parameter by the first call."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszTargetName",
        "description": "Pointer to a Unicode or ANSI string that indicates the target of the context."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "fContextReq",
        "description": "Bit flags that indicate the requirements of the context.  Flags used for this parameter are prefixed with ISC_REQ_; for example:  ISC_REQ_DELEGATE. Specify  combinations of the following attributes flags.  ValueMeaning  ISC_REQ_REPLAY_DETECT   Detect replayed packets.   ISC_REQ_SEQUENCE_DETECT   Detect messages received out of sequence.   ISC_REQ_CONFIDENTIALITY   Encrypt messages.   ISC_REQ_STREAM   Support a stream-oriented connection.   ISC_REQ_EXTENDED_ERROR   When errors occur, the remote party will be notified.   ISC_REQ_CONNECTION   The security context will not handle formatting messages.   ISC_REQ_MUTUAL_AUTH   Client and server will be authenticated.   ISC_REQ_INTEGRITY   Sign messages and verify signatures.     For  further descriptions of the various attributes, see  Context Requirements."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "Reserved1",
        "description": "Reserved value; must be zero."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "TargetDataRep",
        "description": "Indicates the data representation, such as byte ordering, on the target. Can be either SECURITY_NATIVE_DREP or SECURITY_NETWORK_DREP."
      },
      {
        "in_out": "_In_",
        "type": "PSecBufferDesc",
        "name": "pInput",
        "description": "Pointer to a  SecBufferDesc structure that contains pointers to the buffers supplied as input to the package. The pointer must be NULL on the first call to the function. On subsequent calls to the function, it is a pointer to a buffer allocated with enough memory to hold the token returned by the remote peer.  SASL requires a single buffer of type SECBUFFER_TOKEN that contains the challenge received from the server."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "Reserved2",
        "description": "Reserved value; must be zero."
      },
      {
        "in_out": "_Out_",
        "type": "PCtxtHandle",
        "name": "phNewContext",
        "description": "Pointer to a  CtxtHandle structure. On the first call to the SaslInitializeSecurityContext function, this pointer receives the new context handle. On the second call, phNewContext can be the same as the handle specified in the phContext parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "pOutput",
        "description": "Pointer to a  SecBufferDesc structure that contains pointers to the  SecBuffer structure that receives the output data. If a buffer was typed as SEC_READWRITE in the input, it will be there on output. The system will allocate a buffer for the security token if requested (through ISC_REQ_ALLOCATE_MEMORY) and fill in the address in the buffer descriptor for the security token."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned long SEC_FAR",
        "name": "*pfContextAttr",
        "description": "Pointer to a variable to receive a set of bit flags that indicate the attributes of the established context. For a description of the various attributes, see  Context Requirements.  Flags used for this parameter are prefixed with ISC_RET_, such as ISC_RET_DELEGATE.     For a list of valid values, see the fContextReq parameter. Do not check for security-related attributes until the final function call returns successfully. Attribute flags not related to security, such as the ASC_RET_ALLOCATED_MEMORY flag, can be checked before the final return. Note  Particular context attributes can change during a negotiation with a remote peer."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PTimeStamp",
        "name": "ptsExpiry",
        "description": "Pointer to a TimeStamp structure that receives the expiration time of the context. It is recommended that the security package always return this value in local time. This parameter is optional and NULL should be passed for short-lived clients."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 4,
    "description": "The SaslSetContextOption function sets the value of the specified property for the specified SASL context.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Sspi.h (include Security.h)",
    "return_value": "If the call is completed successfully, this function returns SEC_E_OK. The following table shows some possible error return values.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS SEC_ENTRY",
    "category": "Authentication",
    "name": "SaslSetContextOption",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCtxtHandle",
        "name": "ContextHandle",
        "description": "Handle of the SASL context."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Option",
        "description": "Property to set for the SASL context. The following table lists the possible values.  ValueMeaning  SASL_OPTION_AUTHZ_PROCESSING   Data type of buffer: ULONG State of SASL processing of the Authz value provided by the SASL application. The valid states for processing are Sasl_AuthZIDForbidden  and Sasl_AuthZIDProcessed. The default value is Sasl_AuthZIDProcessed.   SASL_OPTION_AUTHZ_STRING   Data type of buffer: Array of binary characters String of characters passed from the SASL client to the server.  If the AuthZ_Processing state is Sasl_AuthZIDForbidden, the  return value SEC_E_UNSUPPORTED_FUNCTION is returned.   SASL_OPTION_RECV_SIZE   Data type of buffer: ULONG Maximum size of the receiving buffer on the local computer. The default value is 0x0FFFF bytes.   SASL_OPTION_SEND_SIZE   Data type of buffer: ULONG Maximum message data size that can be transmitted.  This value is  the maximum buffer size that can be transmitted to the remote SASL process minus the block size, the trailer size, and the maximum signature size. The default value is 0x0FFFF bytes."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Value",
        "description": "A pointer to a buffer that contains the value to set to  the requested property. For the data type of the buffer for each value of the Option parameter, see the Option parameter."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Size",
        "description": "The size, in bytes, of the buffer specified by the Value parameter."
      }
    ],
    "min_client": "None supported"
  },
  {
    "n_arguments": 2,
    "description": "Adds a security support provider to the list of providers supported by Microsoft Negotiate.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "AddSecurityPackage",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszPackageName",
        "description": "The name of the package to add."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_PACKAGE_OPTIONS",
        "name": "pOptions",
        "description": "A pointer to a SECURITY_PACKAGE_OPTIONS structure that specifies additional information about the security package."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "The ChangeAccountPassword function changes the password for a Windows domain account by using the specified Security Support Provider.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, the function returns SEC_E_OK. If the function fails, it returns an error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "ChangeAccountPassword",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SEC_WCHAR",
        "name": "*pszPackageName",
        "description": "The name of the provider to use. The value of this parameter must be either \"Kerberos\", \"Negotiate\", or \"NTLM\"."
      },
      {
        "in_out": "_In_",
        "type": "SEC_WCHAR",
        "name": "*pszDomainName",
        "description": "The domain of the account for which to change the password."
      },
      {
        "in_out": "_In_",
        "type": "SEC_WCHAR",
        "name": "*pszAccountName",
        "description": "The user name of the account for which to change the password."
      },
      {
        "in_out": "_In_",
        "type": "SEC_WCHAR",
        "name": "*pszOldPassword",
        "description": "The old password to be changed."
      },
      {
        "in_out": "_In_",
        "type": "SEC_WCHAR",
        "name": "*pszNewPassword",
        "description": "The new password for the specified account."
      },
      {
        "in_out": "_In_",
        "type": "BOOLEAN",
        "name": "bImpersonating",
        "description": "TRUE if the calling process is running as the client; otherwise, FALSE."
      },
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "dwReserved",
        "description": "Reserved. Must be set to zero."
      },
      {
        "in_out": "_Inout_",
        "type": "PSecBufferDesc",
        "name": "pOutput",
        "description": "On input, a pointer to a SecBufferDesc structure. The SecBufferDesc structure must contain a single buffer of type SECBUFFER_CHANGE_PASS_RESPONSE. On output, the pvBuffer member of that structure points to a DOMAIN_PASSWORD_INFORMATION structure."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Serializes the specified target into an array of byte values.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "NTSecPkg.h",
    "return_value": "If the function succeeds, it returns STATUS_SUCCESS. If the function fails, it returns an error code that indicates the reason it failed. ",
    "remarks": "",
    "return_type": "NTSTATUS WINAPI",
    "category": "Authentication",
    "name": "CredMarshalTargetInfo",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCREDENTIAL_TARGET_INFORMATIONW",
        "name": "InTargetInfo",
        "description": "A pointer to a Unicode version of the CREDENTIAL_TARGET_INFORMATION structure that specifies the target to serialize."
      },
      {
        "in_out": "_Out_",
        "type": "PUSHORT",
        "name": "*Buffer",
        "description": "The serialized array of byte values that represents the target specified by the InTargetInfo parameter."
      },
      {
        "in_out": "",
        "type": "PULONG",
        "name": "BufferSize",
        "description": "The size, in bytes, of the Buffer array."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Deletes a security support provider from the list of providers supported by Microsoft Negotiate.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "DeleteSecurityPackage",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "pszPackageName",
        "description": "The name of the security provider to delete."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LsaManageSidNameMapping function adds or removes SID/name mappings from the mapping set registered with the LSA Lookup Service.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the mapping is inserted successfully, the return value is STATUS_SUCCESS. Otherwise, if the function fails due to SID or name conflicts, STATUS_INVALID_PARAMETER error will be returned. ",
    "remarks": "",
    "return_type": "void WINAPI",
    "category": "Authentication",
    "name": "LsaManageSidNameMapping",
    "is_callback": 0,
    "dll": "Secur32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SID_NAME_MAPPING_OPERATION_TYPE",
        "name": "OpType",
        "description": "Indicates if a this function is being called to add or remove an SID/name mapping."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_SID_NAME_MAPPING_OPERATION_INPUT",
        "name": "OpInput",
        "description": "Indicates the domain, account, and SID values to use during this operation. Additional flags can also be set within this structure."
      },
      {
        "in_out": "_Out_",
        "type": "PLSA_SID_NAME_MAPPING_OPERATION_OUTPUT",
        "name": "*OpOutput",
        "description": "Contains a value of   LSA_SID_NAME_MAPPING_OPERATION_ERROR that indicates operation success or failure.  ValueMeaning  Success   Operation is complete without error.   NonMappingError   An error unrelated to SID-name mapping has occurred.   NameCollision   Operation failure due to name collision.   SidCollision   Operation failure due to SID collision.   DomainNotFound   Corresponding domain not found.   DomainSidPrefixMismatch   Provided SID doesn't have the correct domain prefix.   MappingNotFound   Mapping not found in the cache."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The LsaOpenPolicy function opens a handle to the Policy object on a local or remote system.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the function returns STATUS_SUCCESS. If the function fails, it returns an NTSTATUS code. For more information, see  LSA Policy Function Return Values. You can use the  LsaNtStatusToWinError function to convert the NTSTATUS code to a Windows error code. ",
    "remarks": "To administer the local security policy of a local or remote system, you must call the LsaOpenPolicy function to establish a session with that system's LSA subsystem. LsaOpenPolicy connects to the LSA of the target system and returns a handle to the Policy object of that system. You can use this handle in subsequent LSA function calls to administer the  local security policy information of the target system. For an example that demonstrates calling this function see  Opening a Policy Object Handle. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaOpenPolicy",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PLSA_UNICODE_STRING",
        "name": "SystemName",
        "description": "A pointer to an  LSA_UNICODE_STRING structure that contains the name of the target system. The name can have the form \"ComputerName\" or \"\\\\ComputerName\". If this parameter is NULL, the function opens the Policy object on the local system."
      },
      {
        "in_out": "_In_",
        "type": "PLSA_OBJECT_ATTRIBUTES",
        "name": "ObjectAttributes",
        "description": "A pointer to an  LSA_OBJECT_ATTRIBUTES structure that specifies the connection attributes. The structure members are not used; initialize them to NULL or zero."
      },
      {
        "in_out": "_In_",
        "type": "ACCESS_MASK",
        "name": "DesiredAccess",
        "description": "An ACCESS_MASK that specifies the requested access rights. The function fails if the DACL of the target system does not allow the caller the requested access. To determine the access rights that you need, see the documentation for the LSA functions with which you want to use the policy handle."
      },
      {
        "in_out": "_Inout_",
        "type": "PLSA_HANDLE",
        "name": "PolicyHandle",
        "description": "A pointer to an  LSA_HANDLE variable that receives a handle to the Policy object. When you no longer need this handle, pass it to the  LsaClose function to close it."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LsaQueryInformationPolicy function retrieves information about a Policy object.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the LsaQueryInformationPolicy function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. You can use the  LsaNtStatusToWinError function to convert the NTSTATUS code to a Windows error code. ",
    "remarks": "For an example that demonstrates calling this function see  Managing Policy Information. ",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaQueryInformationPolicy",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_HANDLE",
        "name": "PolicyHandle",
        "description": "A handle to a Policy object. The required access rights for this handle depend on the value of the InformationClass parameter. For more information, see  Opening a Policy Object Handle."
      },
      {
        "in_out": "_In_",
        "type": "POLICY_INFORMATION_CLASS",
        "name": "InformationClass",
        "description": "Specifies one of the following values from the  POLICY_INFORMATION_CLASS enumeration type. The value indicates the type of information to retrieve.       ValueMeaning  PolicyAuditEventsInformation   Retrieves the system's auditing rules. The handle passed in the PolicyHandle parameter must have the POLICY_VIEW_AUDIT_INFORMATION access right. The Buffer parameter receives a pointer to a  POLICY_AUDIT_EVENTS_INFO structure.   PolicyPrimaryDomainInformation   Retrieves the name and SID of the system's primary domain. The handle passed in the PolicyHandle parameter must have the POLICY_VIEW_LOCAL_INFORMATION access right. The Buffer parameter receives a pointer to a  POLICY_PRIMARY_DOMAIN_INFO structure.   PolicyAccountDomainInformation   Retrieves the name and SID of the system's account domain. The handle passed in the PolicyHandle parameter must have the POLICY_VIEW_LOCAL_INFORMATION access right. The Buffer parameter receives a pointer to a  POLICY_ACCOUNT_DOMAIN_INFO structure.   PolicyLsaServerRoleInformation   Retrieves the role of an LSA server. The handle passed in the PolicyHandle parameter must have the POLICY_VIEW_LOCAL_INFORMATION access right. The Buffer parameter receives a pointer to a  POLICY_LSA_SERVER_ROLE_INFO structure.   PolicyModificationInformation   Retrieves information about the creation time and last modification of the LSA database. The handle passed in the PolicyHandle parameter must have the POLICY_VIEW_LOCAL_INFORMATION access right. The Buffer parameter receives a pointer to a  POLICY_MODIFICATION_INFO structure.   PolicyDnsDomainInformation   Retrieves the Domain Name System (DNS) information about the primary domain associated with the Policy object. The handle passed in the PolicyHandle parameter must have the POLICY_VIEW_LOCAL_INFORMATION access right. The Buffer parameter receives a pointer to a  POLICY_DNS_DOMAIN_INFO structure."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "*Buffer",
        "description": "Pointer to a variable that receives a pointer to a structure containing the requested information. The type of structure depends on the value of the InformationClass parameter.     When you no longer need the information, pass the returned pointer to  LsaFreeMemory."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LsaSetInformationPolicy function modifies information in a Policy object.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Ntsecapi.h",
    "return_value": "If the function succeeds, the return value is STATUS_SUCCESS. If the function fails, the return value is an NTSTATUS code. For more information, see  LSA Policy Function Return Values. You can use the  LsaNtStatusToWinError function to convert the NTSTATUS code to a Windows error code. ",
    "remarks": "",
    "return_type": "NTSTATUS",
    "category": "Authentication",
    "name": "LsaSetInformationPolicy",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_HANDLE",
        "name": "PolicyHandle",
        "description": "A handle to a Policy object. The required access rights for this handle depend on the value of the InformationClass parameter. For more information, see  Opening a Policy Object Handle."
      },
      {
        "in_out": "_In_",
        "type": "POLICY_INFORMATION_CLASS",
        "name": "InformationClass",
        "description": "Specifies one of the following values from the  POLICY_INFORMATION_CLASS enumeration type. The value indicates the type of information to set.      \t\t\t\t\t  ValueMeaning  PolicyAuditEventsInformation   Sets the system's auditing rules. The handle passed in the PolicyHandle parameter must have the POLICY_SET_AUDIT_REQUIREMENTS access right. The Buffer parameter must be a pointer to a  POLICY_AUDIT_EVENTS_INFO structure.   PolicyPrimaryDomainInformation   Sets the name and SID of the system's primary domain. The handle passed in the PolicyHandle parameter must have the POLICY_TRUST_ADMIN access right. The Buffer parameter must be a pointer to a  POLICY_PRIMARY_DOMAIN_INFO structure.   PolicyAccountDomainInformation   Sets the name and SID of the system's account domain. The handle passed in the PolicyHandle parameter must have the POLICY_TRUST_ADMIN access right. The Buffer parameter must be a pointer to a  POLICY_ACCOUNT_DOMAIN_INFO structure.   PolicyDnsDomainInformation   Sets Domain Name System (DNS) information about the primary domain associated with the Policy object. The handle passed in the PolicyHandle parameter must have the POLICY_TRUST_ADMIN access right. The Buffer parameter must be a pointer to a  POLICY_DNS_DOMAIN_INFO structure.   PolicyLsaServerRoleInformation   Sets the role of an LSA server. The handle passed in the PolicyHandle parameter must have the POLICY_SERVER_ADMIN access right. The Buffer parameter must be a pointer to a  POLICY_LSA_SERVER_ROLE_INFO structure. Changing a server's role from primary to backup has no effect (although the function returns STATUS_SUCCESS). Changing a server's role from backup to primary requires extensive network operations and may be slow."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "Buffer",
        "description": "Pointer to a structure containing the information to set. The type of structure depends on the value of the InformationClass parameter."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Enables network vendors to supply their own permission editor dialog boxes.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, the function should return WN_SUCCESS. If the function fails, it should call  SetLastError to set extended error information, which may include the following values.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPFMXEditPerm",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpDriveName",
        "description": "Pointer to the current drive name selected in File Manager."
      },
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hwndFMX",
        "description": "A handle to the FMX window which can be used to query selections."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nType",
        "description": "Specifies the type of permission dialog box to bring up. This parameter can be one of the following values.  ValueMeaning  WNPERM_DLG_PERM   Brings up the Permissions dialog box.   WNPERM_DLG_AUDIT   Brings up the Auditing dialog box.   WNPERM_DLG_OWNER   Brings up the Owner dialog box."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Retrieves the capabilities of the permission editor. The return value is a bitmask that indicates which of the Security menu items in File Manager are to be enabled.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "A bitmask that indicates what permission capability the user has on the selected drive. The bitmask is a combination of the following flags.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPFMXGetPermCaps",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpDriveName",
        "description": "Pointer to the name of the drive currently selected in File Manager."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves the help file and help context of the permission editor dialog boxes when a menu item in the Security menu of File Manager is selected and F1 is pressed.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Npapi.h",
    "return_value": "If the function succeeds, the function should return WN_SUCCESS. If the function fails, it should call  SetLastError to set extended error information, which may include the following values.  ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Authentication",
    "name": "NPFMXGetPermHelp",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpDriveName",
        "description": "Pointer to the name of the drive currently selected in File Manager."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nType",
        "description": "Specifies the menu item in the Security menu of File Manager on which to bring up Help. This can be one of the following values.      \t\t\t\t\t  ValueMeaning  WNPERM_DLG_PERM   Show help on the Permissions menu item.   WNPERM_DLG_AUDIT   Show help on the Auditing menu item.    WNPERM_DLG_OWNER   Show help on the Owner menu item."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fDirectory",
        "description": "Specifies whether the selected item is a directory. This should be set to TRUE if the selected item in File Manager is a directory, and FALSE if it is a file."
      },
      {
        "in_out": "_Inout_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "Pointer to a buffer that will receive the help file name."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpBufferSize",
        "description": "Pointer to a DWORD that specifies the size of the buffer passed in. If lpBuffer is not large enough, on return, this contains the size of buffer needed."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpnHelpContext",
        "description": "Pointer to a DWORD that will receive the help context for the given nType."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves context information from a credential provider.",
    "library": "",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS or an informational status code. If the function fails, return an NTSTATUS error code that indicates the reason it failed. For more information, see Remarks. ",
    "remarks": "A pointer to the SpGetCredUIContextFn function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "SpGetCredUIContextFn",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the context for which to get information."
      },
      {
        "in_out": "_In_",
        "type": "GUID",
        "name": "*CredType",
        "description": "The type of credential specified by the ContextHandle parameter. This can be one of the following values.  ValueMeaning  SEC_WINNT_AUTH_DATA_TYPE_PASSWORD 0x28bfc32f, 0x10f6, 0x4738,  0x98, 0xd1, 0x1a, 0xc0, 0x61, 0xdf, 0x71, 0x6a   The credential is a password.   SEC_WINNT_AUTH_DATA_TYPE_CERT 0x235f69ad, 0x73fb, 0x4dbc,  0x82, 0x3, 0x6, 0x29, 0xe7, 0x39, 0x33, 0x9b   The credential is a certificate.   SEC_WINNT_AUTH_DATA_TYPE_CSP_DATA 0x68fd9879, 0x79c, 0x4dfe,  0x82, 0x81, 0x57, 0x8a, 0xad, 0xc1, 0xc1, 0x0   The credential is authentication data from a cryptographic service provider (CSP)."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "FlatCredUIContextLength",
        "description": "The size, in characters, of the buffer received by the FlatCredUIContext parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "*FlatCredUIContext",
        "description": "A pointer to an array of characters that specifies information about the context specified by the ContextHandle parameter."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Gets metadata from a security support provider (SSP) when it is initiating a security context.",
    "library": "",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS, or an informational status code. If the function fails, return an NTSTATUS error code that indicates the reason it failed. For more information, see Remarks. ",
    "remarks": "A pointer to the SpQueryMetaDataFn function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "SpQueryMetaDataFn",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "CredentialHandle",
        "description": "A handle to the credentials to use for the security context. If the ContextHandle parameter points to NULL on input, this function uses the value of this parameter to create a security context. The value of this parameter  cannot be NULL if the ContextHandle parameter points to NULL on input."
      },
      {
        "in_out": "_In_opt_",
        "type": "PUNICODE_STRING",
        "name": "TargetName",
        "description": "A pointer to a  UNICODE_STRING that contains the name of the target of the context."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ContextRequirements",
        "description": "Flags that indicate the context attributes required by the client.     The following are valid values. Values can be combined by using a logical OR operation.  ValueMeaning  ISC_REQ_DELEGATE   The server is allowed to impersonate the client.   ISC_REQ_MUTUAL_AUTH   Both the client and the server are required to prove their identity.   ISC_REQ_REPLAY_DETECT   The security context will support the detection of replayed packets.   ISC_REQ_SEQUENCE_DETECT   The security context will support the detection of out-of-order messages.   ISC_REQ_USE_SESSION_KEY   A new session key must be negotiated.   ISC_REQ_PROMPT_FOR_CREDS   If the client is an interactive user, the package must, if possible, prompt the user for the appropriate credentials.   ISC_REQ_USE_SUPPLIED_CREDS   The input buffer contains package-specific credential information which should be used to authenticate the connection.   ISC_REQ_ALLOCATE_MEMORY   The package must allocate memory. The caller must eventually call the  FreeContextBuffer function to free memory allocated by the package.   ISC_REQ_USE_DCE_STYLE   The caller expects a three-leg mutual authentication transaction.   ISC_REQ_DATAGRAM   A datagram-type communications channel should be used. For more information, see  Datagram Contexts.   ISC_REQ_CONNECTION   A connection-type communications channel should be used. For more information, see  Connection-Oriented Contexts.   ISC_REQ_EXTENDED_ERROR   If the context fails, generate an error reply message to send back to the client.   ISC_REQ_STREAM   A stream-type communications channel should be used. For more information, see  Stream Contexts.   ISC_REQ_INTEGRITY   Buffer integrity is verified; however, replayed and out-of-sequence messages will not be detected."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG",
        "name": "MetaDataLength",
        "description": "The size, in characters, of the MetaData buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "MetaData",
        "description": "The metadata that the SSP provides."
      },
      {
        "in_out": "_Inout_",
        "type": "PLSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the security handle to use. If this parameter points to NULL on input, this function allocates and initializes a security context by using the values of the CredentialHandle and TargetName parameters. If this parameter points to NULL on input, the CredentialHandle cannot be NULL."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Updates the credentials associated with the specified context.",
    "library": "",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Ntsecpkg.h",
    "return_value": "If the function succeeds, return STATUS_SUCCESS, or an informational status code. If the function fails, return an NTSTATUS error code that indicates the reason it failed. For more information, see Remarks. ",
    "remarks": "A pointer to the SpUpdateCredentialsFn function is available in the  SECPKG_FUNCTION_TABLE structure received from the  SpLsaModeInitialize function. ",
    "return_type": "NTSTATUS NTAPI",
    "category": "Authentication",
    "name": "SpUpdateCredentialsFn",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LSA_SEC_HANDLE",
        "name": "ContextHandle",
        "description": "A handle to the context to update."
      },
      {
        "in_out": "_In_",
        "type": "GUID",
        "name": "*CredType",
        "description": "The type of credential specified by the ContextHandle parameter. This can be one of the following values.  ValueMeaning  SEC_WINNT_AUTH_DATA_TYPE_PASSWORD 0x28bfc32f, 0x10f6, 0x4738,  0x98, 0xd1, 0x1a, 0xc0, 0x61, 0xdf, 0x71, 0x6a   The credential is a password.   SEC_WINNT_AUTH_DATA_TYPE_CERT 0x235f69ad, 0x73fb, 0x4dbc,  0x82, 0x3, 0x6, 0x29, 0xe7, 0x39, 0x33, 0x9b   The credential is a certificate.   SEC_WINNT_AUTH_DATA_TYPE_CSP_DATA 0x68fd9879, 0x79c, 0x4dfe,  0x82, 0x81, 0x57, 0x8a, 0xad, 0xc1, 0xc1, 0x0   The credential is authentication data from a cryptographic service provider (CSP)."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "FlatCredUIContextLength",
        "description": "The size, in characters, of the buffer specified by  the FlatCredUIContext parameter."
      },
      {
        "in_out": "",
        "type": "PUCHAR",
        "name": "FlatCredUIContext",
        "description": "A string that specifies the updated credentials."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Compares the two specified credentials.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiCompareAuthIdentities",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthIdentity1",
        "description": "A pointer to an opaque structure that specifies the first credential to compare."
      },
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthIdentity2",
        "description": "A pointer to an opaque structure that specifies the second credential to compare."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "SameSuppliedUser",
        "description": "TRUE if the user account specified by the AuthIdentity1 parameter is the same as the user account specified by the AuthIdentity2 parameter; otherwise, FALSE."
      },
      {
        "in_out": "_Out_",
        "type": "PBOOLEAN",
        "name": "SameSuppliedIdentity",
        "description": "TRUE if the identity specified by the AuthIdentity1 parameter is the same as the identity specified by the AuthIdentity2 parameter; otherwise, FALSE."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Creates a copy of the specified opaque credential structure.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiCopyAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthData",
        "description": "The credential structure to be copied."
      },
      {
        "in_out": "_Out_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "*AuthDataCopy",
        "description": "The structure that receives the copy of the structure specified by the AuthData parameter."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Decrypts the specified  encrypted credential.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiDecryptAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "EncryptedAuthData",
        "description": "On input, a  pointer to the encrypted credential structure to be decrypted. On output, a pointer to the decrypted credential structure."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Encodes the specified authentication identity as three strings.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. Possible values include, but are not limited to, those in the following table.  ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiEncodeAuthIdentityAsStrings",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "pAuthIdentity",
        "description": "The credential structure to be encoded."
      },
      {
        "in_out": "_Out_",
        "type": "PCWSTR",
        "name": "*ppszUserName",
        "description": "The marshaled user name of the identity specified by the pAuthIdentity parameter. When you have finished using this string, free it by calling the SspiFreeAuthIdentity function."
      },
      {
        "in_out": "_Out_",
        "type": "PCWSTR",
        "name": "*ppszDomainName",
        "description": "The marshaled domain name of the identity specified by the pAuthIdentity parameter. When you have finished using this string, free it by calling the SspiFreeAuthIdentity function."
      },
      {
        "in_out": "_Out_",
        "type": "PCWSTR",
        "name": "*ppszPackedCredentialsString",
        "description": "An encoded string version of a SEC_WINNT_AUTH_IDENTITY_EX2 structure that specifies the users credentials. When you have finished using this string, free it by calling the SspiFreeAuthIdentity function."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Encodes a set of three credential strings as an authentication identity structure.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiEncodeStringsAsAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszUserName",
        "description": "The user name associated with the identity to encode."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszDomainName",
        "description": "The domain name associated with the identity to encode."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszPackedCredentialsString",
        "description": "An encoded string version of a SEC_WINNT_AUTH_IDENTITY_EX2 structure that specifies the user's credentials."
      },
      {
        "in_out": "_Out_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "*ppAuthIdentity",
        "description": "A pointer to the encoded identity structure. When you have finished using this structure, free it by calling the SspiFreeAuthIdentity function."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Encrypts the specified identity structure.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiEncryptAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthData",
        "description": "On input, the identity structure to encrypt. On output, the encrypted identity structure."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a new identity structure that is a copy of  the specified identity structure modified to exclude the specified security support provider (SSP).",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiExcludePackage",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthIdentity",
        "description": "The identity structure to modify."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszPackageName",
        "description": "The SSP to exclude."
      },
      {
        "in_out": "_Out_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "*ppNewAuthIdentity",
        "description": "The modified identity structure."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Frees the memory allocated for the specified identity structure.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiFreeAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthData",
        "description": "The identity structure to free."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves context information from a credential provider.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiGetCredUIContext",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ContextHandle",
        "description": "A pointer to a SEC_WINNT_CREDUI_CONTEXT structure retrieved during a previous call to the SspiUnmarshalCredUIContext function."
      },
      {
        "in_out": "_In_",
        "type": "GUID",
        "name": "*CredType",
        "description": "The type of credential specified by the ContextHandle parameter. This can be one of the following values.  ValueMeaning  SEC_WINNT_AUTH_DATA_TYPE_PASSWORD 0x28bfc32f, 0x10f6, 0x4738,  0x98, 0xd1, 0x1a, 0xc0, 0x61, 0xdf, 0x71, 0x6a   The credential is a password.   SEC_WINNT_AUTH_DATA_TYPE_CERT 0x235f69ad, 0x73fb, 0x4dbc,  0x82, 0x3, 0x6, 0x29, 0xe7, 0x39, 0x33, 0x9b   The credential is a certificate.   SEC_WINNT_AUTH_DATA_TYPE_CSP_DATA 0x68fd9879, 0x79c, 0x4dfe,  0x82, 0x81, 0x57, 0x8a, 0xad, 0xc1, 0xc1, 0x0   The credential is authentication data from a cryptographic service provider (CSP)."
      },
      {
        "in_out": "_In_",
        "type": "LUID",
        "name": "*LogonId",
        "description": "The logon ID associated with the credential specified by the ContextHandle parameter. The caller must be running as LocalSystem to specify a logon ID."
      },
      {
        "in_out": "_Out_",
        "type": "PSEC_WINNT_CREDUI_CONTEXT_VECTOR",
        "name": "*CredUIContexts",
        "description": "A pointer to a SEC_WINNT_CREDUI_CONTEXT_VECTOR structure that specifies the offset and size of the data in the structure specified by the ContextHandle parameter."
      },
      {
        "in_out": "_Out_",
        "type": "HANDLE",
        "name": "*TokenHandle",
        "description": "A handle to the specified user's token."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Gets the host name associated with the specified target.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiGetTargetHostName",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszTargetName",
        "description": "The target for which to get the host name."
      },
      {
        "in_out": "_Out_",
        "type": "PWSTR",
        "name": "*pszHostName",
        "description": "The name of the host associated with the target specified by the pszTargetName parameter."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Indicates whether the specified identity structure is encrypted.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "TRUE if the identity structure specified by the EncryptedAuthData parameter is encrypted; otherwise, FALSE. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Authentication",
    "name": "SspiIsAuthIdentityEncrypted",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "EncryptedAuthData",
        "description": "The identity structure to test."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Indicates whether an error returned after a call to either the InitializeSecurityContext or the AcceptSecurityContext function requires an additional call to the SspiPromptForCredentials function.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "TRUE if the error specified by the ErrorOrNtStatus parameter indicates that an additional call to SspiPromptForCredentials is necessary; otherwise, FALSE. ",
    "remarks": "",
    "return_type": "BOOLEAN",
    "category": "Authentication",
    "name": "SspiIsPromptingNeeded",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "ErrorOrNtStatus",
        "description": "The error to test."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Allows a Security Support Provider Interface (SSPI) application to prompt a user to enter credentials.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiPromptForCredentials",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pszTargetName",
        "description": "The name of the target to use."
      },
      {
        "in_out": "_In_",
        "type": "PCREDUI_INFOW",
        "name": "pUiInfo",
        "description": "A pointer to a CREDUI_INFO structure that contains information for customizing the appearance of the dialog box that this function displays.       If the hwndParent member of the CREDUI_INFO structure is not NULL, this function displays a modal dialog box centered on the parent window. If the hwndParent member of the CREDUI_INFO structure is NULL, the function displays a dialog box centered on the screen. This function ignores the  hbmBanner member of the CREDUI_INFO structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAuthError",
        "description": "A Windows error code, defined in Winerror.h, that is displayed in the dialog box. If credentials previously collected were not valid, the caller uses this parameter to pass the error message from the API that collected the credentials (for example, Winlogon) to this function. The corresponding error message is formatted and displayed in the dialog box. Set the  value of this parameter to zero to display no error message."
      },
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pszPackage",
        "description": "The name of the security package to use."
      },
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "pInputAuthIdentity",
        "description": "An identity structure that is used to populate credential fields in the dialog box. To leave the credential fields empty, set the value of this parameter to NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "*ppAuthIdentity",
        "description": "An identity structure that represents the  credentials this function collects. When you have finished using this structure, free it by calling the SspiFreeAuthIdentity function."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "BOOL",
        "name": "*pfSave",
        "description": "A pointer to a Boolean value that, on input, specifies whether the Save check box is selected in the dialog box that this function displays. On output, the value of this parameter specifies whether the Save check box was selected when the user clicked the Submit button in the dialog box. Set this parameter to NULL to ignore the Save check box. This parameter is ignored if the CREDUIWIN_CHECKBOX flag is not set in the dwFlags parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags that determine the behavior of this function. The following flag is currently defined.  ValueMeaning  SSPIPFC_CREDPROV_DO_NOT_SAVE 0x00000001   The value of the pfSave parameter is ignored, and the credentials collected by this function are not saved. Windows 7 and Windows Server 2008 R2:  The value of the pfSave parameter is ignored, and the credentials collected by this function are not saved. Only the name of this possible value was SSPIPFC_SAVE_CRED_BY_CALLER.    SSPIPFC_NO_CHECKBOX 0x00000002   The value signifies that password and smart card credential providers  will not display the \"Remember my credentials\" checkbox to the user. The SspiPromptForCredentials function passes this flag value, SSPIPFC_NO_CHECKBOX,  in the pvInAuthBuffer parameter of CredUIPromptForWindowsCredentials function."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Frees the memory associated with the specified buffer.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "This function does not return a value. ",
    "remarks": "",
    "return_type": "VOID",
    "category": "Authentication",
    "name": "SspiLocalFree",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "DataBuffer",
        "description": "The buffer to free."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Serializes the specified identity structure into a byte array.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiMarshalAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthIdentity",
        "description": "The identity structure to serialize."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned long",
        "name": "*AuthIdentityLength",
        "description": "The length, in bytes, of the AuthIdentityByteArray array."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned long",
        "name": "*AuthIdentityByteArray",
        "description": "A pointer to an array of byte values that represents the identity specified by the AuthIdentity parameter."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Generates a target name and credential type from the specified identity structure.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiPrepareForCredRead",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthIdentity",
        "description": "The identity structure from which to generate the credentials to be passed to the CredRead function."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszTargetName",
        "description": "A target name that can be modified by this function depending on the value of the AuthIdentity parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pCredmanCredentialType",
        "description": "The credential type to pass to the CredRead function."
      },
      {
        "in_out": "_Out_",
        "type": "PCWSTR",
        "name": "*ppszCredmanTargetName",
        "description": "The target name to pass to the CredRead function."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Generates values from an identity structure that can be passed as the values of parameters in a call to the CredWrite function.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiPrepareForCredWrite",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthIdentity",
        "description": "The identity structure from which to generate the credentials to be passed to the CredWrite function."
      },
      {
        "in_out": "_In_",
        "type": "PCWSTR",
        "name": "pszTargetName",
        "description": "A target name that can be modified by this function depending on the value of the AuthIdentity parameter. Set the value of this parameter to NULL to use the user name as the target."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pCredmanCredentialType",
        "description": "The credential type to pass to the CredWrite function."
      },
      {
        "in_out": "_Out_",
        "type": "PCWSTR",
        "name": "*ppszCredmanTargetName",
        "description": "The target name to pass to the CredWrite function."
      },
      {
        "in_out": "_Out_",
        "type": "PCWSTR",
        "name": "*ppszCredmanUserName",
        "description": "The user name to pass to the CredWrite function."
      },
      {
        "in_out": "_Out_",
        "type": "PUCHAR",
        "name": "*ppCredentialBlob",
        "description": "The credential BLOB to send to the CredWrite function."
      },
      {
        "in_out": "_Out_",
        "type": "PULONG",
        "name": "pCredentialBlobSize",
        "description": "The size, in bytes, of the ppCredentialBlob buffer."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Deserializes the specified array of byte values into an identity structure.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiUnmarshalAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "unsigned long",
        "name": "AuthIdentityLength",
        "description": "The size, in bytes, of the AuthIdentityByteArray array."
      },
      {
        "in_out": "_In_",
        "type": "char",
        "name": "*AuthIdentityByteArray",
        "description": "The array of byte values to deserialize."
      },
      {
        "in_out": "_Out_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "*ppAuthIdentity",
        "description": "The deserialized identity structure."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Deserializes credential information obtained by a credential provider during  a previous call to the ICredentialProvider::SetSerialization method.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiUnmarshalCredUIContext",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "MarshaledCredUIContext",
        "description": "The serialized credential information obtained as the rgbSerialization member of the CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION structure retrieved from a call to the ICredentialProvider::SetSerialization method."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MarshaledCredUIContextLength",
        "description": "The size, in bytes, of the MarshaledCredUIContext buffer."
      },
      {
        "in_out": "_Out_",
        "type": "PSEC_WINNT_CREDUI_CONTEXT",
        "name": "*CredUIContext",
        "description": "A pointer to a SEC_WINNT_CREDUI_CONTEXT structure that specifies the deserialized credential information."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Updates the credentials associated with the specified context.",
    "library": "Credui.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiUpdateCredentials",
    "is_callback": 0,
    "dll": "Credui.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "ContextHandle",
        "description": "A pointer to a SEC_WINNT_CREDUI_CONTEXT structure retrieved during a previous call to the SspiUnmarshalCredUIContext function."
      },
      {
        "in_out": "_In_",
        "type": "GUID",
        "name": "*CredType",
        "description": "The type of credential specified by the ContextHandle parameter. This can be one of the following values.  ValueMeaning  SEC_WINNT_AUTH_DATA_TYPE_PASSWORD 0x28bfc32f, 0x10f6, 0x4738,  0x98, 0xd1, 0x1a, 0xc0, 0x61, 0xdf, 0x71, 0x6a   The credential is a password.   SEC_WINNT_AUTH_DATA_TYPE_CERT 0x235f69ad, 0x73fb, 0x4dbc,  0x82, 0x3, 0x6, 0x29, 0xe7, 0x39, 0x33, 0x9b   The credential is a certificate.   SEC_WINNT_AUTH_DATA_TYPE_CSP_DATA 0x68fd9879, 0x79c, 0x4dfe,  0x82, 0x81, 0x57, 0x8a, 0xad, 0xc1, 0xc1, 0x0   The credential is authentication data from a cryptographic service provider (CSP)."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "FlatCredUIContextLength",
        "description": "The size, in bytes, of the FlatCredUIContext buffer."
      },
      {
        "in_out": "_In_",
        "type": "PUCHAR",
        "name": "FlatCredUIContext",
        "description": "The values with which to update the specified credentials."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Indicates whether the specified identity structure is valid.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK, which indicates that the identity structure specified by the AuthData parameter is valid. If the function fails, it returns a nonzero error code that indicates that the identity structure specified by the AuthData parameter is not valid. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiValidateAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthData",
        "description": "The identity structure to test."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Fills the block of memory associated with the specified identity structure with zeros.",
    "library": "Secur32.lib",
    "min_server": "Windows Server 2008 R2 [desktop apps only]",
    "header": "Sspi.h",
    "return_value": "If the function succeeds, it returns SEC_E_OK. If the function fails, it returns a nonzero error code. ",
    "remarks": "",
    "return_type": "SECURITY_STATUS",
    "category": "Authentication",
    "name": "SspiZeroAuthIdentity",
    "is_callback": 0,
    "dll": "SspiCli.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PSEC_WINNT_AUTH_IDENTITY_OPAQUE",
        "name": "AuthData",
        "description": "The identity structure to fill with zeros."
      }
    ],
    "min_client": "Windows 7 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Called by a replacement  \t\t\t\tGINA DLL to retrieve credentials information if Terminal Services is enabled. \t\t\tThe GINA DLL can then use this information to fill in a logon box automatically and attempt to log the user in.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winwlx.h",
    "return_value": "The WlxQueryTsLogonCredentials function returns one of the following values.  ",
    "remarks": "This function supersedes the WlxQueryClientCredentials and WlxQueryInetConnectorCredentials functions. To access this function, the GINA DLL must use the  WLX_DISPATCH_VERSION_1_4 structure and set the Winlogon version to at least WLX_VERSION_1_4 in its  WlxNegotiate call. Other Winlogon support functions that may be called when Terminal Services is enabled are WlxDisconnect, WlxQueryClientCredentials, WlxQueryTerminalServicesData, and  WlxWin31Migrate. ",
    "return_type": "BOOL",
    "category": "Authentication",
    "name": "WlxQueryTsLogonCredentials",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PWLX_CLIENT_CREDENTIALS_INFO_V2_0",
        "name": "pCred",
        "description": "When the return value is TRUE, pCred specifies a pointer to a WLX_CLIENT_CREDENTIALS_INFO_V2_0 structure that contains the credentials to use for auto logon."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  }
]

