[
  {
    "n_arguments": 2,
    "description": "The CopyRect function copies the coordinates of one rectangle to another.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. For an example, see Using Rectangles. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "CopyRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprcDst",
        "description": "Pointer to the RECT structure that receives the logical coordinates of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprcSrc",
        "description": "Pointer to the RECT structure whose coordinates are to be copied in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The EqualRect function determines whether the two specified rectangles are equal by comparing the coordinates of their upper-left and lower-right corners.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the two rectangles are identical, the return value is nonzero. If the two rectangles are not identical, the return value is zero. ",
    "remarks": "The EqualRect function does not treat empty rectangles as equal if their coordinates are different. Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "EqualRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc1",
        "description": "Pointer to a RECT structure that contains the logical coordinates of the first rectangle."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc2",
        "description": "Pointer to a RECT structure that contains the logical coordinates of the second rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The InflateRect function increases or decreases the width and height of the specified rectangle. The InflateRect function adds dx units to the left and right ends of the rectangle and dy units to the top and bottom. The dx and dy parameters are signed values; positive values increase the width and height, and negative values decrease them.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "InflateRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPRECT",
        "name": "lprc",
        "description": "A pointer to the RECT structure that increases or decreases in size."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "dx",
        "description": "The amount to increase or decrease the rectangle width. This parameter must be negative to decrease the width."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "dy",
        "description": "The amount to increase or decrease the rectangle height. This parameter must be negative to decrease the height."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The IntersectRect function calculates the intersection of two source rectangles and places the coordinates of the intersection rectangle into the destination rectangle. If the source rectangles do not intersect, an empty rectangle (in which all coordinates are set to zero) is placed into the destination rectangle.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the rectangles intersect, the return value is nonzero. If the rectangles do not intersect, the return value is zero. ",
    "remarks": "Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. For an example, see Using Rectangles. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "IntersectRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprcDst",
        "description": "A pointer to the RECT structure that is to receive the intersection of the rectangles pointed to by the lprcSrc1 and lprcSrc2 parameters. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprcSrc1",
        "description": "A pointer to the RECT structure that contains the first source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprcSrc2",
        "description": "A pointer to the RECT structure that contains the second source rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The IsRectEmpty function determines whether the specified rectangle is empty. An empty rectangle is one that has no area; that is, the coordinate of the right side is less than or equal to the coordinate of the left side, or the coordinate of the bottom side is less than or equal to the coordinate of the top side.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the rectangle is empty, the return value is nonzero. If the rectangle is not empty, the return value is zero. ",
    "remarks": "Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. For an example, see Using Rectangles. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "IsRectEmpty",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "Pointer to a RECT structure that contains the logical coordinates of the rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The OffsetRect function moves the specified rectangle by the specified offsets.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. For an example, see Using Rectangles. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "OffsetRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPRECT",
        "name": "lprc",
        "description": "Pointer to a RECT structure that contains the logical coordinates of the rectangle to be moved."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "dx",
        "description": "Specifies the amount to move the rectangle left or right. This parameter must be a negative value to move the rectangle to the left."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "dy",
        "description": "Specifies the amount to move the rectangle up or down. This parameter must be a negative value to move the rectangle up."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The PtInRect function determines whether the specified point lies within the specified rectangle. A point is within a rectangle if it lies on the left or top side or is within all four sides. A point on the right or bottom side is considered outside the rectangle.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the specified point lies within the rectangle, the return value is nonzero. If the specified point does not lie within the rectangle, the return value is zero. ",
    "remarks": "The rectangle must be normalized before PtInRect is called. That is, lprc.right must be greater than lprc.left and lprc.bottom must be greater than lprc.top. If the rectangle is not normalized, a point is never considered inside of the rectangle. Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. For an example, see Using Rectangles. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PtInRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "A pointer to a RECT structure that contains the specified rectangle."
      },
      {
        "in_out": "_In_",
        "type": "POINT",
        "name": "pt",
        "description": "A POINT structure that contains the specified point."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The SetRect function sets the coordinates of the specified rectangle. This is equivalent to assigning the left, top, right, and bottom arguments to the appropriate members of the RECT structure.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. For an example, see Using Rectangles. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprc",
        "description": "Pointer to the RECT structure that contains the rectangle to be set."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xLeft",
        "description": "Specifies the x-coordinate of the rectangle's upper-left corner."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yTop",
        "description": "Specifies the y-coordinate of the rectangle's upper-left corner."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xRight",
        "description": "Specifies the x-coordinate of the rectangle's lower-right corner."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yBottom",
        "description": "Specifies the y-coordinate of the rectangle's lower-right corner."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SetRectEmpty function creates an empty rectangle in which all coordinates are set to zero.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. For an example, see Using Rectangles. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetRectEmpty",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprc",
        "description": "Pointer to the RECT structure that contains the coordinates of the rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SubtractRect function determines the coordinates of a rectangle formed by subtracting one rectangle from another.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the resulting rectangle is empty, the return value is zero. If the resulting rectangle is not empty, the return value is nonzero. ",
    "remarks": "The function only subtracts the rectangle specified by lprcSrc2 from the rectangle specified by lprcSrc1 when the rectangles intersect completely in either the x- or y-direction. For example, if *lprcSrc1 has the coordinates (10,10,100,100) and *lprcSrc2 has the coordinates (50,50,150,150), the function sets the coordinates of the rectangle pointed to by lprcDst to (10,10,100,100). If *lprcSrc1 has the coordinates (10,10,100,100) and *lprcSrc2 has the coordinates (50,10,150,150), however, the function sets the coordinates of the rectangle pointed to by lprcDst to (10,10,50,100). In other words, the resulting rectangle is the bounding box of the geometric difference. Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SubtractRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprcDst",
        "description": "A pointer to a RECT structure that receives the coordinates of the rectangle determined by subtracting the rectangle pointed to by lprcSrc2 from the rectangle pointed to by lprcSrc1."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprcSrc1",
        "description": "A pointer to a RECT structure from which the function subtracts the rectangle pointed to by lprcSrc2."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprcSrc2",
        "description": "A pointer to a RECT structure that the function subtracts from the rectangle pointed to by lprcSrc1."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The UnionRect function creates the union of two rectangles. The union is the smallest rectangle that contains both source rectangles.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the specified structure contains a nonempty rectangle, the return value is nonzero. If the specified structure does not contain a nonempty rectangle, the return value is zero. ",
    "remarks": "The system ignores the dimensions of an empty rectangle that is, a rectangle in which all coordinates are set to zero, so that it has no height or no width. Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "UnionRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprcDst",
        "description": "A pointer to the RECT structure that will receive a rectangle containing the rectangles pointed to by the lprcSrc1 and lprcSrc2 parameters."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprcSrc1",
        "description": "A pointer to the RECT structure that contains the first source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprcSrc2",
        "description": "A pointer to the RECT structure that contains the second source rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CombineRgn function combines two regions and stores the result in a third region. The two regions are combined according to the specified mode.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the type of the resulting region. It can be one of the following values.  ",
    "remarks": "The three regions need not be distinct. For example, the hrgnSrc1 parameter can equal the hrgnDest parameter. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "CombineRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgnDest",
        "description": "A handle to a new region with dimensions defined by combining two other regions. (This region must exist before CombineRgn is called.)"
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgnSrc1",
        "description": "A handle to the first of two regions to be combined."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgnSrc2",
        "description": "A handle to the second of two regions to be combined."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "fnCombineMode",
        "description": "A mode indicating how the two regions will be combined. This parameter can be one of the following values.  ValueMeaning  RGN_AND   Creates the intersection of the two combined regions.   RGN_COPY   Creates a copy of the region identified by hrgnSrc1.   RGN_DIFF   Combines the parts of hrgnSrc1 that are not part of hrgnSrc2.   RGN_OR   Creates the union of two combined regions.   RGN_XOR   Creates the union of two combined regions except for any overlapping areas."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CreateEllipticRgn function creates an elliptical region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the region. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the HRGN object, call the DeleteObject function to delete it. A bounding rectangle defines the size, shape, and orientation of the region: The long sides of the rectangle define the length of the ellipse's major axis; the short sides define the length of the ellipse's minor axis; and the center of the rectangle defines the intersection of the major and minor axes. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "CreateEllipticRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "Specifies the x-coordinate in logical units, of the upper-left corner of the bounding rectangle of the ellipse."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "Specifies the y-coordinate in logical units, of the upper-left corner of the bounding rectangle of the ellipse."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "Specifies the x-coordinate in logical units, of the lower-right corner of the bounding rectangle of the ellipse."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "Specifies the y-coordinate in logical units, of the lower-right corner of the bounding rectangle of the ellipse."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateEllipticRgnIndirect function creates an elliptical region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the region. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the HRGN object, call the DeleteObject function to delete it. A bounding rectangle defines the size, shape, and orientation of the region: The long sides of the rectangle define the length of the ellipse's major axis; the short sides define the length of the ellipse's minor axis; and the center of the rectangle defines the intersection of the major and minor axes. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "CreateEllipticRgnIndirect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "Pointer to a RECT structure that contains the coordinates of the upper-left and lower-right corners of the bounding rectangle of the ellipse in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CreatePolygonRgn function creates a polygonal region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the region. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the HRGN object, call the DeleteObject function to delete it. Region coordinates are represented as 27-bit signed integers. Regions created by the Create<shape>Rgn methods (such as CreateRectRgn and CreatePolygonRgn) only include the interior of the shape; the shape's outline is excluded from the region. This means that any point on a line between two sequential vertices is not included in the region. If you were to call PtInRegion for such a point, it would return zero as the result. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "CreatePolygonRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures that define the vertices of the polygon in logical units. The polygon is presumed closed. Each vertex can be specified only once."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cPoints",
        "description": "The number of points in the array."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "fnPolyFillMode",
        "description": "The fill mode used to determine which pixels are in the region. This parameter can be one of the following values.  ValueMeaning  ALTERNATE   Selects alternate mode (fills area between odd-numbered and even-numbered polygon sides on each scan line).   WINDING   Selects winding mode (fills any region with a nonzero winding value).     For more information about these modes, see the SetPolyFillMode function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CreatePolyPolygonRgn function creates a region consisting of a series of polygons. The polygons can overlap.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the region. If the function fails, the return value is zero. ",
    "remarks": "When you no longer need the HRGN object, call the DeleteObject function to delete it. Region coordinates are represented as 27-bit signed integers. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "CreatePolyPolygonRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures that define the vertices of the polygons in logical units. The polygons are specified consecutively. Each polygon is presumed closed and each vertex is specified only once."
      },
      {
        "in_out": "_In_",
        "type": "const INT*",
        "name": "lpPolyCounts",
        "description": "A pointer to an array of integers, each of which specifies the number of points in one of the polygons in the array pointed to by lppt."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The total number of integers in the array pointed to by lpPolyCounts."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "fnPolyFillMode",
        "description": "The fill mode used to determine which pixels are in the region. This parameter can be one of the following values.  ValueMeaning  ALTERNATE   Selects alternate mode (fills area between odd-numbered and even-numbered polygon sides on each scan line).   WINDING   Selects winding mode (fills any region with a nonzero winding value).     For more information about these modes, see the SetPolyFillMode function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CreateRectRgn function creates a rectangular region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the region. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the HRGN object, call the DeleteObject function to delete it. Region coordinates are represented as 27-bit signed integers. Regions created by the Create<shape>Rgn methods (such as CreateRectRgn and CreatePolygonRgn) only include the interior of the shape; the shape's outline is excluded from the region. This means that any point on a line between two sequential vertices is not included in the region. If you were to call PtInRegion for such a point, it would return zero as the result. For an example, see Drawing Markers. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "CreateRectRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "Specifies the x-coordinate of the upper-left corner of the region in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "Specifies the y-coordinate of the upper-left corner of the region in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "Specifies the x-coordinate of the lower-right corner of the region in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "Specifies the y-coordinate of the lower-right corner of the region in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateRectRgnIndirect function creates a rectangular region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the region. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the HRGN object, call the DeleteObject function to delete it. Region coordinates are represented as 27-bit signed integers. The region will be exclusive of the bottom and right edges. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "CreateRectRgnIndirect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "Pointer to a RECT structure that contains the coordinates of the upper-left and lower-right corners of the rectangle that defines the region in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The CreateRoundRectRgn function creates a rectangular region with rounded corners.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the region. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the HRGN object call the DeleteObject function to delete it. Region coordinates are represented as 27-bit signed  integers. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "CreateRoundRectRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "Specifies the x-coordinate of the upper-left corner of the region in device units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "Specifies the y-coordinate of the upper-left corner of the region in device units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "Specifies the x-coordinate of the lower-right corner of the region in device units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "Specifies the y-coordinate of the lower-right corner of the region in device units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidthEllipse",
        "description": "Specifies the width of the ellipse used to create the rounded corners in device units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeightEllipse",
        "description": "Specifies the height of the ellipse used to create the rounded corners in device units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The EqualRgn function checks the two specified regions to determine whether they are identical. The function considers two regions identical if they are equal in size and shape.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the two regions are equal, the return value is nonzero. If the two regions are not equal, the return value is zero. A return value of ERROR means at least one of the region handles is invalid. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "EqualRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hSrcRgn1",
        "description": "Handle to a region."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hSrcRgn2",
        "description": "Handle to a region."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The ExtCreateRegion function creates a region from the specified region and transformation data.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the value of the region. If the function fails, the return value is NULL. ",
    "remarks": "Region coordinates are represented as 27-bit signed integers. An application can retrieve data for a region by calling the GetRegionData function. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "ExtCreateRegion",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const XFORM*",
        "name": "lpXform",
        "description": "A pointer to an XFORM structure that defines the transformation to be performed on the region. If this pointer is NULL, the identity transformation is used."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nCount",
        "description": "The number of bytes pointed to by lpRgnData."
      },
      {
        "in_out": "_In_",
        "type": "const RGNDATA*",
        "name": "lpRgnData",
        "description": "A pointer to a RGNDATA structure that contains the region data in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The FillRgn function fills a region by using the specified brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "FillRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region to be filled. The region's coordinates are presumed to be in logical units."
      },
      {
        "in_out": "_In_",
        "type": "HBRUSH",
        "name": "hbr",
        "description": "Handle to the brush to be used to fill the region."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The FrameRgn function draws a border around the specified region by using the specified brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "FrameRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region to be enclosed in a border. The region's coordinates are presumed to be in logical units."
      },
      {
        "in_out": "_In_",
        "type": "HBRUSH",
        "name": "hbr",
        "description": "Handle to the brush to be used to draw the border."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "Specifies the width, in logical units, of vertical brush strokes."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "Specifies the height, in logical units, of horizontal brush strokes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetPolyFillMode function retrieves the current polygon fill mode.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the polygon fill mode, which can be one of the following values.  If an error occurs, the return value is zero. ",
    "remarks": "",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetPolyFillMode",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetRegionData function fills the specified buffer with data describing a region. This data includes the dimensions of the rectangles that make up the region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds and dwCount specifies an adequate number of bytes, the return value is always dwCount. If dwCount is too small or the function fails, the return value is 0. If lpRgnData is NULL, the return value is the required number of bytes. If the function fails, the return value is zero. ",
    "remarks": "The GetRegionData function is used in conjunction with the ExtCreateRegion function. ",
    "return_type": "DWORD",
    "category": "Windows GDI",
    "name": "GetRegionData",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hRgn",
        "description": "A handle to the region."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwCount",
        "description": "The size, in bytes, of the lpRgnData buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPRGNDATA",
        "name": "lpRgnData",
        "description": "A pointer to a RGNDATA structure that receives the information. The dimensions of the region are in logical units. If this parameter is NULL, the return value contains the number of bytes needed for the region data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetRgnBox function retrieves the bounding rectangle of the specified region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the region's complexity. It can be one of the following values:  If the hrgn parameter does not identify a valid region, the return value is zero. ",
    "remarks": "",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetRgnBox",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "A handle to the region."
      },
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprc",
        "description": "A pointer to a RECT structure that receives the bounding rectangle in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The InvertRgn function inverts the colors in the specified region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "On monochrome screens, the InvertRgn function makes white pixels black and black pixels white. On color screens, this inversion is dependent on the type of technology used to generate the colors for the screen. For an example, see Using Brushes. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "InvertRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region for which colors are inverted. The region's coordinates are presumed to be logical coordinates."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The OffsetRgn function moves a region by the specified offsets.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the new region's complexity. It can be one of the following values.  ",
    "remarks": "",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "OffsetRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region to be moved."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXOffset",
        "description": "Specifies the number of logical units to move left or right."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYOffset",
        "description": "Specifies the number of logical units to move up or down."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The PaintRgn function paints the specified region by using the brush currently selected into the device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PaintRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region to be filled. The region's coordinates are presumed to be logical coordinates."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The PtInRegion function determines whether the specified point is inside the specified region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the specified point is in the region, the return value is nonzero. If the specified point is not in the region, the return value is zero. For an example, see Drawing Markers. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PtInRegion",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region to be examined."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "Specifies the x-coordinate of the point in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "Specifies the y-coordinate of the point in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The RectInRegion function determines whether any part of the specified rectangle is within the boundaries of a region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If any part of the specified rectangle lies within the boundaries of the region, the return value is nonzero. If no part of the specified rectangle lies within the boundaries of the region, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "RectInRegion",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "Pointer to a RECT structure containing the coordinates of the rectangle in logical units. The lower and right edges of the rectangle are not included."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetPolyFillMode function sets the polygon fill mode for functions that fill polygons.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the previous filling mode. If an error occurs, the return value is zero. ",
    "remarks": "In general, the modes differ only in cases where a complex, overlapping polygon must be filled (for example, a five-sided polygon that forms a five-pointed star with a pentagon in the center). In such cases, ALTERNATE mode fills every other enclosed region within the polygon (that is, the points of the star), but WINDING mode fills all regions (that is, the points and the pentagon). When the fill mode is ALTERNATE, GDI fills the area between odd-numbered and even-numbered polygon sides on each scan line. That is, GDI fills the area between the first and second side, between the third and fourth side, and so on. When the fill mode is WINDING, GDI fills any region that has a nonzero winding value. This value is defined as the number of times a pen used to draw the polygon would go around the region. The direction of each edge of the polygon is important. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "SetPolyFillMode",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "iPolyFillMode",
        "description": "The new fill mode. This parameter can be one of the following values.  ValueMeaning  ALTERNATE   Selects alternate mode (fills the area between odd-numbered and even-numbered polygon sides on each scan line).   WINDING   Selects winding mode (fills any region with a nonzero winding value)."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The SetRectRgn function converts a region into a rectangular region with the specified coordinates.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The region does not include the lower and right boundaries of the rectangle. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetRectRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "Handle to the region."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "Specifies the x-coordinate of the upper-left corner of the rectangular region in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "Specifies the y-coordinate of the upper-left corner of the rectangular region in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "Specifies the x-coordinate of the lower-right corner of the rectangular region in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "Specifies the y-coordinate of the lower-right corner of the rectangular region in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CreatePen function creates a logical pen that has the specified style, width, and color. The pen can subsequently be selected into a device context and used to draw lines and curves.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle that identifies a logical pen. If the function fails, the return value is NULL. ",
    "remarks": "After an application creates a logical pen, it can select that pen into a device context by calling the SelectObject function. After a pen is selected into a device context, it can be used to draw lines and curves. If the value specified by the nWidth parameter is zero, a line drawn with the created pen always is a single pixel wide regardless of the current transformation. If the value specified by nWidth is greater than 1, the fnPenStyle parameter must be PS_NULL, PS_SOLID, or PS_INSIDEFRAME. If the value specified by nWidth is greater than 1 and fnPenStyle is PS_INSIDEFRAME, the line associated with the pen is drawn inside the frame of all primitives except polygons and polylines. If the value specified by nWidth is greater than 1, fnPenStyle is PS_INSIDEFRAME, and the color specified by the crColor parameter does not match one of the entries in the logical palette, the system draws lines by using a dithered color. Dithered colors are not available with solid pens. When you no longer need the pen, call the DeleteObject function to delete it. ICM: No color management is done at creation. However, color management is performed when the pen is selected into an ICM-enabled device context. For an example, see Creating Colored Pens and Brushes. ",
    "return_type": "HPEN",
    "category": "Windows GDI",
    "name": "CreatePen",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "fnPenStyle",
        "description": "The pen style. It can be any one of the following values.  ValueMeaning  PS_SOLID   The pen is solid.   PS_DASH   The pen is dashed. This style is valid only when the pen width is one or less in device units.   PS_DOT   The pen is dotted. This style is valid only when the pen width is one or less in device units.   PS_DASHDOT   The pen has alternating dashes and dots. This style is valid only when the pen width is one or less in device units.   PS_DASHDOTDOT   The pen has alternating dashes and double dots. This style is valid only when the pen width is one or less in device units.   PS_NULL   The pen is invisible.   PS_INSIDEFRAME   The pen is solid. When this pen is used in any GDI drawing function that takes a bounding rectangle, the dimensions of the figure are shrunk so that it fits entirely in the bounding rectangle, taking into account the width of the pen. This applies only to geometric pens."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width of the pen, in logical units. If nWidth is zero, the pen is a single pixel wide, regardless of the current transformation. CreatePen returns a pen with the specified width bit with the PS_SOLID style if you specify a width greater than one for the following styles: PS_DASH, PS_DOT, PS_DASHDOT, PS_DASHDOTDOT."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "A color reference for the pen color. To generate a COLORREF structure, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreatePenIndirect function creates a logical cosmetic pen that has the style, width, and color specified in a structure.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle that identifies a logical cosmetic pen. If the function fails, the return value is NULL. ",
    "remarks": "After an application creates a logical pen, it can select that pen into a device context by calling the SelectObject function. After a pen is selected into a device context, it can be used to draw lines and curves. When you no longer need the pen, call the DeleteObject function to delete it. ",
    "return_type": "HPEN",
    "category": "Windows GDI",
    "name": "CreatePenIndirect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const LOGPEN*",
        "name": "lplgpn",
        "description": "Pointer to a LOGPEN structure that specifies the pen's style, width, and color."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The ExtCreatePen function creates a logical cosmetic or geometric pen that has the specified style, width, and brush attributes.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle that identifies a logical pen. If the function fails, the return value is zero. ",
    "remarks": "A geometric pen can have any width and can have any of the attributes of a brush, such as dithers and patterns. A cosmetic pen can only be a single pixel wide and must be a solid color, but cosmetic pens are generally faster than geometric pens. The width of a geometric pen is always specified in world units. The width of a cosmetic pen is always 1. End caps and joins are only specified for geometric pens. After an application creates a logical pen, it can select that pen into a device context by calling the SelectObject function. After a pen is selected into a device context, it can be used to draw lines and curves. If dwPenStyle is PS_COSMETIC and PS_USERSTYLE, the entries in the lpStyle array specify lengths of dashes and spaces in style units. A style unit is defined by the device where the pen is used to draw a line. If dwPenStyle is PS_GEOMETRIC and PS_USERSTYLE, the entries in the lpStyle array specify lengths of dashes and spaces in logical units. If dwPenStyle is PS_ALTERNATE, the style unit is ignored and every other pixel is set. If the lbStyle member of the LOGBRUSH structure pointed to by lplb is BS_PATTERN, the bitmap pointed to by the lbHatch member of that structure cannot be a DIB section. A DIB section is a bitmap created by CreateDIBSection. If that bitmap is a DIB section, the ExtCreatePen function fails. When an application no longer requires a specified pen, it should call the DeleteObject function to delete the pen. ICM: No color management is done at pen creation. However, color management is performed when the pen is selected into an ICM-enabled device context. For an example, see Using Pens. ",
    "return_type": "HPEN",
    "category": "Windows GDI",
    "name": "ExtCreatePen",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwPenStyle",
        "description": "A combination of type, style, end cap, and join attributes. The values from each category are combined by using the bitwise OR operator ( | ). The pen type can be one of the following values.  ValueMeaning  PS_GEOMETRIC   The pen is geometric.   PS_COSMETIC   The pen is cosmetic.     The pen style can be one of the following values.  ValueMeaning  PS_ALTERNATE   The pen sets every other pixel. (This style is applicable only for cosmetic pens.)   PS_SOLID   The pen is solid.   PS_DASH   The pen is dashed.   PS_DOT   The pen is dotted.   PS_DASHDOT   The pen has alternating dashes and dots.   PS_DASHDOTDOT   The pen has alternating dashes and double dots.   PS_NULL   The pen is invisible.   PS_USERSTYLE   The pen uses a styling array supplied by the user.   PS_INSIDEFRAME   The pen is solid. When this pen is used in any GDI drawing function that takes a bounding rectangle, the dimensions of the figure are shrunk so that it fits entirely in the bounding rectangle, taking into account the width of the pen. This applies only to geometric pens.     The end cap is only specified for geometric pens. The end cap can be one of the following values.  ValueMeaning  PS_ENDCAP_ROUND   End caps are round.   PS_ENDCAP_SQUARE   End caps are square.   PS_ENDCAP_FLAT   End caps are flat.     The join is only specified for geometric pens. The join can be one of the following values.  ValueMeaning  PS_JOIN_BEVEL   Joins are beveled.   PS_JOIN_MITER   Joins are mitered when they are within the current limit set by the SetMiterLimit function. If it exceeds this limit, the join is beveled.   PS_JOIN_ROUND   Joins are round."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwWidth",
        "description": "The width of the pen. If the dwPenStyle parameter is PS_GEOMETRIC, the width is given in logical units. If dwPenStyle is PS_COSMETIC, the width must be set to 1."
      },
      {
        "in_out": "_In_",
        "type": "const LOGBRUSH*",
        "name": "lplb",
        "description": "A pointer to a LOGBRUSH structure. If dwPenStyle is PS_COSMETIC, the lbColor member specifies the color of the pen and the lpStyle member must be set to BS_SOLID. If dwPenStyle is PS_GEOMETRIC, all members must be used to specify the brush attributes of the pen."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwStyleCount",
        "description": "The length, in DWORD units, of the lpStyle array. This value must be zero if dwPenStyle is not PS_USERSTYLE. The style count is limited to 16."
      },
      {
        "in_out": "_In_",
        "type": "const DWORD*",
        "name": "lpStyle",
        "description": "A pointer to an array. The first value specifies the length of the first dash in a user-defined style, the second value specifies the length of the first space, and so on. This pointer must be NULL if dwPenStyle is not PS_USERSTYLE. If the lpStyle array is exceeded during line drawing, the pointer is reset to the beginning of the array. When this happens and dwStyleCount is an even number, the pattern of dashes and spaces repeats. However, if dwStyleCount is odd, the pattern reverses when the pointer is reset -- the first element of lpStyle now refers to spaces, the second refers to dashes, and so forth."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The AbortPath function closes and discards any paths in the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "If there is an open path bracket in the given device context, the path bracket is closed and the path is discarded. If there is a closed path in the device context, the path is discarded. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "AbortPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context from which a path will be discarded."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The BeginPath function opens a path bracket in the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "After a path bracket is open, an application can begin calling GDI drawing functions to define the points that lie in the path. An application can close an open path bracket by calling the EndPath function. When an application calls BeginPath for a device context, any previous paths are discarded from that device context. The following list shows which drawing functions can be used. For an example, see Using Paths. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "BeginPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CloseFigure function closes an open figure in a path.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The CloseFigure function closes the figure by drawing a line from the current position to the first point of the figure (usually, the point specified by the most recent call to the MoveToEx function) and then connects the lines by using the line join style. If a figure is closed by using the LineTo function instead of CloseFigure, end caps are used to create the corner instead of a join. The CloseFigure function should only be called if there is an open path bracket in the specified device context. A figure in a path is open unless it is explicitly closed by using this function. (A figure can be open even if the current point and the starting point of the figure are the same.) After a call to CloseFigure, adding a line or curve to the path starts a new figure. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "CloseFigure",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context in which the figure will be closed."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The EndPath function closes a path bracket and selects the path defined by the bracket into the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.  If the function fails,                              GetLastError may return one of the following error codes:  If the function fails,                              GetLastError may return one of the following error codes: For an example, see Using Paths. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "EndPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context into which the new path is selected."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The FillPath function closes any open figures in the current path and fills the path's interior by using the current brush and polygon-filling mode.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.  If the function fails,                              GetLastError may return one of the following error codes:  If the function fails,                              GetLastError may return one of the following error codes: ",
    "remarks": "After its interior is filled, the path is discarded from the DC identified by the hdc parameter. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "FillPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context that contains a valid path."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The FlattenPath function transforms any curves in the path that is selected into the current device context (DC), turning each curve into a sequence of lines.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.  If the function fails,                              GetLastError may return one of the following error codes:  If the function fails,                              GetLastError may return one of the following error codes: ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "FlattenPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a DC that contains a valid path."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetMiterLimit function retrieves the miter limit for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The miter limit is used when drawing geometric lines that have miter joins. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "GetMiterLimit",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_Out_",
        "type": "PFLOAT",
        "name": "peLimit",
        "description": "Pointer to a floating-point value that receives the current miter limit."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetPath function retrieves the coordinates defining the endpoints of lines and the control points of curves found in the path that is selected into the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the nSize parameter is nonzero, the return value is the number of points enumerated. If nSize is 0, the return value is the total number of points in the path (and GetPath writes nothing to the buffers). If nSize is nonzero and is less than the number of points in the path, the return value is 1.  If the function fails,                              GetLastError may return one of the following error codes:  If the function fails,                              GetLastError may return one of the following error codes: ",
    "remarks": "The device context identified by the hdc parameter must contain a closed path. The points of the path are returned in logical coordinates. Points are stored in the path in device coordinates, so GetPath changes the points from device coordinates to logical coordinates by using the inverse of the current transformation. The FlattenPath function may be called before GetPath to convert all curves in the path into line segments. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context that contains a closed path."
      },
      {
        "in_out": "_Out_",
        "type": "LPPOINT",
        "name": "lpPoints",
        "description": "A pointer to an array of POINT structures that receives the line endpoints and curve control points, in logical coordinates."
      },
      {
        "in_out": "_Out_",
        "type": "LPBYTE",
        "name": "lpTypes",
        "description": "A pointer to an array of bytes that receives the vertex types. ..."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nSize",
        "description": "The total number of POINT structures that can be stored in the array pointed to by lpPoints. This value must be the same as the number of bytes that can be placed in the array pointed to by lpTypes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The PathToRegion function creates a region from the path that is selected into the specified device context. The resulting region uses device coordinates.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a valid region. If the function fails, the return value is zero.  If the function fails, GetLastError may return one of the following error codes:  If the function fails, GetLastError may return one of the following error codes: ",
    "remarks": "When you no longer need the HRGN object call the DeleteObject function to delete it. The device context identified by the hdc parameter must contain a closed path. After PathToRegion converts a path into a region, the system discards the closed path from the specified device context. ",
    "return_type": "HRGN",
    "category": "Windows GDI",
    "name": "PathToRegion",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context that contains a closed path."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SetMiterLimit function sets the limit for the length of miter joins for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The miter length is defined as the distance from the intersection of the line walls on the inside of the join to the intersection of the line walls on the outside of the join. The miter limit is the maximum allowed ratio of the miter length to the line width. The default miter limit is 10.0. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetMiterLimit",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "FLOAT",
        "name": "eNewLimit",
        "description": "Specifies the new miter limit for the device context."
      },
      {
        "in_out": "_Out_",
        "type": "PFLOAT",
        "name": "peOldLimit",
        "description": "Pointer to a floating-point value that receives the previous miter limit. If this parameter is NULL, the previous miter limit is not returned."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The StrokeAndFillPath function closes any open figures in a path, strokes the outline of the path by using the current pen, and fills its interior by using the current brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.  If the function fails, GetLastError may return one of the following error codes:  If the function fails, GetLastError may return one of the following error codes: ",
    "remarks": "The device context identified by the hdc parameter must contain a closed path. The StrokeAndFillPath function has the same effect as closing all the open figures in the path, and stroking and filling the path separately, except that the filled region will not overlap the stroked region even if the pen is wide. For an example, see Drawing a Pie Chart. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "StrokeAndFillPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The StrokePath function renders the specified path by using the current pen.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The path, if it is to be drawn by StrokePath, must have been completed through a call to EndPath. Calling this function on a path for which EndPath has not been called will cause this function to fail and return zero.  Unlike other path drawing functions such as StrokeAndFillPath, StrokePath will not attempt to close the path by drawing a straight line from the first point on the path to the last point on the path. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "StrokePath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context that contains the completed path."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The WidenPath function redefines the current path as the area that would be painted if the path were stroked using the pen currently selected into the given device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.  If the function fails, GetLastError may return one of the following error codes:  If the function fails, GetLastError may return one of the following error codes: ",
    "remarks": "The WidenPath function is successful only if the current pen is a geometric pen created by the ExtCreatePen function, or if the pen is created with the CreatePen function and has a width, in device units, of more than one. The device context identified by the hdc parameter must contain a closed path. Any B\u00c3\u00a9zier curves in the path are converted to sequences of straight lines approximating the widened curves. As such, no B\u00c3\u00a9zier curves remain in the path after WidenPath is called. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "WidenPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context that contains a closed path."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CloseEnhMetaFile function closes an enhanced-metafile device context and returns a handle that identifies an enhanced-format metafile.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to an enhanced metafile. If the function fails, the return value is NULL. ",
    "remarks": "An application can use the enhanced-metafile handle returned by the CloseEnhMetaFile function to perform the following tasks: When the application no longer needs the enhanced metafile handle, it should release the handle by calling the DeleteEnhMetaFile function. ",
    "return_type": "HENHMETAFILE",
    "category": "Windows GDI",
    "name": "CloseEnhMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to an enhanced-metafile device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CopyEnhMetaFile function copies the contents of an enhanced-format metafile to a specified file.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the copy of the enhanced metafile. If the function fails, the return value is NULL. ",
    "remarks": "Where text arguments must use Unicode characters, use the CopyEnhMetaFile function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function. Applications can use metafiles stored in memory for temporary operations. When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the DeleteEnhMetaFile function. ",
    "return_type": "HENHMETAFILE",
    "category": "Windows GDI",
    "name": "CopyEnhMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemfSrc",
        "description": "A handle to the enhanced metafile to be copied."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFile",
        "description": "A pointer to the name of the destination file. If this parameter is NULL, the source metafile is copied to memory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The CreateEnhMetaFile function creates a device context for an enhanced-format metafile. This device context can be used to store a device-independent picture.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the device context for the enhanced metafile. If the function fails, the return value is NULL. ",
    "remarks": "Where text arguments must use Unicode characters, use the CreateEnhMetaFile function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function. The system uses the reference device identified by the hdcRef parameter to record the resolution and units of the device on which a picture originally appeared. If the hdcRef parameter is NULL, it uses the current display device for reference. The left and top members of the RECT structure pointed to by the lpRect parameter must be less than the right and bottom members, respectively. Points along the edges of the rectangle are included in the picture. If lpRect is NULL, the graphics device interface (GDI) computes the dimensions of the smallest rectangle that surrounds the picture drawn by the application. The lpRect parameter should be provided where possible. The string pointed to by the lpDescription parameter must contain a null character between the application name and the picture name and must terminate with two null charactersfor example, \"XYZ Graphics Editor\\0Bald Eagle\\0\\0\", where \\0 represents the null character. If lpDescription is NULL, there is no corresponding entry in the enhanced-metafile header. Applications use the device context created by this function to store a graphics picture in an enhanced metafile. The handle identifying this device context can be passed to any GDI function. After an application stores a picture in an enhanced metafile, it can display the picture on any output device by calling the PlayEnhMetaFile function. When displaying the picture, the system uses the rectangle pointed to by the lpRect parameter and the resolution data from the reference device to position and scale the picture. The device context returned by this function contains the same default attributes associated with any new device context. Applications must use the GetWinMetaFileBits function to convert an enhanced metafile to the older Windows metafile format. The file name for the enhanced metafile should use the .emf extension. For an example, see Creating an Enhanced Metafile. ",
    "return_type": "HDC",
    "category": "Windows GDI",
    "name": "CreateEnhMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcRef",
        "description": "A handle to a reference device for the enhanced metafile. This parameter can be NULL; for more information, see Remarks."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFilename",
        "description": "A pointer to the file name for the enhanced metafile to be created. If this parameter is NULL, the enhanced metafile is memory based and its contents are lost when it is deleted by using the DeleteEnhMetaFile function."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lpRect",
        "description": "A pointer to a RECT structure that specifies the dimensions (in .01-millimeter units) of the picture to be stored in the enhanced metafile."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpDescription",
        "description": "A pointer to a string that specifies the name of the application that created the picture, as well as the picture's title. This parameter can be NULL; for more information, see Remarks."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The DeleteEnhMetaFile function deletes an enhanced-format metafile or an enhanced-format metafile handle.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "If the hemf parameter identifies an enhanced metafile stored in memory, the DeleteEnhMetaFile function deletes the metafile. If hemf identifies a metafile stored on a disk, the function deletes the metafile handle but does not destroy the actual metafile. An application can retrieve the file by calling the GetEnhMetaFile function. For an example, see Opening an Enhanced Metafile and Displaying Its Contents. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "DeleteEnhMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to an enhanced metafile."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The EnhMetaFileProc function is an application-defined callback function used with the EnumEnhMetaFile function. The ENHMFENUMPROC type defines a pointer to this callback function. EnhMetaFileProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "This function must return a nonzero value to continue enumeration; to stop enumeration, it must return zero. ",
    "remarks": "An application must register the callback function by passing its address to the EnumEnhMetaFile function. ",
    "return_type": "int CALLBACK",
    "category": "Windows GDI",
    "name": "EnhMetaFileProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Handle to the device context passed to EnumEnhMetaFile."
      },
      {
        "in_out": "_In_",
        "type": "HANDLETABLE*",
        "name": "lpHTable",
        "description": "Pointer to a HANDLETABLE structure representing the table of handles associated with the graphics objects (pens, brushes, and so on) in the metafile. The first entry contains the enhanced-metafile handle."
      },
      {
        "in_out": "_In_",
        "type": "const ENHMETARECORD*",
        "name": "lpEMFR",
        "description": "Pointer to one of the records in the metafile. This record should not be modified. (If modification is necessary, it should be performed on a copy of the record.)"
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nObj",
        "description": "Specifies the number of objects with associated handles in the handle table."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lpData",
        "description": "Pointer to optional data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The EnumEnhMetaFile function enumerates the records within an enhanced-format metafile by retrieving each record and passing it to the specified callback function. The application-supplied callback function processes each record as required. The enumeration continues until the last record is processed or when the callback function returns zero.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the callback function successfully enumerates all the records in the enhanced metafile, the return value is nonzero. If the callback function does not successfully enumerate all the records in the enhanced metafile, the return value is zero. ",
    "remarks": "Points along the edge of the rectangle pointed to by the lpRect parameter are included in the picture. If the hdc parameter is NULL, the system ignores lpRect. If the callback function calls the PlayEnhMetaFileRecord function, hdc must identify a valid device context. The system uses the device context's transformation and mapping mode to transform the picture displayed by the PlayEnhMetaFileRecord function. You can use the EnumEnhMetaFile function to embed one enhanced-metafile within another. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "EnumEnhMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context. This handle is passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to an enhanced metafile."
      },
      {
        "in_out": "_In_",
        "type": "ENHMFENUMPROC",
        "name": "lpEnhMetaFunc",
        "description": "A pointer to the application-supplied callback function. For more information, see the EnhMetaFileProc function."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpData",
        "description": "A pointer to optional callback-function data."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lpRect",
        "description": "A pointer to a RECT structure that specifies the coordinates, in logical units, of the picture's upper-left and lower-right corners."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GdiComment function copies a comment from a buffer into a specified enhanced-format metafile.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "A comment can include any kind of private information, for example, the source of a picture and the date it was created. A comment should begin with an application signature, followed by the data. Comments should not contain application-specific or position-specific data. Position-specific data specifies the location of a record, and it should not be included because one metafile may be embedded within another metafile. A public comment is a comment that begins with the comment signature identifier GDICOMMENT_IDENTIFIER. The following public comments are defined.    ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "GdiComment",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to an enhanced-metafile device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbSize",
        "description": "The length of the comment buffer, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "const BYTE*",
        "name": "lpData",
        "description": "A pointer to the buffer that contains the comment."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetEnhMetaFile function creates a handle that identifies the enhanced-format metafile stored in the specified file.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "WinGdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the enhanced metafile. If the function fails, the return value is NULL. ",
    "remarks": "When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the DeleteEnhMetaFile function. A Windows-format metafile must be converted to the enhanced format before it can be processed by the GetEnhMetaFile function. To convert the file, use the SetWinMetaFileBits function. Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function. For an example, see Opening an Enhanced Metafile and Displaying Its Contents. ",
    "return_type": "HENHMETAFILE",
    "category": "Windows GDI",
    "name": "GetEnhMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszMetaFile",
        "description": "A pointer to a null-terminated string that specifies the name of an enhanced metafile."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetEnhMetaFileBits function retrieves the contents of the specified enhanced-format metafile and copies them into a buffer.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds and the buffer pointer is NULL, the return value is the size of the enhanced metafile, in bytes. If the function succeeds and the buffer pointer is a valid pointer, the return value is the number of bytes copied to the buffer. If the function fails, the return value is zero. ",
    "remarks": "After the enhanced-metafile bits are retrieved, they can be used to create a memory-based metafile by calling the SetEnhMetaFileBits function. The GetEnhMetaFileBits function does not invalidate the enhanced-metafile handle. The application must call the DeleteEnhMetaFile function to delete the handle when it is no longer needed. The metafile contents retrieved by this function are in the enhanced format. To retrieve the metafile contents in the Windows format, use the GetWinMetaFileBits function. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetEnhMetaFileBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to the enhanced metafile."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbBuffer",
        "description": "The size, in bytes, of the buffer to receive the data."
      },
      {
        "in_out": "_Out_",
        "type": "LPBYTE",
        "name": "lpbBuffer",
        "description": "A pointer to a buffer that receives the metafile data. The buffer must be sufficiently large to contain the data. If lpbBuffer is NULL, the function returns the size necessary to hold the data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetEnhMetaFileDescription function retrieves an optional text description from an enhanced-format metafile and copies the string to the specified buffer.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the optional text description exists and the buffer pointer is NULL, the return value is the length of the text string, in characters. If the optional text description exists and the buffer pointer is a valid pointer, the return value is the number of characters copied into the buffer. If the optional text description does not exist, the return value is zero. If the function fails, the return value is GDI_ERROR. ",
    "remarks": "The optional text description contains two strings, the first identifying the application that created the enhanced metafile and the second identifying the picture contained in the metafile. The strings are separated by a null character and terminated with two null charactersfor example, \"XYZ Graphics Editor\\0Bald Eagle\\0\\0\" where \\0 represents the null character. Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetEnhMetaFileDescription",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to the enhanced metafile."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cchBuffer",
        "description": "The size, in characters, of the buffer to receive the data. Only this many characters will be copied."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszDescription",
        "description": "A pointer to a buffer that receives the optional text description."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetEnhMetaFileHeader function retrieves the record containing the header for the specified enhanced-format metafile.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds and the structure pointer is NULL, the return value is the size of the record that contains the header; if the structure pointer is a valid pointer, the return value is the number of bytes copied. Otherwise, it is zero. ",
    "remarks": "An enhanced-metafile header contains such information as the metafile's size, in bytes; the dimensions of the picture stored in the metafile; the number of records stored in the metafile; the offset to the optional text description; the size of the optional palette, and the resolution of the device on which the picture was created. The record that contains the enhanced-metafile header is always the first record in the metafile. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetEnhMetaFileHeader",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to the enhanced metafile for which the header is to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbBuffer",
        "description": "The size, in bytes, of the buffer to receive the data. Only this many bytes will be copied."
      },
      {
        "in_out": "_Out_",
        "type": "LPENHMETAHEADER",
        "name": "lpemh",
        "description": "A pointer to an ENHMETAHEADER structure that receives the header record. If this parameter is NULL, the function returns the size of the header record."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetEnhMetaFilePaletteEntries function retrieves optional palette entries from the specified enhanced metafile.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the array pointer is NULL and the enhanced metafile contains an optional palette, the return value is the number of entries in the enhanced metafile's palette; if the array pointer is a valid pointer and the enhanced metafile contains an optional palette, the return value is the number of entries copied; if the metafile does not contain an optional palette, the return value is zero. Otherwise, the return value is GDI_ERROR. ",
    "remarks": "An application can store an optional palette in an enhanced metafile by calling the CreatePalette and SetPaletteEntries functions before creating the picture and storing it in the metafile. By doing this, the application can achieve consistent colors when the picture is displayed on a variety of devices. An application that displays a picture stored in an enhanced metafile can call the GetEnhMetaFilePaletteEntries function to determine whether the optional palette exists. If it does, the application can call the GetEnhMetaFilePaletteEntries function a second time to retrieve the palette entries and then create a logical palette (by using the CreatePalette function), select it into its device context (by using the SelectPalette function), and then realize it (by using the RealizePalette function). After the logical palette has been realized, calling the PlayEnhMetaFile function displays the picture using its original colors. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetEnhMetaFilePaletteEntries",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to the enhanced metafile."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cEntries",
        "description": "The number of entries to be retrieved from the optional palette."
      },
      {
        "in_out": "_Out_",
        "type": "LPPALETTEENTRY",
        "name": "lppe",
        "description": "A pointer to an array of PALETTEENTRY structures that receives the palette colors. The array must contain at least as many structures as there are entries specified by the cEntries parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "[GetMetaFile is no longer available for use as of Windows 2000. Instead, use GetEnhMetaFile.]",
    "library": "Gdi32.lib",
    "min_server": "",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the metafile. If the function fails, the return value is NULL. ",
    "remarks": "This function is not implemented in the Win32 API. It is provided for compatibility with 16-bit versions of Windows. In Win32 applications, use the GetEnhMetaFile function. ",
    "return_type": "HENHMETAFILE",
    "category": "Windows GDI",
    "name": "GetMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszMetaFile",
        "description": "A pointer to a null-terminated string that specifies the name of a metafile."
      }
    ],
    "min_client": ""
  },
  {
    "n_arguments": 5,
    "description": "The GetWinMetaFileBits function converts the enhanced-format records from a metafile into Windows-format records and stores the converted records in the specified buffer.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds and the buffer pointer is NULL, the return value is the number of bytes required to store the converted records; if the function succeeds and the buffer pointer is a valid pointer, the return value is the size of the metafile data in bytes. If the function fails, the return value is zero. ",
    "remarks": "This function converts an enhanced metafile into a Windows-format metafile so that its picture can be displayed in an application that recognizes the older format. The system uses the reference device context to determine the resolution of the converted metafile. The GetWinMetaFileBits function does not invalidate the enhanced metafile handle. An application should call the DeleteEnhMetaFile function to release the handle when it is no longer needed. To create a scalable Windows-format metafile, specify MM_ANISOTROPIC as the fnMapMode parameter. The upper-left corner of the metafile picture is always mapped to the origin of the reference device. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetWinMetaFileBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to the enhanced metafile."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbBuffer",
        "description": "The size, in bytes, of the buffer into which the converted records are to be copied."
      },
      {
        "in_out": "_Out_",
        "type": "LPBYTE",
        "name": "lpbBuffer",
        "description": "A pointer to the buffer that receives the converted records. If lpbBuffer is NULL, GetWinMetaFileBits returns the number of bytes required to store the converted metafile records."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "fnMapMode",
        "description": "The mapping mode to use in the converted metafile."
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcRef",
        "description": "A handle to the reference device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The PlayEnhMetaFile function displays the picture stored in the specified enhanced-format metafile.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "When an application calls the PlayEnhMetaFile function, the system uses the picture frame in the enhanced-metafile header to map the picture onto the rectangle pointed to by the lpRect parameter. (This picture may be sheared or rotated by setting the world transform in the output device before calling PlayEnhMetaFile.) Points along the edges of the rectangle are included in the picture. An enhanced-metafile picture can be clipped by defining the clipping region in the output device before playing the enhanced metafile. If an enhanced metafile contains an optional palette, an application can achieve consistent colors by setting up a color palette on the output device before calling PlayEnhMetaFile. To retrieve the optional palette, use the GetEnhMetaFilePaletteEntries function. An enhanced metafile can be embedded in a newly created enhanced metafile by calling PlayEnhMetaFile and playing the source enhanced metafile into the device context for the new enhanced metafile. The states of the output device context are preserved by this function. Any object created but not deleted in the enhanced metafile is deleted by this function. To stop this function, an application can call the CancelDC function from another thread to terminate the operation. In this case, the function returns FALSE. For an example, see Opening an Enhanced Metafile and Displaying Its Contents. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PlayEnhMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context for the output device on which the picture will appear."
      },
      {
        "in_out": "_In_",
        "type": "HENHMETAFILE",
        "name": "hemf",
        "description": "A handle to the enhanced metafile."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lpRect",
        "description": "A pointer to a RECT structure that contains the coordinates of the bounding rectangle used to display the picture. The coordinates are specified in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The PlayEnhMetaFileRecord function plays an enhanced-metafile record by executing the graphics device interface (GDI) functions identified by the record.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "This is an enhanced-metafile function. An application typically uses PlayEnhMetaFileRecord in conjunction with the EnumEnhMetaFile function to process and play an enhanced-format metafile one record at a time. The hdc, lpHandletable, and nHandles parameters must be exactly those passed to the EnhMetaFileProc callback procedure by the EnumEnhMetaFile function. If PlayEnhMetaFileRecord does not recognize a record, it ignores the record and returns TRUE. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PlayEnhMetaFileRecord",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context passed to the EnumEnhMetaFile function."
      },
      {
        "in_out": "_In_",
        "type": "LPHANDLETABLE",
        "name": "lpHandletable",
        "description": "A pointer to a table of handles to GDI objects used when playing the metafile. The first entry in this table contains the enhanced-metafile handle."
      },
      {
        "in_out": "_In_",
        "type": "const ENHMETARECORD*",
        "name": "lpEnhMetaRecord",
        "description": "A pointer to the enhanced-metafile record to be played."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nHandles",
        "description": "The number of handles in the handle table."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetEnhMetaFileBits function creates a memory-based enhanced-format metafile from the specified data.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a memory-based enhanced metafile. If the function fails, the return value is NULL. ",
    "remarks": "When the application no longer needs the enhanced-metafile handle, it should delete the handle by calling the DeleteEnhMetaFile function. The SetEnhMetaFileBits function does not accept metafile data in the Windows format. To import Windows-format metafiles, use the SetWinMetaFileBits function. ",
    "return_type": "HENHMETAFILE",
    "category": "Windows GDI",
    "name": "SetEnhMetaFileBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbBuffer",
        "description": "Specifies the size, in bytes, of the data provided."
      },
      {
        "in_out": "_In_",
        "type": "const BYTE*",
        "name": "lpData",
        "description": "Pointer to a buffer that contains enhanced-metafile data. (It is assumed that the data in the buffer was obtained by calling the GetEnhMetaFileBits function.)"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SetWinMetaFileBits function converts a metafile from the older Windows format to the new enhanced format and stores the new metafile in memory.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a memory-based enhanced metafile. If the function fails, the return value is NULL. ",
    "remarks": "Windows uses the reference device context's resolution data and the data in the METAFILEPICT structure to scale a picture. If the hdcRef parameter is NULL, the system uses resolution data for the current output device. If the lpmfp parameter is NULL, the system uses the MM_ANISOTROPIC mapping mode to scale the picture so that it fits the entire device surface. The hMF member of the METAFILEPICT structure is not used. When the application no longer needs the enhanced metafile handle, it should delete it by calling the DeleteEnhMetaFile function. The handle returned by this function can be used with other enhanced-metafile functions. If the reference device context is not identical to the device in which the metafile was originally created, some GDI functions that use device units may not draw the picture correctly. ",
    "return_type": "HENHMETAFILE",
    "category": "Windows GDI",
    "name": "SetWinMetaFileBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cbBuffer",
        "description": "The size, in bytes, of the buffer that contains the Windows-format metafile."
      },
      {
        "in_out": "_In_",
        "type": "const BYTE*",
        "name": "lpbBuffer",
        "description": "A pointer to a buffer that contains the Windows-format metafile data. (It is assumed that the data was obtained by using the GetMetaFileBitsEx or GetWinMetaFileBits function.)"
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcRef",
        "description": "A handle to a reference device context."
      },
      {
        "in_out": "_In_",
        "type": "const METAFILEPICT*",
        "name": "lpmfp",
        "description": "A pointer to a METAFILEPICT structure that contains the suggested size of the metafile picture and the mapping mode that was used when the picture was created."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CloseMetaFile function closes a metafile device context and returns a handle that identifies a Windows-format metafile.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a Windows-format metafile. If the function fails, the return value is NULL. ",
    "remarks": "To convert a Windows-format metafile into a new enhanced-format metafile, use the SetWinMetaFileBits function. When an application no longer needs the Windows-format metafile handle, it should delete the handle by calling the DeleteMetaFile function. ",
    "return_type": "HMETAFILE",
    "category": "Windows GDI",
    "name": "CloseMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a metafile device context used to create a Windows-format metafile."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CopyMetaFile function copies the content of a Windows-format metafile to the specified file.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the copy of the Windows-format metafile. If the function fails, the return value is NULL. ",
    "remarks": "Where text arguments must use Unicode characters, use this function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function. When the application no longer needs the Windows-format metafile handle, it should delete the handle by calling the DeleteMetaFile function. ",
    "return_type": "HMETAFILE",
    "category": "Windows GDI",
    "name": "CopyMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HMETAFILE",
        "name": "hmfSrc",
        "description": "A handle to the source Windows-format metafile."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFile",
        "description": "A pointer to the name of the destination file. If this parameter is NULL, the source metafile is copied to memory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateMetaFile function creates a device context for a Windows-format metafile.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the device context for the Windows-format metafile. If the function fails, the return value is NULL. ",
    "remarks": "Where text arguments must use Unicode characters, use the CreateMetaFile function as a wide-character function. Where text arguments must use characters from the Windows character set, use this function as an ANSI function. CreateMetaFile is a Windows-format metafile function. This function supports only 16-bit Windows-based applications, which are listed in Windows-Format Metafiles. It does not record or play back GDI functions such as PolyBezier, which were not part of 16-bit Windows. The device context created by this function can be used to record GDI output functions in a Windows-format metafile. It cannot be used with GDI query functions such as GetTextColor. When the device context is used with a GDI output function, the return value of that function becomes TRUE if the function is recorded and FALSE otherwise. When an object is selected by using the SelectObject function, only a copy of the object is recorded. The object still belongs to the application. To create a scalable Windows-format metafile, record the graphics output in the MM_ANISOTROPIC mapping mode. The file cannot contain functions that modify the viewport origin and extents, nor can it contain device-dependent functions such as the SelectClipRgn function. Once created, the Windows metafile can be scaled and rendered to any output device-format by defining the viewport origin and extents of the picture before playing it. ",
    "return_type": "HDC",
    "category": "Windows GDI",
    "name": "CreateMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszFile",
        "description": "A pointer to the file name for the Windows-format metafile to be created. If this parameter is NULL, the Windows-format metafile is memory based and its contents are lost when it is deleted by using the DeleteMetaFile function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The DeleteMetaFile function deletes a Windows-format metafile or Windows-format metafile handle.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "If the metafile identified by the hmf parameter is stored in memory (rather than on a disk), its content is lost when it is deleted by using the DeleteMetaFile function. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "DeleteMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HMETAFILE",
        "name": "hmf",
        "description": "A handle to a Windows-format metafile."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The EnumMetaFile function enumerates the records within a Windows-format metafile by retrieving each record and passing it to the specified callback function. The application-supplied callback function processes each record as required. The enumeration continues until the last record is processed or when the callback function returns zero.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the callback function successfully enumerates all the records in the Windows-format metafile, the return value is nonzero. If the callback function does not successfully enumerate all the records in the Windows-format metafile, the return value is zero. ",
    "remarks": "To convert a Windows-format metafile into an enhanced-format metafile, use the SetWinMetaFileBits function. You can use the EnumMetaFile function to embed one Windows-format metafile within another. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "EnumMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context. This handle is passed to the callback function."
      },
      {
        "in_out": "_In_",
        "type": "HMETAFILE",
        "name": "hmf",
        "description": "Handle to a Windows-format metafile."
      },
      {
        "in_out": "_In_",
        "type": "MFENUMPROC",
        "name": "lpMetaFunc",
        "description": "Pointer to an application-supplied callback function. For more information, see EnumMetaFileProc."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lParam",
        "description": "Pointer to optional data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The EnumMetaFileProc function is an application-defined callback function that processes Windows-format metafile records. This function is called by the EnumMetaFile function. The MFENUMPROC type defines a pointer to this callback function. EnumMetaFileProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "This function must return a nonzero value to continue enumeration; to stop enumeration, it must return zero. ",
    "remarks": "An application must register the callback function by passing its address to the EnumMetaFile function. EnumMetaFileProc is a placeholder for the application-supplied function name. ",
    "return_type": "int CALLBACK",
    "category": "Windows GDI",
    "name": "EnumMetaFileProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Handle to the device context passed to EnumMetaFile."
      },
      {
        "in_out": "_In_",
        "type": "HANDLETABLE*",
        "name": "lpHTable",
        "description": "Pointer to a table of handles associated with the graphics objects (pens, brushes, and so on) in the metafile."
      },
      {
        "in_out": "_In_",
        "type": "METARECORD*",
        "name": "lpMFR",
        "description": "Pointer to one of the records in the metafile. This record should not be modified. (If modification is necessary, it should be performed on a copy of the record.)"
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nObj",
        "description": "Specifies the number of objects with associated handles in the handle table."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lpClientData",
        "description": "Pointer to optional data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetMetaFileBitsEx function retrieves the contents of a Windows-format metafile and copies them into the specified buffer.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds and the buffer pointer is NULL, the return value is the number of bytes required for the buffer; if the function succeeds and the buffer pointer is a valid pointer, the return value is the number of bytes copied. If the function fails, the return value is zero. ",
    "remarks": "After the Windows-metafile bits are retrieved, they can be used to create a memory-based metafile by calling the SetMetaFileBitsEx function. The GetMetaFileBitsEx function does not invalidate the metafile handle. An application must delete this handle by calling the DeleteMetaFile function. To convert a Windows-format metafile into an enhanced-format metafile, use the SetWinMetaFileBits function. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetMetaFileBitsEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HMETAFILE",
        "name": "hmf",
        "description": "A handle to a Windows-format metafile."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nSize",
        "description": "The size, in bytes, of the buffer to receive the data."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpvData",
        "description": "A pointer to a buffer that receives the metafile data. The buffer must be sufficiently large to contain the data. If lpvData is NULL, the function returns the number of bytes required to hold the data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The PlayMetaFile function displays the picture stored in the given Windows-format metafile on the specified device.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "To convert a Windows-format metafile into an enhanced format metafile, use the SetWinMetaFileBits function. A Windows-format metafile can be played multiple times. A Windows-format metafile can be embedded in a second Windows-format metafile by calling the PlayMetaFile function and playing the source metafile into the device context for the target metafile. Any object created but not deleted in the Windows-format metafile is deleted by this function. To stop this function, an application can call the CancelDC function from another thread to terminate the operation. In this case, the function returns FALSE. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PlayMetaFile",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "HMETAFILE",
        "name": "hmf",
        "description": "Handle to a Windows-format metafile."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The PlayMetaFileRecord function plays a Windows-format metafile record by executing the graphics device interface (GDI) function contained within that record.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "To convert a Windows-format metafile into an enhanced-format metafile, use the SetWinMetaFileBits function. An application typically uses PlayMetaFileRecord in conjunction with the EnumMetaFile function to process and play a Windows-format metafile one record at a time. The lpHandletable and nHandles parameters must be identical to those passed to the EnumMetaFileProc callback procedure by EnumMetaFile. If the PlayMetaFileRecord function does not recognize a record, it ignores the record and returns TRUE. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PlayMetaFileRecord",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "LPHANDLETABLE",
        "name": "lpHandletable",
        "description": "A pointer to a HANDLETABLE structure representing the table of handles to GDI objects used when playing the metafile."
      },
      {
        "in_out": "_In_",
        "type": "LPMETARECORD",
        "name": "lpMetaRecord",
        "description": "A pointer to the Windows-format metafile record."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nHandles",
        "description": "The number of handles in the handle table."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetMetaFileBitsEx function creates a memory-based Windows-format metafile from the supplied data.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a memory-based Windows-format metafile. If the function fails, the return value is NULL. ",
    "remarks": "To convert a Windows-format metafile into an enhanced-format metafile, use the SetWinMetaFileBits function. When the application no longer needs the metafile handle returned by SetMetaFileBitsEx, it should delete it by calling the DeleteMetaFile function. ",
    "return_type": "HMETAFILE",
    "category": "Windows GDI",
    "name": "SetMetaFileBitsEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nSize",
        "description": "Specifies the size, in bytes, of the Windows-format metafile."
      },
      {
        "in_out": "_In_",
        "type": "const BYTE*",
        "name": "lpData",
        "description": "Pointer to a buffer that contains the Windows-format metafile. (It is assumed that the data was obtained by using the GetMetaFileBitsEx function.)"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The AngleArc function draws a line segment and an arc. The line segment is drawn from the current position to the beginning of the arc. The arc is drawn along the perimeter of a circle with the given radius and center. The length of the arc is defined by the given start and sweep angles.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The AngleArc function moves the current position to the ending point of the arc. The arc drawn by this function may appear to be elliptical, depending on the current transformation and mapping mode. Before drawing the arc, AngleArc draws the line segment from the current position to the beginning of the arc. The arc is drawn by constructing an imaginary circle around the specified center point with the specified radius. The starting point of the arc is determined by measuring counterclockwise from the x-axis of the circle by the number of degrees in the start angle. The ending point is similarly located by measuring counterclockwise from the starting point by the number of degrees in the sweep angle. If the sweep angle is greater than 360 degrees, the arc is swept multiple times. This function draws lines by using the current pen. The figure is not filled. For an example, see Drawing a Pie Chart. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "AngleArc",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "Specifies the x-coordinate, in logical units, of the center of the circle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "Specifies the y-coordinate, in logical units, of the center of the circle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRadius",
        "description": "Specifies the radius, in logical units, of the circle. This value must be positive."
      },
      {
        "in_out": "_In_",
        "type": "FLOAT",
        "name": "eStartAngle",
        "description": "Specifies the start angle, in degrees, relative to the x-axis."
      },
      {
        "in_out": "_In_",
        "type": "FLOAT",
        "name": "eSweepAngle",
        "description": "Specifies the sweep angle, in degrees, relative to the starting angle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The Arc function draws an elliptical arc.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the arc is drawn, the return value is nonzero. If the arc is not drawn, the return value is zero. ",
    "remarks": "The points (nLeftRect, nTopRect) and (nRightRect, nBottomRect) specify the bounding rectangle. An ellipse formed by the specified bounding rectangle defines the curve of the arc. The arc extends in the current drawing direction from the point where it intersects the radial from the center of the bounding rectangle to the (nXStartArc, nYStartArc) point. The arc ends where it intersects the radial from the center of the bounding rectangle to the (nXEndArc, nYEndArc) point. If the starting point and ending point are the same, a complete ellipse is drawn. The arc is drawn using the current pen; it is not filled. The current position is neither used nor updated by Arc. Use the GetArcDirection and SetArcDirection functions to get and set the current drawing direction for a device context. The default drawing direction is counterclockwise. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "Arc",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context where drawing takes place."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical units, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical units, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXStartArc",
        "description": "The x-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYStartArc",
        "description": "The y-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXEndArc",
        "description": "The x-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYEndArc",
        "description": "The y-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The ArcTo function draws an elliptical arc.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "ArcTo is similar to the Arc function, except that the current position is updated. The points (nLeftRect, nTopRect) and (nRightRect, nBottomRect) specify the bounding rectangle. An ellipse formed by the specified bounding rectangle defines the curve of the arc. The arc extends counterclockwise from the point where it intersects the radial line from the center of the bounding rectangle to the (nXRadial1, nYRadial1) point. The arc ends where it intersects the radial line from the center of the bounding rectangle to the (nXRadial2, nYRadial2) point. If the starting point and ending point are the same, a complete ellipse is drawn. A line is drawn from the current position to the starting point of the arc. If no error occurs, the current position is set to the ending point of the arc. The arc is drawn using the current pen; it is not filled. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "ArcTo",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context where drawing takes place."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical units, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical units, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXRadial1",
        "description": "The x-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYRadial1",
        "description": "The y-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXRadial2",
        "description": "The x-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYRadial2",
        "description": "The y-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetArcDirection function retrieves the current arc direction for the specified device context. Arc and rectangle functions use the arc direction.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the current arc direction; it can be any one of the following values:  ",
    "remarks": "",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetArcDirection",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The LineDDA function determines which pixels should be highlighted for a line defined by the specified starting and ending points.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The LineDDA function passes the coordinates for each point along the line, except for the line's ending point, to the application-defined callback function. In addition to passing the coordinates of a point, this function passes any existing application-defined data. The coordinates passed to the callback function match pixels on a video display only if the default transformations and mapping modes are used. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "LineDDA",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXStart",
        "description": "Specifies the x-coordinate, in logical units, of the line's starting point."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYStart",
        "description": "Specifies the y-coordinate, in logical units, of the line's starting point."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXEnd",
        "description": "Specifies the x-coordinate, in logical units, of the line's ending point."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYEnd",
        "description": "Specifies the y-coordinate, in logical units, of the line's ending point."
      },
      {
        "in_out": "_In_",
        "type": "LINEDDAPROC",
        "name": "lpLineFunc",
        "description": "Pointer to an application-defined callback function. For more information, see the LineDDAProc callback function."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lpData",
        "description": "Pointer to the application-defined data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LineDDAProc function is an application-defined callback function used with the LineDDA function. It is used to process coordinates. The LINEDDAPROC type defines a pointer to this callback function. LineDDAProc is a placeholder for the application-defined function name.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "This function does not return a value. ",
    "remarks": "An application registers a LineDDAProc function by passing its address to the LineDDA function. ",
    "return_type": "VOID CALLBACK",
    "category": "Windows GDI",
    "name": "LineDDAProc",
    "is_callback": 1,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "Specifies the x-coordinate, in logical units, of the current point."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "Specifies the y-coordinate, in logical units, of the current point."
      },
      {
        "in_out": "_In_",
        "type": "LPARAM",
        "name": "lpData",
        "description": "Pointer to the application-defined data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The LineTo function draws a line from the current position up to, but not including, the specified point.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The line is drawn by using the current pen and, if the pen is a geometric pen, the current brush. If LineTo succeeds, the current position is set to the specified ending point. For an example, see Drawing Markers. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "LineTo",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXEnd",
        "description": "Specifies the x-coordinate, in logical units, of the line's ending point."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYEnd",
        "description": "Specifies the y-coordinate, in logical units, of the line's ending point."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The MoveToEx function updates the current position to the specified point and optionally returns the previous position.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The MoveToEx function affects all drawing functions. For an example, see Drawing Markers. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "MoveToEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "Handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "Specifies the x-coordinate, in logical units, of the new position, in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "Specifies the y-coordinate, in logical units, of the new position, in logical units."
      },
      {
        "in_out": "_Out_",
        "type": "LPPOINT",
        "name": "lpPoint",
        "description": "Pointer to a POINT structure that receives the previous current position. If this parameter is a NULL pointer, the previous position is not returned."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The PolyBezier function draws one or more B\u00c3\u00a9zier curves.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The PolyBezier function draws cubic B\u00c3\u00a9zier curves by using the endpoints and control points specified by the lppt parameter. The first curve is drawn from the first point to the fourth point by using the second and third points as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the previous curve is used as the starting point, the next two points in the sequence are control points, and the third is the ending point. The current position is neither used nor updated by the PolyBezier function. The figure is not filled. This function draws lines by using the current pen. For an example, see Redrawing in the Update Region. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PolyBezier",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures that contain the endpoints and control points of the curve(s), in logical units."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cPoints",
        "description": "The number of points in the lppt array. ..."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The PolyBezierTo function draws one or more B\u00c3\u00a9zier curves.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "This function draws cubic B\u00c3\u00a9zier curves by using the control points specified by the lppt parameter. The first curve is drawn from the current position to the third point by using the first two points as control points. For each subsequent curve, the function needs exactly three more points, and uses the ending point of the previous curve as the starting point for the next. PolyBezierTo moves the current position to the ending point of the last B\u00c3\u00a9zier curve. The figure is not filled. This function draws lines by using the current pen. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PolyBezierTo",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures that contains the endpoints and control points, in logical units."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cCount",
        "description": "The number of points in the lppt array. ..."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The PolyDraw function draws a set of line segments and B\u00c3\u00a9zier curves.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The PolyDraw function can be used in place of consecutive calls to MoveToEx, LineTo, and PolyBezierTo functions to draw disjoint figures. The lines and curves are drawn using the current pen and figures are not filled. If there is an active path started by calling BeginPath, PolyDraw adds to the path. The points contained in the lppt array and in the lpbTypes array indicate whether each point is part of a MoveTo, LineTo, or PolyBezierTo operation. It is also possible to close figures. This function updates the current position. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PolyDraw",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures that contains the endpoints for each line segment and the endpoints and control points for each B\u00e9zier curve, in logical units. ..."
      },
      {
        "in_out": "_In_",
        "type": "const BYTE*",
        "name": "lpbTypes",
        "description": "A pointer to an array that specifies how each point in the lppt array is used. ..."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cCount",
        "description": "The total number of points in the lppt array, the same as the number of bytes in the lpbTypes array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The Polyline function draws a series of line segments by connecting the points in the specified array.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The lines are drawn from the first point through subsequent points by using the current pen. Unlike the LineTo or PolylineTo functions, the Polyline function neither uses nor updates the current position. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "Polyline",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures, in logical units."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "cPoints",
        "description": "The number of points in the array. This number must be greater than or equal to two."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The PolylineTo function draws one or more straight lines.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Unlike the Polyline function, the PolylineTo function uses and updates the current position. A line is drawn from the current position to the first point specified by the lppt parameter by using the current pen. For each additional line, the function draws from the ending point of the previous line to the next point specified by lppt. PolylineTo moves the current position to the ending point of the last line. If the line segments drawn by this function form a closed figure, the figure is not filled. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PolylineTo",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures that contains the vertices of the line, in logical units."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cCount",
        "description": "The number of points in the array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The PolyPolyline function draws multiple series of connected line segments.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The line segments are drawn by using the current pen. The figures formed by the segments are not filled. The current position is neither used nor updated by this function. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PolyPolyline",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lppt",
        "description": "A pointer to an array of POINT structures that contains the vertices of the polylines, in logical units. The polylines are specified consecutively."
      },
      {
        "in_out": "_In_",
        "type": "const DWORD*",
        "name": "lpdwPolyPoints",
        "description": "A pointer to an array of variables specifying the number of points in the lppt array for the corresponding polyline. Each entry must be greater than or equal to two."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cCount",
        "description": "The total number of entries in the lpdwPolyPoints array."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetArcDirection sets the drawing direction to be used for arc and rectangle functions.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the old arc direction. If the function fails, the return value is zero. ",
    "remarks": "The default direction is counterclockwise. The SetArcDirection function specifies the direction in which the following functions draw: ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "SetArcDirection",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "ArcDirection",
        "description": "The new arc direction. This parameter can be one of the following values.  ValueMeaning  AD_COUNTERCLOCKWISE   Figures drawn counterclockwise.   AD_CLOCKWISE   Figures drawn clockwise."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Client-provided callback function, used by CreateFontPackage and MergeFontPackage to allocate memory.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FontSub.h",
    "return_value": "Returns a void pointer to the allocated space, or NULL if there is insufficient memory available. ",
    "remarks": "malloc conforms to this type; the application can either use malloc or a more specialized function for memory allocation. Whatever function is chosen, there must also be appropriate functions to reallocate and to free this memory. ",
    "return_type": "typedef void* (",
    "category": "Windows GDI",
    "name": "CFP_ALLOCPROC pointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "size_t",
        "name": "size",
        "description": "Number of bytes to allocate."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Client-provided callback function, used by CreateFontPackage and MergeFontPackage to free memory.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FontSub.h",
    "return_value": "Deallocates a memory block (memblock) that was previously allocated by a call to a CFP_ALLOCPROC or CFP_REALLOCPROC callback function. If memblock is NULL, the pointer should be ignored and the function should return immediately. The function is not required to correctly handle being passed an invalid pointer (a pointer to a memory block that was not allocated by the appropriate CFP_ALLOCPROC or CFP_REALLOCPROC callback function). ",
    "remarks": "free conforms to this type; the application can either use free or a more specialized function. Whatever function is chosen, there must also be appropriate functions to allocate and to reallocate this memory. ",
    "return_type": "typedef void* (",
    "category": "Windows GDI",
    "name": "CFP_FREEPROC pointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "memblock",
        "description": "Previously allocated memory block to be freed."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Client-provided callback function, used by CreateFontPackage and MergeFontPackage to reallocate memory when the size of an allocated buffer needs to change.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FontSub.h",
    "return_value": "Returns a void pointer to the reallocated (and possibly moved) memory block. The return value should be NULL if the size is zero and the memblock argument is not NULL, or if there is not enough available memory to expand the block to the given size. In the first case, the original block should be freed. In the second, the original block should be unchanged. ",
    "remarks": "realloc       conforms to this type; the application can either use realloc or a more specialized function for memory reallocation. Whatever function is chosen, there must also be appropriate functions for initial allocation and to free this memory. ",
    "return_type": "typedef void* (",
    "category": "Windows GDI",
    "name": "CFP_REALLOCPROC pointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "memblock",
        "description": "Pointer to previously allocated memory block."
      },
      {
        "in_out": "_In_",
        "type": "size_t",
        "name": "size",
        "description": "New size in bytes."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 17,
    "description": "The CreateFontPackage function creates a subset version of a specified TrueType font, typically in order to pass it to a printer. In order to allow for the fact that pages later in a document may need characters or glyphs that were not used on the first page, this function can create an initial subset font package, then create \"Delta\" font packages that can be merged with the original subset font package, effectively extending it.",
    "library": "FontSub.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FontSub.h",
    "return_value": "If the function is successful, returns zero. Otherwise, returns a nonzero value. See Font-Package Function Error Messages for possible error returns. ",
    "remarks": "By specifying a value of TTFCFP_SUBSET for usSubsetFormat, you can directly create a working font rather than a font package. This does not allow for future merging, but if there is no need for merging, this skips a step in the downstream processing: a font package needs to be converted back to a working font before it can be used. By specifying a value of TTFCFP_SUBSET1 for usSubsetFormat, you can create a font package that allows later merging. For example, consider the case where an application calls this function at the start of a large print job. Part way through the print job, the application discovers that it needs glyphs that are not in the subset it has built. The application can make another call to CreateFontPackage, this time specifying a value of TTFCFP_DELTA for usSubsetFormat. The printer can use MergeFontPackage to merge in these additional glyphs. A CMAP maps from character encodings to glyphs. If *pusSubsetKeepList is a list of character values, then the application uses parameters usSubsetPlatform and usSubsetEncoding to specify what type of CMAP is being used, so that character values can be mapped to glyphs. ",
    "return_type": "unsigned long",
    "category": "Windows GDI",
    "name": "CreateFontPackage",
    "is_callback": 0,
    "dll": "FontSub.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const unsigned char*",
        "name": "puchSrcBuffer",
        "description": "Points to a buffer containing source TTF or TTC data, describing the font that is to be subsetted."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned long",
        "name": "ulSrcBufferSize",
        "description": "Specifies size of *puchSrcBuffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned char**",
        "name": "puchFontPackageBuffer",
        "description": "Points to a variable of type unsigned char*. The CreateFontPackage function will allocate a buffer **puchFontPackageBuffer, using lpfnAllocate and lpfnReAllocate. On successful return, the buffer will contain the subset font or font package. The application is responsible for eventually freeing the buffer."
      },
      {
        "in_out": "_Out_",
        "type": "const unsigned long*",
        "name": "pulFontPackageBufferSize",
        "description": "Points to an unsigned long, which on successful return will specify the allocated size of buffer **puchFontPackageBuffer."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned long*",
        "name": "pulBytesWritten",
        "description": "Points to an unsigned long, which on successful return will specify the number of bytes actually used in buffer **puchFontPackageBuffer."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usFlags",
        "description": "Specifies whether this font should be subsetted, compressed, or both; whether it is a TTF or TTC; and whether*pusSubsetKeepListrepresents character codes or glyph indices. Any combination of the following flags may be specified:  ValueMeaning  TTFCFP_FLAGS_SUBSET   If set, requests subsetting.   TTFCFP_FLAGS_COMPRESS   If set, requests compression. The currently shipping version of this function does not do compression. This flag allows for future implementation of this capability, but is currently ignored.   TTFCFP_FLAGS_TTC   If set, specifies that the font in puchSrcBuffer is a TTC; otherwise, it must be a TTF.   TTFCFP_FLAGS_GLYPHLIST   If set, specifies that*pusSubsetKeepListis a list of glyph indices; otherwise, it must be a list of character codes."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usTTCIndex",
        "description": "The zero based TTC Index; only used if TTFCFP_FLAGS_TTC is set in usFlags."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usSubsetFormat",
        "description": "The format of the file to create. Select one of these values; they cannot be combined.  ValueMeaning  TTFCFP_SUBSET   Create a standalone Subset font that cannot be merged with later.   TTFCFP_SUBSET1   Create a Subset font package that can be merged with later.   TTFCFP_DELTA   Create a Delta font package that can merge with a previous subset font."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usSubsetLanguage",
        "description": "The language in the Name table to retain. If Set to 0, all languages will be retained. Used only for initial subsetting: that is, used only if usSubsetFormat is either TTFCFP_SUBSET or TTFCFP_SUBSET1, and the TTFCFP_FLAGS_SUBSET flag is set in usFlags."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usSubsetPlatform",
        "description": "In conjunction with usSubsetEncoding, specifies which CMAP to use. Used only if *pusSubsetKeepList is a list of characters: that is, used only if TTFCFP_FLAGS_GLYPHLIST is not set in usFlags. In that case, by this CMAP subtable is applied to pusSubsetKeepList to create a list of glyphs to retain in the output font or font package. If used, this must take one of the following values; they cannot be combined:  Value               Meaning                 TTFCFP_UNICODE_PLATFORMID    TTFCFP_APPLE_PLATFORMID    TTFCFP_ISO_PLATFORMID    TTFCFP_MS_PLATFORMID"
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usSubsetEncoding",
        "description": "In conjunction with usSubsetPlatform, specifies which CMAP to use. Used only if *pusSubsetKeepList is a list of characters: that is, used only if TTFCFP_FLAGS_GLYPHLIST is not set in usFlags. If used, this must take one of the following values; they cannot be combined:  ValueMeaning  TTFCFP_STD_MAC_CHAR_SET   Can be used only if usSubsetPlatform == TTFCFP_APPLE_PLATFORMID.   TTFCFP_SYMBOL_CHAR_SET   Can be used only if usSubsetPlatform == TTFSUB_MS_PLATFORMID.   TTFCFP_UNICODE_CHAR_SET   Can be used only if usSubsetPlatform == TTFSUB_MS_PLATFORMID.   TTFCFP_DONT_CARE"
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short*",
        "name": "pusSubsetKeepList",
        "description": "Points to an array of integers which comprise a list of character codes or glyph indices that should be retained in the output font or font package. If this list contains character codes (that is, if if TTFCFP_FLAGS_GLYPHLIST is not set in usFlags), this list may be either Unicode or some other type of encoding, depending on the Platform-Encoding CMAP specified by usSubsetPlatform and usSubsetEncoding."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usSubsetKeepListCount",
        "description": "The number of elements in the list *pusSubsetKeepList."
      },
      {
        "in_out": "_In_",
        "type": "CFP_ALLOCPROC",
        "name": "lpfnAllocate",
        "description": "The callback function to allocate initial memory for puchFontPackageBuffer and for temporary buffers."
      },
      {
        "in_out": "_In_",
        "type": "CFP_REALLOCPROC",
        "name": "lpfnReAllocate",
        "description": "The callback function to reallocate memory for puchFontPackageBuffer and for temporary buffers."
      },
      {
        "in_out": "_In_",
        "type": "CFP_FREEPROC",
        "name": "lpfnFree",
        "description": "The callback function to free up memory allocated by lpfnAllocate and lpfnReAllocate."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvReserved",
        "description": "Must be set to NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "The MergeFontPackage function manipulates fonts created by CreateFontPackage. It is slightly more flexible than its name might suggest: it can appropriately handle all of the subset fonts and font packages created by CreateFontPackage. It can turn a font package into a working font, and it can merge a Delta font package into an appropriately prepared working font.",
    "library": "FontSub.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "FontSub.h",
    "return_value": "If the function is successful, returns zero. Otherwise, returns a nonzero value. See Font-Package Function Error Messages for possible error returns. ",
    "remarks": "This function handles four distinct, related entities, each representing a subset font:  ",
    "return_type": "unsigned long",
    "category": "Windows GDI",
    "name": "MergeFontPackage",
    "is_callback": 0,
    "dll": "FontSub.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const unsigned char*",
        "name": "puchMergeFontBuffer",
        "description": "A pointer to a buffer containing a font to merge with. This is used only when usMode is TTFMFP_DELTA."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned long",
        "name": "ulMergeFontBufferSize",
        "description": "Specifies size of *puchMergeFontBuffer, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "unsigned char*",
        "name": "puchFontPackageBuffer",
        "description": "A pointer to a to buffer containing a font package."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned long",
        "name": "ulFontPackageBufferSize",
        "description": "Specifies size of *puchMergeFontBuffer, in bytes."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned char**",
        "name": "ppuchDestBuffer",
        "description": "A pointer to a variable of type unsigned char*. The MergeFontPackage function will allocate a buffer **ppuchDestBuffer, using lpfnAllocate and lpfnReAllocate. On successful return, that buffer will contain the resulting merged or expanded font. The application is responsible for eventually freeing that buffer."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned long*",
        "name": "pulDestBufferSize",
        "description": "Points to an unsigned long, which on successful return will specify the allocated size of buffer **ppuchDestBuffer."
      },
      {
        "in_out": "_Out_",
        "type": "unsigned long*",
        "name": "pulBytesWritten",
        "description": "Points to an unsigned long, which on successful return will specify the number of bytes actually used in buffer **ppuchDestBuffer."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned short",
        "name": "usMode",
        "description": "Specifies what kind of process to perform. Select one of these values; they cannot be combined.  ValueMeaning  TTFMFP_SUBSET   Copies a simple working font; see remarks below. puchMergeFontBuffer will be ignored; puchFontPackageBuffer should contain a working font created by CreateFontPackage with usSubsetFormat set to TTFCFP_SUBSET; this working font will simply be copied to ppuchDestBuffer.   TTFMFP_SUBSET1   Turns a font package into a mergeable working font; see remarks below. puchMergeFontBuffer will be ignored; puchFontPackageBuffer should contain a mergeable working font created by CreateFontPackage with usSubsetFormat set to TTFCFP_SUBSET1. The result in **ppuchDestBuffer will be a working font that may be merged with later.   TTFMFP_DELTA   Merges a Delta font package into a mergeable working font; see remarks below. *puchFontPackageBuffer should contain a font package created by CreateFontPackage with usSubsetFormat set to TTFCFP_DELTA and puchMergeFontBuffer should contain a font package created by a prior call to MergeFontPackage with usMode set to TTFMFP_SUBSET1 or TTFMFP_DELTA. The resulting merged font in **ppuchDestBuffer will be a working font that may be merged with later."
      },
      {
        "in_out": "_In_",
        "type": "CFP_ALLOCPROC",
        "name": "lpfnAllocate",
        "description": "The callback function to allocate initial memory for ppuchDestBuffer and for temporary buffers."
      },
      {
        "in_out": "_In_",
        "type": "CFP_REALLOCPROC",
        "name": "lpfnReAllocate",
        "description": "The callback function to reallocate memory for ppuchDestBuffer and for temporary buffers."
      },
      {
        "in_out": "_In_",
        "type": "CFP_FREEPROC",
        "name": "lpfnFree",
        "description": "The callback function to free up memory allocated by lpfnAllocate and lpfnReAllocate."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvReserved",
        "description": "Must be set to NULL."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Client-provided callback function, used by TTGetEmbeddedFontInfo and TTLoadEmbeddedFont to read stream contents from a buffer.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "Returns the number of bytes successfully read. In the event of failure, no special error codes are returned. The system function that called this will detect failure from the fact that not as many bytes were read as were requested. ",
    "remarks": "",
    "return_type": "typedef unsigned long ( WINAPIV",
    "category": "Windows GDI",
    "name": "READEMBEDPROC pointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "lpvReadStream",
        "description": "Stream identifier (file handle or other) of the input stream (font structure)."
      },
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "lpvBuffer",
        "description": "Address of buffer to which to write data."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned long",
        "name": "cbBuffer",
        "description": "Number of bytes to read (from stream to buffer)."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Converts an array of 8-bit character code values to 16-bit Unicode values.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. Array *pusShortCodes is filled with 16-bit Unicode values that correspond to the 8-bit character codes in *pusCharCodes.ulShortCodeSize contains the size, in wide characters, of *pusShortCodes. Otherwise, returns an error code described in Embedding Function Error Messages. ",
    "remarks": "This function may be useful to clients when creating a list of symbol characters to be subsetted. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTCharToUnicode",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "A device context handle."
      },
      {
        "in_out": "_In_",
        "type": "UCHAR*",
        "name": "pucCharCodes",
        "description": "A pointer to an array of 8-bit character codes to convert to 16-bit Unicode values. Must be set to a non-null value."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulCharCodeSize",
        "description": "The size of an 8-bit character code array."
      },
      {
        "in_out": "_Out_",
        "type": "USHORT*",
        "name": "pusShortCodes",
        "description": "A pointer to an array that will be filled by this function with the Unicode equivalents of the 8-bit values in the pucCharCodesarray. This parameter must be set to a non-null value."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulShortCodeSize",
        "description": "The size, in wide characters, of the character code array."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulFlags",
        "description": "This parameter is currently unused."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Releases memory used by an embedded font, hFontReference.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, TTDeleteEmbeddedFont returns a value of E_NONE. The memory occupied by the embedded font structure is cleared. By default, the font indicated by hFontReference is also permanently removed (uninstalled and deleted) from the system. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "The client is responsible for calling this function to remove fonts when the embedding privileges do not allow a font to be permanently installed on a user's system. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTDeleteEmbeddedFont",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hFontReference",
        "description": "Handle identifying font, as provided in the TTLoadEmbeddedFont function."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulFlags",
        "description": "Flag specifying font deletion options. Currently, this flag can be set to zero or the following value:  ValueMeaning  TTDELETE_DONTREMOVEFONT   Do not remove the installed font from the system, but release the memory previously occupied by the embedded font structure."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulStatus",
        "description": "Currently undefined."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "Creates a font structure containing the subsetted wide-character (16-bit) font. The current font of the device context (hDC) provides the font information.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If the embedding is successful, returns E_NONE. The font structure is incorporated into the document stream by the client. pulPrivStatus is set, indicating the embedding privileges of the font; and pulStatus is set to provide results of the embedding operation. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "Clients are responsible for determining and indicating the character set of the font. For information about embedding UCS-4 characters, see TTEmbedFontEx. For information about embedding font characters from a file, see TTEmbedFontFromFileA. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTEmbedFont",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Device context handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulFlags",
        "description": "Flag specifying the embedding request. This flag can have zero or more of the following values.  ValueMeaning  TTEMBED_EMBEDEUDC   Include the associated EUDC font file data with the font structure.   TTEMBED_RAW   Return a font structure containing the full character set, non-compressed. This is the default behavior of the function.   TTEMBED_SUBSET   Return a subsetted font containing only the glyphs indicated by the pusCharCodeSet or pulCharCodeSet parameter. These character codes must be denoted as 16-bit or UCS-4 characters, as appropriate for the parameter.   TTEMBED_TTCOMPRESSED   Return a compressed font structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulCharSet",
        "description": "Flag specifying the character set of the font to be embedded. This flag can have one of the following values.  ValueMeaning  CHARSET_UNICODE   Unicode character set, requiring 16-bit character encoding.   CHARSET_SYMBOL   Symbol character set, requiring 16-bit character encoding."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulPrivStatus",
        "description": "Pointer to flag indicating embedding privileges of the font. This flag can have one of the following values. This function returns the least restrictive license granted.  ValueMeaning  EMBED_PREVIEWPRINT   Preview and Print Embedding.   EMBED_EDITABLE   Editable Embedding.   EMBED_INSTALLABLE   Installable Embedding.   EMBED_NOEMBEDDING   Restricted License Embedding."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulStatus",
        "description": "Pointer to a bitfield containing status information about the embedding request. This field is filled upon completion of this function. No bits are currently defined for this parameter."
      },
      {
        "in_out": "",
        "type": "WRITEEMBEDPROC",
        "name": "lpfnWriteToStream",
        "description": "Pointer to the client-defined callback function, which writes the font structure to the document stream. See WRITEEMBEDPROC."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvWriteStream",
        "description": "A token to represent the output stream."
      },
      {
        "in_out": "_In_",
        "type": "USHORT*",
        "name": "pusCharCodeSet",
        "description": "Pointer to the buffer containing the optional Unicode character codes for subsetting. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "usCharCodeCount",
        "description": "The number of characters in the list of characters indicated by pusCharCodeSet. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "usLanguage",
        "description": "Specifies which language in the name table to keep when subsetting. Set to 0 to keep all languages. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_opt_",
        "type": "TTEMBEDINFO*",
        "name": "pTTEmbedInfo",
        "description": "Pointer to a TTEMBEDINFO structure containing the URLs from which the embedded font object may be legitimately referenced. If pTTEmbedInfo is NULL, no URLs will be added to the embedded font object and no URL checking will occur when the client calls TTLoadEmbeddedFont."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "Creates a font structure containing the subsetted UCS-4 character (32-bit) font. The current font of the device context (hDC) provides the font information.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If the embedding is successful, returns E_NONE. The font structure is incorporated into the document stream by the client. pulPrivStatus is set, indicating the embedding privileges of the font; and pulStatus is set to provide results of the embedding operation. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "This function references a client-defined callback routine for embedding the font structure into the document stream. Clients are responsible for determining and indicating the character set of the font. For information on embedding Unicode characters, see TTEmbedFont; for information on embedding Unicode characters from a file, see TTEmbedFontFromFileA. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTEmbedFontEx",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Device context handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulFlags",
        "description": "Flag specifying the embedding request. This flag can have zero or more of the following values.  ValueMeaning  TTEMBED_EMBEDEUDC   Include the associated EUDC font file data with the font structure.   TTEMBED_RAW   Return a font structure containing the full character set, non-compressed. This is the default behavior of the function.   TTEMBED_SUBSET   Return a subsetted font containing only the glyphs indicated by the pusCharCodeSet or pulCharCodeSet parameter. These character codes must be denoted as 16-bit or UCS-4 characters as appropriate for the parameter.   TTEMBED_TTCOMPRESSED   Return a compressed font structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulCharSet",
        "description": "Flag specifying the character set of the font to be embedded. This flag can have one of the following values.  ValueMeaning  CHARSET_UNICODE   Unicode character set, requiring 16-bit character encoding.   CHARSET_SYMBOL   Symbol character set, requiring 16-bit character encoding."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulPrivStatus",
        "description": "Pointer to flag indicating embedding privileges of the font. This flag can have one of the following values. This function returns the least restrictive license granted.  ValueMeaning  EMBED_PREVIEWPRINT   Preview and Print Embedding.   EMBED_EDITABLE   Editable Embedding.   EMBED_INSTALLABLE   Installable Embedding.   EMBED_NOEMBEDDING   Restricted License Embedding."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulStatus",
        "description": "Pointer to a bitfield containing status information about the embedding request. This field is filled upon completion of this function. No bits are currently defined for this parameter."
      },
      {
        "in_out": "",
        "type": "WRITEEMBEDPROC",
        "name": "lpfnWriteToStream",
        "description": "Pointer to the client-defined callback function which writes the font structure to the document stream. See WRITEEMBEDPROC."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvWriteStream",
        "description": "A token to represent the output stream."
      },
      {
        "in_out": "_In_",
        "type": "ULONG*",
        "name": "pulCharCodeSet",
        "description": "Pointer to the buffer containing the optional UCS-4 character codes for subsetting. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "usCharCodeCount",
        "description": "The number of characters in the list of characters indicated by pulCharCodeSet. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "usLanguage",
        "description": "Specifies which language in the name table to keep when subsetting. Set to 0 to keep all languages. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_opt_",
        "type": "TTEMBEDINFO*",
        "name": "pTTEmbedInfo",
        "description": "Pointer to a TTEMBEDINFO structure containing the URLs from which the embedded font object may be legitimately referenced. If pTTEmbedInfo is NULL, no URLs will be added to the embedded font object and no URL checking will occur when the client calls TTLoadEmbeddedFont."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 13,
    "description": "Creates a font structure containing the subsetted wide-character (16-bit) font. An external file provides the font information.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If the embedding is successful, returns E_NONE. The font structure is incorporated into the document stream by the client. pulPrivStatus is set, indicating the embedding privileges of the font; and pulStatus is set to provide results of the embedding operation. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "This function references a client-defined callback routine for embedding the font structure into the document stream. Clients are responsible for determining and indicating the character set of the font. For information on embedding Unicode characters from a device context, see TTEmbedFont; for information on embedding UCS-4 characters from a device context, see TTEmbedFontEx. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTEmbedFontFromFileA",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Device context handle."
      },
      {
        "in_out": "_In_",
        "type": "LPCSTR",
        "name": "szFontFileName",
        "description": "The font file name and path to embed. This is an ANSI string."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "usTTCIndex",
        "description": "Zero-based index into the font file (TTC) identifying the physical font to embed. If the file contains a single font (such as a TTF or OTF outline file), this parameter should be set to 0."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulFlags",
        "description": "Flag specifying the embedding request. This flag can have zero or more of the following values.  ValueMeaning  TTEMBED_EMBEDEUDC   Include the associated EUDC font file data with the font structure.   TTEMBED_RAW   Return a font structure containing the full character set, non-compressed. This is the default behavior of the function.   TTEMBED_SUBSET   Return a subsetted font containing only the glyphs indicated by the pusCharCodeSet or pulCharCodeSet parameter. These character codes must be denoted as 16-bit or UCS-4 characters as appropriate for the parameter.   TTEMBED_TTCOMPRESSED   Return a compressed font structure."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulCharSet",
        "description": "Flag specifying the character set of the font to be embedded. This flag can have one of the following values.  ValueMeaning  CHARSET_UNICODE   Unicode character set, requiring 16-bit character encoding.   CHARSET_SYMBOL   Symbol character set, requiring 16-bit character encoding."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulPrivStatus",
        "description": "Pointer to flag indicating embedding privileges of the font. This flag can have one of the following values. This function returns the least restrictive license granted.  ValueMeaning  EMBED_PREVIEWPRINT   Preview and Print Embedding.   EMBED_EDITABLE   Editable Embedding.   EMBED_INSTALLABLE   Installable Embedding.   EMBED_NOEMBEDDING   Restricted License Embedding."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulStatus",
        "description": "Pointer to a bitfield containing status information about the embedding request. This field is filled upon completion of this function. No bits are currently defined for this parameter."
      },
      {
        "in_out": "",
        "type": "WRITEEMBEDPROC",
        "name": "lpfnWriteToStream",
        "description": "Pointer to the client-defined callback function that writes the font structure to the document stream.  See WRITEEMBEDPROC."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvWriteStream",
        "description": "A token to represent the output stream."
      },
      {
        "in_out": "_In_",
        "type": "USHORT*",
        "name": "pusCharCodeSet",
        "description": "Pointer to the buffer containing the optional Unicode character codes for subsetting. This field is only used for subsetting a font and is ignored if theulFlagsfield does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "usCharCodeCount",
        "description": "The number of characters in the list of characters indicated by pusCharCodeSet. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_",
        "type": "USHORT",
        "name": "usLanguage",
        "description": "Specifies which language in the name table to keep when subsetting. Set to 0 to keep all languages. This field is only used for subsetting a font and is ignored if the ulFlags field does not specify TTEMBED_SUBSET."
      },
      {
        "in_out": "_In_opt_",
        "type": "TTEMBEDINFO*",
        "name": "pTTEmbedInfo",
        "description": "Pointer to a TTEMBEDINFO structure containing the URLs from which the embedded font object may be legitimately referenced. If pTTEmbedInfo is NULL, no URLs will be added to the embedded font object and no URL checking will occur when the client calls the TTLoadEmbeddedFont function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Adds or removes facenames from the typeface exclusion list.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. The facename indicated by lpszFacename will be added or removed from the typeface exclusion list. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "The function TTEnableEmbeddingForFacename uses a typeface exclusion list to control whether a specific font can be embedded. This list identifies all fonts that should NOT be embedded and is shared by all authoring clients on a single system. An authoring client can embed fonts without referencing the typeface exclusion list (that is, without using TTEnableEmbeddingForFacename). Embedding fonts in a document results in the following tradeoffs. Two additional functions, TTIsEmbeddingEnabled and TTIsEmbeddingEnabledForFacename, access the typeface exclusion list to provide enabling status. The typeface exclusion list is stored in the registry key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Shared Tools\\t2embed. The default typeface exclusion list should contain the following named value entries representing the Microsoft Windows core fonts.  ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTEnableEmbeddingForFacename",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTR",
        "name": "lpszFacename",
        "description": "Pointer to the facename of the font to be added or removed from the typeface exclusion list."
      },
      {
        "in_out": "_In_",
        "type": "bool",
        "name": "bEnable",
        "description": "Boolean controlling operation on typeface exclusion list. If nonzero, then the facename will be removed from the list; if zero, the facename will be added to the list."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Retrieves information about an embedded font, such as embedding permissions. TTGetEmbeddedFontInfo performs the same task as TTLoadEmbeddedFont but does not allocate internal data structures for the embedded font.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. The location referenced by *pulPrivStatus identifies embedding privileges of the font. The location referenced by *pulStatus identifies whether a subset of the font is embedded. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTGetEmbeddedFontInfo",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulFlags",
        "description": "Flags specifying the request. This flag can have zero or more of the following values.  ValueMeaning  TTEMBED_EMBEDEUDC   Include the associated EUDC font file data with the font structure.   TTEMBED_RAW   Return a font structure containing the full character set, non-compressed. This is the default behavior of the function.   TTEMBED_SUBSET   Return a subsetted font containing only the glyphs indicated by the pusCharCodeSet or pulCharCodeSet parameter. These character codes must be denoted as 16-bit or UCS-4 characters, as appropriate for the parameter.   TTEMBED_TTCOMPRESSED   Return a compressed font structure."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulPrivStatus",
        "description": "On completion, indicates embedding privileges of the font. A list of possible values follows:  ValueMeaning  EMBED_PREVIEWPRINT   Preview and Print Embedding.   EMBED_EDITABLE   Editable Embedding.   EMBED_INSTALLABLE   Installable Embedding.   EMBED_NOEMBEDDING   Restricted License Embedding."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulPrivs",
        "description": "Flag indicating a further restriction of embedding privileges, imposed by the client. See TTLoadEmbeddedFont for additional information. This flag must have one of the following values.  ValueMeaning  LICENSE_PREVIEWPRINT   Preview and Print Embedding.   LICENSE_EDITABLE   Editable Embedding.   LICENSE_INSTALLABLE   Installable Embedding.   LICENSE_NOEMBEDDING   Restricted License Embedding.   LICENSE_DEFAULT   Use default embedding level."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulStatus",
        "description": "Pointer to a bitfield containing status information, and is filled upon completion of this function. The status can be zero or the following value:  ValueMeaning  TTLOAD_FONT_SUBSETTED   The font loaded is a subset of the original font."
      },
      {
        "in_out": "",
        "type": "READEMBEDPROC",
        "name": "lpfnReadFromStream",
        "description": "[callback] Pointer to the client-defined callback function that reads the font structure from the document stream."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvReadStream",
        "description": "Currently undefined. Reserved for a pointer to the stream (font structure)."
      },
      {
        "in_out": "_In_",
        "type": "TTLOADINFO*",
        "name": "pTTLoadInfo",
        "description": "Pointer to a TTLOADINFO structure containing the URL from which the embedded font object has been obtained."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Obtains the embedding privileges of a font.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. This function reads the embedding privileges stored in the font and transfers the privileges to pulPrivStatus. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "Alternatively, an application can determine embedding privileges by using TTLoadEmbeddedFont and then checking the value returned in pulPrivStatus for success or failure of the function. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTGetEmbeddingType",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Device context handle."
      },
      {
        "in_out": "_In_",
        "type": "ULONG*",
        "name": "pulPrivStatus",
        "description": "Pointer to flag indicating embedding privileges of the font. This flag can have one of the following values. This function returns the least restrictive license granted.  ValueMeaning  EMBED_PREVIEWPRINT   Preview and Print Embedding.   EMBED_EDITABLE   Editable Embedding.   EMBED_INSTALLABLE   Installable Embedding.   EMBED_NOEMBEDDING   Restricted License Embedding."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Obtains the family name for the font loaded through TTLoadEmbeddedFont.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. The font family name is a string in szWinFamilyName or szMacFamilyName. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTGetNewFontName",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE*",
        "name": "phFontReference",
        "description": "Handle that identifies the embedded font that has been installed. The handle references an internal structure, not an Hfont."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSTR",
        "name": "szWinFamilyName",
        "description": "Buffer to hold the new 16-bit-character Microsoft Windows family name."
      },
      {
        "in_out": "_In_",
        "type": "long",
        "name": "cchMaxWinName",
        "description": "Length of the string allocated for the Windows name (szWinFamilyName). Must be at least LF_FACESIZE long."
      },
      {
        "in_out": "_Out_",
        "type": "LPSTR",
        "name": "szMacFamilyName",
        "description": "Buffer to hold the new 8-bit-character MacIntosh family name."
      },
      {
        "in_out": "_In_",
        "type": "long",
        "name": "cchMaxMacName",
        "description": "Length of the string allocated for the Macintosh name (szMacFamilyName). Must be at least LF_FACESIZE long."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether the typeface exclusion list contains a specified font.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. The parameter pbEnabled is filled with a boolean that indicates whether embedding is currently enabled within a device context. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "If the specified font is listed, the client should not embed the font. For additional information on the exclusion list, see the Remarks section of TTEnableEmbeddingForFacename. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTIsEmbeddingEnabled",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Device context handle."
      },
      {
        "in_out": "_Out_",
        "type": "BOOL*",
        "name": "pbEnabled",
        "description": "Pointer to a boolean, set upon completion of the function. A nonzero value indicates the font is not in the typeface exclusion list and, therefore, can be embedded without conflict."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether embedding is enabled for a specified font.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. pbEnabled is filled with a boolean that indicates whether embedding is currently enabled within a device context for the specified font. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "If successful, the client may embed the font. For additional information on the exclusion list, see the Remarks section of TTEnableEmbeddingForFacename. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTIsEmbeddingEnabledForFacename",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSTR",
        "name": "lpszFacename",
        "description": "Pointer to the facename of the font, such as Arial Bold."
      },
      {
        "in_out": "_Out_",
        "type": "BOOL*",
        "name": "pbEnabled",
        "description": "Pointer to a boolean, set upon completion of the function. A nonzero value indicates the font is not in the typeface exclusion list, and, therefore, can be embedded without conflict."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 10,
    "description": "Reads an embedded font from the document stream and installs it. Also allows a client to further restrict embedding privileges of the font.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful, returns E_NONE. If font loading is successful, a font indicated by phFontReference is created from the font structure with the names referenced in szWinFamilyName and szMacFamilyName. pulPrivStatus is set indicating the embedding privileges of the font; and pulStatus may be set indicating status information about the font loading operation. Otherwise, returns an error code described in Embedding Function Error Messages. ",
    "remarks": "To assist a client in determining whether an embedded font is already installed on the system, the font loading function will return an error message indicating a font with the same name exists on the system (E_FONTNAMEALREADYEXISTS), and if that font has the same checksum as the embedded font (E_FONTALREADYEXISTS). The client then has two options: To change the name of an embedded font prior to installing, the client must supply both the 8-bit-character and 16-bit-character name strings as parameters. The font name will be changed in the name table of the newly installed font. The new name is only available to the client and will not be enumerated to the user. To use the existing name of the embedded font, the name string parameters need to be set to NULL. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTLoadEmbeddedFont",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "HANDLE*",
        "name": "phFontReference",
        "description": "A pointer to a handle that identifies the installed embedded font. This handle references an internal structure, not an Hfont."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulFlags",
        "description": "A flag specifying loading and installation options. Currently, this flag can be set to zero or the following value:  ValueMeaning  TTLOAD_PRIVATE   Load the font so that it is not enumerated to the user. If the font is not installable, it will remain private."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulPrivStatus",
        "description": "A pointer to flag indicating embedding privileges of the font. This flag is written upon completion of this function and can have one of the following values. This function returns the least restrictive license granted.  ValueMeaning  EMBED_PREVIEWPRINT                    Preview and Print Embedding. The font may be embedded within documents, but must only be installed temporarily on the remote system. A document containing this type of font can only be opened as read-only. The application must not allow the user to edit the document. The document can only be viewed and/or printed.   EMBED_EDITABLE                    Editable Embedding. The font may be embedded within documents, but must only be installed temporarily on the remote system. A document containing this type of font may be opened \"read/write,\" with editing permitted.   EMBED_INSTALLABLE                    Installable Embedding. The font may be embedded and permanently installed on the remote system. The user of the remote system acquires the identical rights, obligations, and licenses for that font as the original purchaser of the font, and is subject to the same end-user license agreement, copyright, design patent, and/or trademark as was the original purchaser.   EMBED_NOEMBEDDING                    Restricted License Embedding. The font must not be modified, embedded, or exchanged in any manner without first obtaining permission of the legal owner."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulPrivs",
        "description": "A flag indicating a further restriction of embedding privileges, imposed by the client loading the font. This flag must have one of the following values.  ValueMeaning  LICENSE_PREVIEWPRINT   Preview and Print Embedding.   LICENSE_EDITABLE   Editable Embedding.   LICENSE_INSTALLABLE   Installable Embedding.   LICENSE_NOEMBEDDING   Restricted License Embedding.   LICENSE_DEFAULT   Use default embedding level."
      },
      {
        "in_out": "_Out_",
        "type": "ULONG*",
        "name": "pulStatus",
        "description": "A pointer to a bitfield containing status information about the TTLoadEmbeddedFont request. This field is filled upon completion of this function and can have zero or more of the following values.  ValueMeaning  TTLOAD_FONT_SUBSETTED   The font loaded is a subset of the original font.   TTLOAD_FONT_IN_SYSSTARTUP   The font loaded was labeled as installable and has been added to the registry so it will be available upon startup."
      },
      {
        "in_out": "_In_",
        "type": "READEMBEDPROC",
        "name": "lpfnReadFromStream",
        "description": "A pointer to the client-defined callback function that reads the font structure from the document stream."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvReadStream",
        "description": "A pointer to the stream (font structure)."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSTR",
        "name": "szWinFamilyName",
        "description": "A pointer to the new 16-bit-character Unicode Microsoft Windows family name of the font. Set to NULL to use existing name. When changing the name of a font upon loading, you must supply both this parameter and the szMacFamilyName parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSTR",
        "name": "szMacFamilyName",
        "description": "A pointer to the new 8-bit-character Macintosh family name of the font. Set to NULL to use existing name. When changing the name of a font upon loading, you must supply both this parameter and the szWinFamilyName parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "TTLOADINFO*",
        "name": "pTTLoadInfo",
        "description": "A pointer to a TTLOADINFO structure containing the URL from which the embedded font object has been obtained. If this value does not match one of those contained in the TTEMBEDINFO structure, the font will not load successfully."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Validates part or all glyph data of a wide-character (16-bit) font, in the size range specified.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful and the glyph data is valid, returns E_NONE. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "This function was supported in Windows XP and earlier, but is no longer supported. In Windows Vista and later, this function will always return E_API_NOTIMPL, and no processing is performed by this API. Effective font validation can be performed by a tool, such as Font Validator, that is capable of performing thorough validation of all parts of the font file. See the Font Validator documentation for more information. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTRunValidationTests",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Device context handle."
      },
      {
        "in_out": "_In_",
        "type": "TTVALIDATIONTESTSPARAMS*",
        "name": "pTestParam",
        "description": "Pointer to a TTVALIDATIONTESTPARAMS structure specifying the parameters to test."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Validates part or all glyph data of a UCS-4 character (32-bit) font, in the size range specified.",
    "library": "T2embed.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "If successful and the glyph data is valid, returns E_NONE. Otherwise, returns an error code described in Embedding-Function Error Messages. ",
    "remarks": "TTRunValidationTestsEx is a UCS-4 version of TTRunValidationTests. This function was supported in Windows XP and earlier, but is no longer supported. In Windows Vista and later, this function will always return E_API_NOTIMPL, and no processing is performed by this API. Effective font validation can be performed by a tool, such as Font Validator, that is capable of performing thorough validation of all parts of the font file. Please see http://www.microsoft.com/typography/FontValidator.mspx for information on the Font Validator tool. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "TTRunValidationTestsEx",
    "is_callback": 0,
    "dll": "T2embed.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "Device context handle."
      },
      {
        "in_out": "_In_",
        "type": "TTVALIDATIONTESTSPARAMSEX*",
        "name": "pTestParam",
        "description": "Pointer to a TTVALIDATIONTESTPARAMSEX structure specifying the parameters to test."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Client-provided callback function, used by TTEmbedFont, TTEmbedFontEx, and TTEmbedFontFromFileA to write stream contents to a buffer.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "T2embapi.h",
    "return_value": "Returns the number of bytes successfully written. In the event of failure, no special error codes are returned. The system function that called this will detect failure from the fact that not as many bytes were written as were requested. ",
    "remarks": "",
    "return_type": "typedef unsigned long ( WINAPIV",
    "category": "Windows GDI",
    "name": "WRITEEMBEDPROC pointer",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "void*",
        "name": "lpvWriteStream",
        "description": "Stream identifier (file handle or other) of the output stream (font structure)."
      },
      {
        "in_out": "_In_",
        "type": "const void*",
        "name": "lpvBuffer",
        "description": "Address of buffer with data to write."
      },
      {
        "in_out": "_In_",
        "type": "const unsigned long",
        "name": "cbBuffer",
        "description": "Number of bytes to write (from buffer to stream)."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The Chord function draws a chord (a region bounded by the intersection of an ellipse and a line segment, called a secant). The chord is outlined by using the current pen and filled by using the current brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The curve of the chord is defined by an ellipse that fits the specified bounding rectangle. The curve begins at the point where the ellipse intersects the first radial and extends counterclockwise to the point where the ellipse intersects the second radial. The chord is closed by drawing a line from the intersection of the first radial and the curve to the intersection of the second radial and the curve. If the starting point and ending point of the curve are the same, a complete ellipse is drawn. The current position is neither used nor updated by Chord. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "Chord",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context in which the chord appears."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXRadial1",
        "description": "The x-coordinate, in logical coordinates, of the endpoint of the radial defining the beginning of the chord."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYRadial1",
        "description": "The y-coordinate, in logical coordinates, of the endpoint of the radial defining the beginning of the chord."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXRadial2",
        "description": "The x-coordinate, in logical coordinates, of the endpoint of the radial defining the end of the chord."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYRadial2",
        "description": "The y-coordinate, in logical coordinates, of the endpoint of the radial defining the end of the chord."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The Ellipse function draws an ellipse. The center of the ellipse is the center of the specified bounding rectangle. The ellipse is outlined by using the current pen and is filled by using the current brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The current position is neither used nor updated by Ellipse. For an example, see Using Filled Shapes. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "Ellipse",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The FillRect function fills a rectangle by using the specified brush. This function includes the left and top borders, but excludes the right and bottom borders of the rectangle.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The brush identified by the hbr parameter may be either a handle to a logical brush or a color value. If specifying a handle to a logical brush, call one of the following functions to obtain the handle: CreateHatchBrush, CreatePatternBrush, or CreateSolidBrush. Additionally, you may retrieve a handle to one of the stock brushes by using the GetStockObject function. If specifying a color value for the hbr parameter, it must be one of the standard system colors (the value 1 must be added to the chosen color). For example: For a list of all the standard system colors, see GetSysColor. When filling the specified rectangle, FillRect does not include the rectangle's right and bottom sides. GDI fills a rectangle up to, but not including, the right column and bottom row, regardless of the current mapping mode. For an example, see Using Rectangles. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "FillRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "A pointer to a RECT structure that contains the logical coordinates of the rectangle to be filled."
      },
      {
        "in_out": "_In_",
        "type": "HBRUSH",
        "name": "hbr",
        "description": "A handle to the brush used to fill the rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The FrameRect function draws a border around the specified rectangle by using the specified brush. The width and height of the border are always one logical unit.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The brush identified by the hbr parameter must have been created by using the CreateHatchBrush, CreatePatternBrush, or CreateSolidBrush function, or retrieved by using the GetStockObject function. If the bottom member of the RECT structure is less than the top member, or if the right member is less than the left member, the function does not draw the rectangle. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "FrameRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "A handle to the device context in which the border is drawn."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "A pointer to a RECT structure that contains the logical coordinates of the upper-left and lower-right corners of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "HBRUSH",
        "name": "hbr",
        "description": "A handle to the brush used to draw the border."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The InvertRect function inverts a rectangle in a window by performing a logical NOT operation on the color values for each pixel in the rectangle's interior.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "On monochrome screens, InvertRect makes white pixels black and black pixels white. On color screens, the inversion depends on how colors are generated for the screen. Calling InvertRect twice for the same rectangle restores the display to its previous colors. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "InvertRect",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hDC",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "A pointer to a RECT structure that contains the logical coordinates of the rectangle to be inverted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The Pie function draws a pie-shaped wedge bounded by the intersection of an ellipse and two radials. The pie is outlined by using the current pen and filled by using the current brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The curve of the pie is defined by an ellipse that fits the specified bounding rectangle. The curve begins at the point where the ellipse intersects the first radial and extends counterclockwise to the point where the ellipse intersects the second radial. The current position is neither used nor updated by the Pie function. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "Pie",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical coordinates, of the upper-left corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical coordinates, of the lower-right corner of the bounding rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXRadial1",
        "description": "The x-coordinate, in logical coordinates, of the endpoint of the first radial."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYRadial1",
        "description": "The y-coordinate, in logical coordinates, of the endpoint of the first radial."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXRadial2",
        "description": "The x-coordinate, in logical coordinates, of the endpoint of the second radial."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYRadial2",
        "description": "The y-coordinate, in logical coordinates, of the endpoint of the second radial."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The Polygon function draws a polygon consisting of two or more vertices connected by straight lines. The polygon is outlined by using the current pen and filled by using the current brush and polygon fill mode.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The polygon is closed automatically by drawing a line from the last vertex to the first. The current position is neither used nor updated by the Polygon function. Any extra points are ignored. To draw a line with more points, divide your data into groups, each of which have less than the maximum number of points, and call the function for each group of points. Remember to connect the line segments. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "Polygon",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lpPoints",
        "description": "A pointer to an array of POINT structures that specify the vertices of the polygon, in logical coordinates."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The number of vertices in the array. This value must be greater than or equal to 2."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The PolyPolygon function draws a series of closed polygons. Each polygon is outlined by using the current pen and filled by using the current brush and polygon fill mode. The polygons drawn by this function can overlap.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The current position is neither used nor updated by this function. Any extra points are ignored. To draw the polygons with more points, divide your data into groups, each of which have less than the maximum number of points, and call the function for each group of points. Note, it is best to have a polygon in only one of the groups. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PolyPolygon",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lpPoints",
        "description": "A pointer to an array of POINT structures that define the vertices of the polygons, in logical coordinates. The polygons are specified consecutively. Each polygon is closed automatically by drawing a line from the last vertex to the first. Each vertex should be specified once."
      },
      {
        "in_out": "_In_",
        "type": "const INT*",
        "name": "lpPolyCounts",
        "description": "A pointer to an array of integers, each of which specifies the number of points in the corresponding polygon. Each integer must be greater than or equal to 2."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nCount",
        "description": "The total number of polygons."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The Rectangle function draws a rectangle. The rectangle is outlined by using the current pen and filled by using the current brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The current position is neither used nor updated by Rectangle. The rectangle that is drawn excludes the bottom and right edges. If a PS_NULL pen is used, the dimensions of the rectangle are 1 pixel less in height and 1 pixel less in width. For an example, see Using Filled Shapes. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "Rectangle",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical coordinates, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical coordinates, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical coordinates, of the lower-right corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical coordinates, of the lower-right corner of the rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The RoundRect function draws a rectangle with rounded corners. The rectangle is outlined by using the current pen and filled by using the current brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The current position is neither used nor updated by this function. For an example, see Using Filled Shapes. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "RoundRect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical coordinates, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical coordinates, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical coordinates, of the lower-right corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical coordinates, of the lower-right corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width, in logical coordinates, of the ellipse used to draw the rounded corners."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in logical coordinates, of the ellipse used to draw the rounded corners."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The AnimatePalette function replaces entries in the specified logical palette.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. The AnimatePalette function only changes entries with the PC_RESERVED flag set in the corresponding palPalEntry member of the LOGPALETTE structure. If the given palette is associated with the active window, the colors in the palette are replaced immediately. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "AnimatePalette",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "A handle to the logical palette."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iStartIndex",
        "description": "The first logical palette entry to be replaced."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cEntries",
        "description": "The number of entries to be replaced."
      },
      {
        "in_out": "_In_",
        "type": "const PALETTEENTRY*",
        "name": "ppe",
        "description": "A pointer to the first member in an array of PALETTEENTRY structures used to replace the current entries."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateHalftonePalette function creates a halftone palette for the specified device context (DC).",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a logical halftone palette. If the function fails, the return value is zero. ",
    "remarks": "An application should create a halftone palette when the stretching mode of a device context is set to HALFTONE. The logical halftone palette returned by CreateHalftonePalette should then be selected and realized into the device context before the StretchBlt or StretchDIBits function is called. When you no longer need the palette, call the DeleteObject function to delete it. ",
    "return_type": "HPALETTE",
    "category": "Windows GDI",
    "name": "CreateHalftonePalette",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreatePalette function creates a logical palette.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a logical palette. If the function fails, the return value is NULL. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. Once an application creates a logical palette, it can select that palette into a device context by calling the SelectPalette function. A palette selected into a device context can be realized by calling the RealizePalette function. When you no longer need the palette, call the DeleteObject function to delete it. ",
    "return_type": "HPALETTE",
    "category": "Windows GDI",
    "name": "CreatePalette",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const LOGPALETTE*",
        "name": "lplgpl",
        "description": "A pointer to a LOGPALETTE structure that contains information about the colors in the logical palette."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetColorAdjustment function retrieves the color adjustment values for the specified device context (DC).",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "GetColorAdjustment",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_Out_",
        "type": "LPCOLORADJUSTMENT",
        "name": "lpca",
        "description": "A pointer to a COLORADJUSTMENT structure that receives the color adjustment values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetNearestColor function retrieves a color value identifying a color from the system palette that will be displayed when the specified color value is used.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a color from the system palette that corresponds to the given color value. If the function fails, the return value is CLR_INVALID. ",
    "remarks": "",
    "return_type": "COLORREF",
    "category": "Windows GDI",
    "name": "GetNearestColor",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "A color value that identifies a requested color. To create a COLORREF color value, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetNearestPaletteIndex function retrieves the index for the entry in the specified logical palette most closely matching a specified color value.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the index of an entry in a logical palette. If the function fails, the return value is CLR_INVALID. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. If the given logical palette contains entries with the PC_EXPLICIT flag set, the return value is undefined. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetNearestPaletteIndex",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "A handle to a logical palette."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "A color to be matched. To create a COLORREF color value, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetPaletteEntries function retrieves a specified range of palette entries from the given logical palette.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds and the handle to the logical palette is a valid pointer (not NULL), the return value is the number of entries retrieved from the logical palette. If the function succeeds and handle to the logical palette is NULL, the return value is the number of entries in the given palette. If the function fails, the return value is zero. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. If the nEntries parameter specifies more entries than exist in the palette, the remaining members of the PALETTEENTRY structure are not altered. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetPaletteEntries",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "A handle to the logical palette."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iStartIndex",
        "description": "The first entry in the logical palette to be retrieved."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nEntries",
        "description": "The number of entries in the logical palette to be retrieved."
      },
      {
        "in_out": "_Out_",
        "type": "LPPALETTEENTRY",
        "name": "lppe",
        "description": "A pointer to an array of PALETTEENTRY structures to receive the palette entries. The array must contain at least as many structures as specified by the nEntries parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetSystemPaletteEntries function retrieves a range of palette entries from the system palette that is associated with the specified device context (DC).",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of entries retrieved from the palette. If the function fails, the return value is zero. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetSystemPaletteEntries",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iStartIndex",
        "description": "The first entry to be retrieved from the system palette."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nEntries",
        "description": "The number of entries to be retrieved from the system palette."
      },
      {
        "in_out": "_Out_",
        "type": "LPPALETTEENTRY",
        "name": "lppe",
        "description": "A pointer to an array of PALETTEENTRY structures to receive the palette entries. The array must contain at least as many structures as specified by the nEntries parameter. If this parameter is NULL, the function returns the total number of entries in the palette."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetSystemPaletteUse function retrieves the current state of the system (physical) palette for the specified device context (DC).",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the current state of the system palette. This parameter can be one of the following values.  ",
    "remarks": "By default, the system palette contains 20 static colors that are not changed when an application realizes its logical palette. An application can gain access to most of these colors by calling the SetSystemPaletteUse function. The device context identified by the hdc parameter must represent a device that supports color palettes. An application can determine whether a device supports color palettes by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetSystemPaletteUse",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The RealizePalette function maps palette entries from the current logical palette to the system palette.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of entries in the logical palette mapped to the system palette. If the function fails, the return value is GDI_ERROR. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. The RealizePalette function modifies the palette for the device associated with the specified device context. If the device context is a memory DC, the color table for the bitmap selected into the DC is modified. If the device context is a display DC, the physical palette for that device is modified. A logical palette is a buffer between color-intensive applications and the system, allowing these applications to use as many colors as needed without interfering with colors displayed by other windows. When an application's window has the focus and it calls the RealizePalette function, the system attempts to realize as many of the requested colors as possible. The same is also true for applications with inactive windows. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "RealizePalette",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context into which a logical palette has been selected."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The ResizePalette function increases or decreases the size of a logical palette based on the specified value.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. If an application calls ResizePalette to reduce the size of the palette, the entries remaining in the resized palette are unchanged. If the application calls ResizePalette to enlarge the palette, the additional palette entries are set to black (the red, green, and blue values are all 0) and their flags are set to zero. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "ResizePalette",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "A handle to the palette to be changed."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "nEntries",
        "description": "The number of entries in the palette after it has been resized. The number of entries is limited to 1024."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SelectPalette function selects the specified logical palette into a device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the device context's previous logical palette. If the function fails, the return value is NULL. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. An application can select a logical palette into more than one device context only if device contexts are compatible. Otherwise SelectPalette fails. To create a device context that is compatible with another device context, call CreateCompatibleDC with the first device context as the parameter. If a logical palette is selected into more than one device context, changes to the logical palette will affect all device contexts for which it is selected. An application might call the SelectPalette function with the bForceBackground parameter set to TRUE if the child windows of a top-level window each realize their own palettes. However, only the child window that needs to realize its palette must set bForceBackground to TRUE; other child windows must set this value to FALSE. ",
    "return_type": "HPALETTE",
    "category": "Windows GDI",
    "name": "SelectPalette",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "A handle to the logical palette to be selected."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bForceBackground",
        "description": "Specifies whether the logical palette is forced to be a background palette. If this value is TRUE, the RealizePalette function causes the logical palette to be mapped to the colors already in the physical palette in the best possible way. This is always done, even if the window for which the palette is realized belongs to a thread without active focus. If this value is FALSE, RealizePalette causes the logical palette to be copied into the device palette when the application is in the foreground. (If the hdc parameter is a memory device context, this parameter is ignored.)"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetColorAdjustment function sets the color adjustment values for a device context (DC) using the specified values.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The color adjustment values are used to adjust the input color of the source bitmap for calls to the StretchBlt and StretchDIBits functions when HALFTONE mode is set. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetColorAdjustment",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const COLORADJUSTMENT*",
        "name": "lpca",
        "description": "A pointer to a COLORADJUSTMENT structure containing the color adjustment values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SetPaletteEntries function sets RGB (red, green, blue) color values and flags in a range of entries in a logical palette.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of entries that were set in the logical palette. If the function fails, the return value is zero. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. Even if a logical palette has been selected and realized, changes to the palette do not affect the physical palette in the surface. RealizePalette must be called again to set the new logical palette into the surface. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "SetPaletteEntries",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HPALETTE",
        "name": "hpal",
        "description": "A handle to the logical palette."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iStart",
        "description": "The first logical-palette entry to be set."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cEntries",
        "description": "The number of logical-palette entries to be set."
      },
      {
        "in_out": "_In_",
        "type": "const PALETTEENTRY*",
        "name": "lppe",
        "description": "A pointer to the first member of an array of PALETTEENTRY structures containing the RGB values and flags."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetSystemPaletteUse function allows an application to specify whether the system palette contains 2 or 20 static colors. The default system palette contains 20 static colors. (Static colors cannot be changed when an application realizes a logical palette.)",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the previous system palette. It can be either SYSPAL_NOSTATIC, SYSPAL_NOSTATIC256, or SYSPAL_STATIC. If the function fails, the return value is SYSPAL_ERROR. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. When an application window moves to the foreground and the SYSPAL_NOSTATIC value is set, the application must call the GetSysColor function to save the current system colors setting. It must also call SetSysColors to set reasonable values using only black and white. When the application returns to the background or terminates, the previous system colors must be restored. If the function returns SYSPAL_ERROR, the specified device context is invalid or does not support color palettes. An application must call this function only when its window is maximized and has the input focus. If an application calls SetSystemPaletteUse with uUsage set to SYSPAL_NOSTATIC, the system continues to set aside two entries in the system palette for pure white and pure black, respectively. After calling this function with uUsage set to SYSPAL_NOSTATIC, an application must take the following steps: When the application's window loses focus or closes, the application must perform the following steps: ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "SetSystemPaletteUse",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context. This device context must refer to a device that supports color palettes."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uUsage",
        "description": "The new use of the system palette. This parameter can be one of the following values.  ValueMeaning  SYSPAL_NOSTATIC   The system palette contains two static colors (black and white).   SYSPAL_NOSTATIC256   The system palette contains no static colors.   SYSPAL_STATIC   The system palette contains static colors that will not change when an application realizes its logical palette."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The UnrealizeObject function resets the origin of a brush or resets a logical palette. If the hgdiobj parameter is a handle to a brush, UnrealizeObject directs the system to reset the origin of the brush the next time it is selected. If the hgdiobj parameter is a handle to a logical palette, UnrealizeObject directs the system to realize the palette as though it had not previously been realized. The next time the application calls the RealizePalette function for the specified palette, the system completely remaps the logical palette to the system palette.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The UnrealizeObject function should not be used with stock objects. For example, the default palette, obtained by calling GetStockObject (DEFAULT_PALETTE), is a stock object. A palette identified by hgdiobj can be the currently selected palette of a device context. If hgdiobj is a brush, UnrealizeObject does nothing, and the function returns TRUE. Use SetBrushOrgEx to set the origin of a brush. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "UnrealizeObject",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGDIOBJ",
        "name": "hgdiobj",
        "description": "A handle to the logical palette to be reset."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The UpdateColors function updates the client area of the specified device context by remapping the current colors in the client area to the currently realized logical palette.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "An application can determine whether a device supports palette operations by calling the GetDeviceCaps function and specifying the RASTERCAPS constant. An inactive window with a realized logical palette may call UpdateColors as an alternative to redrawing its client area when the system palette changes. The UpdateColors function typically updates a client area faster than redrawing the area. However, because UpdateColors performs the color translation based on the color of each pixel before the system palette changed, each call to this function results in the loss of some color accuracy. This function must be called soon after a WM_PALETTECHANGED message is received. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "UpdateColors",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The ExcludeClipRect function creates a new clipping region that consists of the existing clipping region minus the specified rectangle.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the new clipping region's complexity; it can be one of the following values.  ",
    "remarks": "The lower and right edges of the specified rectangle are not excluded from the clipping region. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "ExcludeClipRect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical units, of the lower-right corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical units, of the lower-right corner of the rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The ExtSelectClipRgn function combines the specified region with the current clipping region using the specified mode.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the new clipping region's complexity; it can be one of the following values.  ",
    "remarks": "If an error occurs when this function is called, the previous clipping region for the specified device context is not affected. The ExtSelectClipRgn function assumes that the coordinates for the specified region are specified in device units. Only a copy of the region identified by the hrgn parameter is used. The region itself can be reused after this call or it can be deleted. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "ExtSelectClipRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "A handle to the region to be selected. This handle must not be NULL unless the RGN_COPY mode is specified."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "fnMode",
        "description": "The operation to be performed. It must be one of the following values.  ValueMeaning  RGN_AND   The new clipping region combines the overlapping areas of the current clipping region and the region identified by hrgn.   RGN_COPY   The new clipping region is a copy of the region identified by hrgn. This is identical to SelectClipRgn. If the region identified by hrgn is NULL, the new clipping region is the default clipping region (the default clipping region is a null region).   RGN_DIFF   The new clipping region combines the areas of the current clipping region with those areas excluded from the region identified by hrgn.   RGN_OR   The new clipping region combines the current clipping region and the region identified by hrgn.   RGN_XOR   The new clipping region combines the current clipping region and the region identified by hrgn but excludes any overlapping areas."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetClipBox function retrieves the dimensions of the tightest bounding rectangle that can be drawn around the current visible area on the device. The visible area is defined by the current clipping region or clip path, as well as any overlapping windows.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value specifies the clipping box's complexity and can be one of the following values.  GetClipBox returns logical coordinates based on the given device context. ",
    "remarks": "",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetClipBox",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_Out_",
        "type": "LPRECT",
        "name": "lprc",
        "description": "A pointer to a RECT structure that is to receive the rectangle dimensions, in logical units."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetClipRgn function retrieves a handle identifying the current application-defined clipping region for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds and there is no clipping region for the given device context, the return value is zero. If the function succeeds and there is a clipping region for the given device context, the return value is 1. If an error occurs, the return value is -1. ",
    "remarks": "An application-defined clipping region is a clipping region identified by the SelectClipRgn function. It is not a clipping region created when the application calls the BeginPaint function. If the function succeeds, the hrgn parameter is a handle to a copy of the current clipping region. Subsequent changes to this copy will not affect the current clipping region. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetClipRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "A handle to an existing region before the function is called. After the function returns, this parameter is a handle to a copy of the current clipping region."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetMetaRgn function retrieves the current metaregion for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "If the function succeeds, hrgn is a handle to a copy of the current metaregion. Subsequent changes to this copy will not affect the current metaregion. The current clipping region of a device context is defined by the intersection of its clipping region and its metaregion. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetMetaRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "A handle to an existing region before the function is called. After the function returns, this parameter is a handle to a copy of the current metaregion."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetRandomRgn function copies the system clipping region of a specified device context to a specific region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is 1. If the function fails, the return value is -1. If the region to be retrieved is NULL, the return value is 0. If the function fails or the region to be retrieved is NULL, hrgn is not initialized. ",
    "remarks": "When using the SYSRGN flag, note that the system clipping region might not be current because of window movements. Nonetheless, it is safe to retrieve and use the system clipping region within the BeginPaint-EndPaint block during WM_PAINT processing. In this case, the system region is the intersection of the update region and the current visible area of the window. Any window movement following the return of GetRandomRgn and before EndPaint will result in a new WM_PAINT message. Any other use of the SYSRGN flag may result in painting errors in your application. The region returned is in screen coordinates. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetRandomRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "A handle to a region. Before the function is called, this identifies an existing region. After the function returns, this identifies a copy of the current system region. The old region identified by hrgn is overwritten."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "iNum",
        "description": "This parameter must be SYSRGN."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The IntersectClipRect function creates a new clipping region from the intersection of the current clipping region and the specified rectangle.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the new clipping region's type and can be one of the following values.  ",
    "remarks": "The lower and right-most edges of the given rectangle are excluded from the clipping region. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "IntersectClipRect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nLeftRect",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nTopRect",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nRightRect",
        "description": "The x-coordinate, in logical units, of the lower-right corner of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nBottomRect",
        "description": "The y-coordinate, in logical units, of the lower-right corner of the rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The OffsetClipRgn function moves the clipping region of a device context by the specified offsets.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the new region's complexity and can be one of the following values.  ",
    "remarks": "",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "OffsetClipRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXOffset",
        "description": "The number of logical units to move left or right."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYOffset",
        "description": "The number of logical units to move up or down."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The PtVisible function determines whether the specified point is within the clipping region of a device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the specified point is within the clipping region of the device context, the return value is TRUE(1). If the specified point is not within the clipping region of the device context, the return value is FALSE(0). If the HDC is not valid, the return value is (BOOL)-1. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PtVisible",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "The x-coordinate, in logical units, of the point."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "The y-coordinate, in logical units, of the point."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The RectVisible function determines whether any part of the specified rectangle lies within the clipping region of a device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the current transform does not have a rotation and the rectangle lies within the clipping region, the return value is TRUE (1). If the current transform does not have a rotation and the rectangle does not lie within the clipping region, the return value is FALSE (0). If the current transform has a rotation and the rectangle lies within the clipping region, the return value is 2. If the current transform has a rotation and the rectangle does not lie within the clipping region, the return value is 1. All other return values are considered error codes. If the any parameter is not valid, the return value is undefined. For an example, see Redrawing in the Update Region. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "RectVisible",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "const RECT*",
        "name": "lprc",
        "description": "A pointer to a RECT structure that contains the logical coordinates of the specified rectangle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SelectClipPath function selects the current path as a clipping region for a device context, combining the new region with any existing clipping region using the specified mode.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.  If the function fails, GetLastError may return one of the following error codes:  If the function fails, GetLastError may return one of the following error codes: ",
    "remarks": "The device context identified by the hdc parameter must contain a closed path. For an example, see Using Clipping. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SelectClipPath",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context of the path."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "iMode",
        "description": "The way to use the path. This parameter can be one of the following values.  ValueMeaning  RGN_AND   The new clipping region includes the intersection (overlapping areas) of the current clipping region and the current path.   RGN_COPY   The new clipping region is the current path.   RGN_DIFF   The new clipping region includes the areas of the current clipping region with those of the current path excluded.   RGN_OR   The new clipping region includes the union (combined areas) of the current clipping region and the current path.   RGN_XOR   The new clipping region includes the union of the current clipping region and the current path but without the overlapping areas."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SelectClipRgn function selects a region as the current clipping region for the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the region's complexity and can be one of the following values.  ",
    "remarks": "Only a copy of the selected region is used. The region itself can be selected for any number of other device contexts or it can be deleted. The SelectClipRgn function assumes that the coordinates for a region are specified in device units. To remove a device-context's clipping region, specify a NULL region handle. For an example, see Clipping Output. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "SelectClipRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HRGN",
        "name": "hrgn",
        "description": "A handle to the region to be selected."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The SetMetaRgn function intersects the current clipping region for the specified device context with the current metaregion and saves the combined region as the new metaregion for the specified device context. The clipping region is reset to a null region.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value specifies the new clipping region's complexity and can be one of the following values.  ",
    "remarks": "The current clipping region of a device context is defined by the intersection of its clipping region and its metaregion. The SetMetaRgn function should only be called after an application's original device context was saved by calling the SaveDC function. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "SetMetaRgn",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateBrushIndirect function creates a logical brush that has the specified style, color, and pattern.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a logical brush. If the function fails, the return value is NULL. ",
    "remarks": "A brush is a bitmap that the system uses to paint the interiors of filled shapes. After an application creates a brush by calling CreateBrushIndirect, it can select it into any device context by calling the SelectObject function. A brush created by using a monochrome bitmap (one color plane, one bit per pixel) is drawn using the current text and background colors. Pixels represented by a bit set to 0 are drawn with the current text color; pixels represented by a bit set to 1 are drawn with the current background color. When you no longer need the brush, call the DeleteObject function to delete it. ICM: No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context. ",
    "return_type": "HBRUSH",
    "category": "Windows GDI",
    "name": "CreateBrushIndirect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const LOGBRUSH*",
        "name": "lplb",
        "description": "A pointer to a LOGBRUSH structure that contains information about the brush."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CreateDIBPatternBrushPt function creates a logical brush that has the pattern specified by the device-independent bitmap (DIB).",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a logical brush. If the function fails, the return value is NULL. ",
    "remarks": "A brush is a bitmap that the system uses to paint the interiors of filled shapes. After an application creates a brush by calling CreateDIBPatternBrushPt, it can select that brush into any device context by calling the SelectObject function. When you no longer need the brush, call the DeleteObject function to delete it. ICM: No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context. ",
    "return_type": "HBRUSH",
    "category": "Windows GDI",
    "name": "CreateDIBPatternBrushPt",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lpPackedDIB",
        "description": "A pointer to a packed DIB consisting of a BITMAPINFO structure immediately followed by an array of bytes defining the pixels of the bitmap."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iUsage",
        "description": "Specifies whether the bmiColors member of the BITMAPINFO structure contains a valid color table and, if so, whether the entries in this color table contain explicit red, green, blue (RGB) values or palette indexes. The iUsage parameter must be one of the following values.  ValueMeaning  DIB_PAL_COLORS   A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the brush is to be selected.   DIB_RGB_COLORS   A color table is provided and contains literal RGB values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CreateHatchBrush function creates a logical brush that has the specified hatch pattern and color.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a logical brush. If the function fails, the return value is NULL. ",
    "remarks": "A brush is a bitmap that the system uses to paint the interiors of filled shapes. After an application creates a brush by calling CreateHatchBrush, it can select that brush into any device context by calling the SelectObject function. It can also call SetBkMode to affect the rendering of the  brush. If an application uses a hatch brush to fill the backgrounds of both a parent and a child window with matching color, you must  set the brush origin before painting the background of the child window. You can do this by  calling the SetBrushOrgEx function. Your application can retrieve the current brush origin by calling the GetBrushOrgEx function. When you no longer need the brush, call the DeleteObject function to delete it. ICM: No color is defined  at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context. The following example creates a logical brush that has the specified hatch pattern and color. You can also  set a hatch brush background to transparent or to opaque. ",
    "return_type": "HBRUSH",
    "category": "Windows GDI",
    "name": "CreateHatchBrush",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "fnStyle",
        "description": "The hatch style of the brush. This parameter can be one of the following values.  ValueMeaning  HS_BDIAGONAL   45-degree upward left-to-right hatch   HS_CROSS   Horizontal and vertical crosshatch   HS_DIAGCROSS   45-degree crosshatch   HS_FDIAGONAL   45-degree downward left-to-right hatch   HS_HORIZONTAL   Horizontal hatch   HS_VERTICAL   Vertical hatch"
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "clrref",
        "description": "The foreground color of the brush that is used for the hatches. To create a COLORREF color value, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreatePatternBrush function creates a logical brush with the specified bitmap pattern. The bitmap can be a DIB section bitmap, which is created by the CreateDIBSection function, or it can be a device-dependent bitmap.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a logical brush. If the function fails, the return value is NULL. ",
    "remarks": "A pattern brush is a bitmap that the system uses to paint the interiors of filled shapes. After an application creates a brush by calling CreatePatternBrush, it can select that brush into any device context by calling the SelectObject function. You can delete a pattern brush without affecting the associated bitmap by using the DeleteObject function. Therefore, you can then use this bitmap to create any number of pattern brushes. A brush created by using a monochrome (1 bit per pixel) bitmap has the text and background colors of the device context to which it is drawn. Pixels represented by a 0 bit are drawn with the current text color; pixels represented by a 1 bit are drawn with the current background color. ICM: No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context. For an example, see Using Brushes. ",
    "return_type": "HBRUSH",
    "category": "Windows GDI",
    "name": "CreatePatternBrush",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hbmp",
        "description": "A handle to the bitmap to be used to create the logical brush."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateSolidBrush function creates a logical brush that has the specified solid color.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a logical brush. If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the HBRUSH object, call the DeleteObject function to delete it. A solid brush is a bitmap that the system uses to paint the interiors of filled shapes. After an application creates a brush by calling CreateSolidBrush, it can select that brush into any device context by calling the SelectObject function. To paint with a system color brush, an application should use GetSysColorBrush (nIndex) instead of CreateSolidBrush(GetSysColor(nIndex)), because GetSysColorBrush returns a cached brush instead of allocating a new one. ICM: No color management is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context. For an example, see Creating Colored Pens and Brushes. ",
    "return_type": "HBRUSH",
    "category": "Windows GDI",
    "name": "CreateSolidBrush",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "The color of the brush. To create a COLORREF color value, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetBrushOrgEx function retrieves the current brush origin for the specified device context. This function replaces the GetBrushOrg function.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "A brush is a bitmap that the system uses to paint the interiors of filled shapes. The brush origin is a set of coordinates with values between 0 and 7, specifying the location of one pixel in the bitmap. The default brush origin coordinates are (0,0). For horizontal coordinates, the value 0 corresponds to the leftmost column of pixels; the value 7 corresponds to the rightmost column. For vertical coordinates, the value 0 corresponds to the uppermost row of pixels; the value 7 corresponds to the lowermost row. When the system positions the brush at the start of any painting operation, it maps the origin of the brush to the location in the window's client area specified by the brush origin. For example, if the origin is set to (2,3), the system maps the origin of the brush (0,0) to the location (2,3) on the window's client area. If an application uses a brush to fill the backgrounds of both a parent and a child window with matching colors, it may be necessary to set the brush origin after painting the parent window but before painting the child window. The system automatically tracks the origin of all window-managed device contexts and adjusts their brushes as necessary to maintain an alignment of patterns on the surface. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "GetBrushOrgEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_Out_",
        "type": "LPPOINT",
        "name": "lppt",
        "description": "A pointer to a POINT structure that receives the brush origin, in device coordinates."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetSysColorBrush function retrieves a handle identifying a logical brush that corresponds to the specified color index.",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "The return value identifies a logical brush if the nIndex parameter is supported by the current platform. Otherwise, it returns NULL. ",
    "remarks": "A brush is a bitmap that the system uses to paint the interiors of filled shapes. An application can retrieve the current system colors by calling the GetSysColor function. An application can set the current system colors by calling the SetSysColors function. An application must not register a window class for a window using a system brush. To register a window class with a system color, see the documentation of the hbrBackground member of the WNDCLASS or WNDCLASSEX structures. System color brushes track changes in system colors. In other words, when the user changes a system color, the associated system color brush automatically changes to the new color. To paint with a system color brush, an application should use GetSysColorBrush (nIndex) instead of CreateSolidBrush ( GetSysColor (nIndex)), because GetSysColorBrush returns a cached brush instead of allocating a new one. System color brushes are owned by the system so you don't need to destroy them. Although you don't need to delete the logical brush that GetSysColorBrush returns, no harm occurs by calling DeleteObject. ",
    "return_type": "HBRUSH",
    "category": "Windows GDI",
    "name": "GetSysColorBrush",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nIndex",
        "description": "A color index. This value corresponds to the color used to paint one of the window elements. See GetSysColor for system color index values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The PatBlt function paints the specified rectangle using the brush that is currently selected into the specified device context. The brush color and the surface color or colors are combined by using the specified raster operation.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The values of the dwRop parameter for this function are a limited subset of the full 256 ternary raster-operation codes; in particular, an operation code that refers to a source rectangle cannot be used. Not all devices support the PatBlt function. For more information, see the description of the RC_BITBLT capability in the GetDeviceCaps function. For an example, see \"Example of Menu-Item Bitmaps\" in Using Menus. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PatBlt",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXLeft",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the rectangle to be filled."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYLeft",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the rectangle to be filled."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width, in logical units, of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in logical units, of the rectangle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRop",
        "description": "The raster operation code. This code can be one of the following values.  ValueMeaning  PATCOPY   Copies the specified pattern into the destination bitmap.   PATINVERT   Combines the colors of the specified pattern with the colors of the destination rectangle by using the Boolean XOR operator.   DSTINVERT   Inverts the destination rectangle.   BLACKNESS   Fills the destination rectangle using the color associated with index 0 in the physical palette. (This color is black for the default physical palette.)   WHITENESS   Fills the destination rectangle using the color associated with index 1 in the physical palette. (This color is white for the default physical palette.)"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SetBrushOrgEx function sets the brush origin that GDI assigns to the next brush an application selects into the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "A brush is a bitmap that the system uses to paint the interiors of filled shapes. The brush origin is a pair of coordinates specifying the location of one pixel in the bitmap. The default brush origin coordinates are (0,0). For horizontal coordinates, the value 0 corresponds to the leftmost column of pixels; the width corresponds to the rightmost column. For vertical coordinates, the value 0 corresponds to the uppermost row of pixels; the height corresponds to the lowermost row. The system automatically tracks the origin of all window-managed device contexts and adjusts their brushes as necessary to maintain an alignment of patterns on the surface. The brush origin that is set with this call is relative to the upper-left corner of the client area. An application should call SetBrushOrgEx after setting the bitmap stretching mode to HALFTONE by using SetStretchBltMode. This must be done to avoid brush misalignment. The system automatically tracks the origin of all window-managed device contexts and adjusts their brushes as necessary to maintain an alignment of patterns on the surface. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetBrushOrgEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXOrg",
        "description": "The x-coordinate, in device units, of the new brush origin. If this value is greater than the brush width, its value is reduced using the modulus operator (nXOrg mod brush width)."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYOrg",
        "description": "The y-coordinate, in device units, of the new brush origin. If this value is greater than the brush height, its value is reduced using the modulus operator (nYOrg mod brush height)."
      },
      {
        "in_out": "_Out_",
        "type": "LPPOINT",
        "name": "lppt",
        "description": "A pointer to a POINT structure that receives the previous brush origin. This parameter can be NULL if the previous brush origin is not required."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The CreateDIBPatternBrush function creates a logical brush that has the pattern specified by the specified device-independent bitmap (DIB). The brush can subsequently be selected into any device context that is associated with a device that supports raster operations.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value identifies a logical brush. If the function fails, the return value is NULL. ",
    "remarks": "When an application selects a two-color DIB pattern brush into a monochrome device context, the system does not acknowledge the colors specified in the DIB; instead, it displays the pattern brush using the current background and foreground colors of the device context. Pixels mapped to the first color of the DIB (offset 0 in the DIB color table) are displayed using the foreground color; pixels mapped to the second color (offset 1 in the color table) are displayed using the background color. When you no longer need the brush, call the DeleteObject function to delete it. ICM: No color is done at brush creation. However, color management is performed when the brush is selected into an ICM-enabled device context. ",
    "return_type": "HBRUSH",
    "category": "Windows GDI",
    "name": "CreateDIBPatternBrush",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HGLOBAL",
        "name": "hglbDIBPacked",
        "description": "A handle to a global memory object containing a packed DIB, which consists of a BITMAPINFO structure immediately followed by an array of bytes defining the pixels of the bitmap."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuColorSpec",
        "description": "Specifies whether the bmiColors member of the BITMAPINFO structure is initialized and, if so, whether this member contains explicit red, green, blue (RGB) values or indexes into a logical palette. The fuColorSpec parameter must be one of the following values.  ValueMeaning  DIB_PAL_COLORS   A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the brush is to be selected.   DIB_RGB_COLORS   A color table is provided and contains literal RGB values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "The AlphaBlend function displays bitmaps that have transparent or semitransparent pixels.",
    "library": "Msimg32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "WinGdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. ",
    "remarks": "If the source rectangle and destination rectangle are not the same size, the source bitmap is stretched to match the destination rectangle. If the SetStretchBltMode function is used, the iStretchMode value is automatically converted to COLORONCOLOR for this function (that is, BLACKONWHITE, WHITEONBLACK, and HALFTONE are changed to COLORONCOLOR). The destination coordinates are transformed by using the transformation currently specified for the destination device context. The source coordinates are transformed by using the transformation currently specified for the source device context. An error occurs (and the function returns FALSE) if the source device context identifies an enhanced metafile device context. If destination and source bitmaps do not have the same color format, AlphaBlend converts the source bitmap to match the destination bitmap. AlphaBlend does not support mirroring. If either the width or height of the source or destination is negative, this call will fail. When rendering to a printer, first call GetDeviceCaps with SHADEBLENDCAPS to determine if the printer supports blending with AlphaBlend. Note that, for a display DC, all blending operations are supported and these flags represent whether the operations are accelerated. If the source and destination are the same surfacethat is, they are both the screen or the same memory bitmap and the source and destination rectangles overlap, an error occurs and the function returns FALSE. The source rectangle must lie completely within the source surface, otherwise an error occurs and the function returns FALSE. AlphaBlend fails if the width or height of the source or destination is negative. The SourceConstantAlpha member of BLENDFUNCTION specifies an alpha transparency value to be used on the entire source bitmap. The SourceConstantAlpha value is combined with any per-pixel alpha values. If SourceConstantAlpha is 0, it is assumed that the image is transparent. Set the SourceConstantAlpha value to 255 (which indicates that the image is opaque) when you only want to use per-pixel alpha values. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "AlphaBlend",
    "is_callback": 0,
    "dll": "Msimg32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcDest",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xoriginDest",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yoriginDest",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "wDest",
        "description": "The width, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "hDest",
        "description": "The height, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcSrc",
        "description": "A handle to the source device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xoriginSrc",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yoriginSrc",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "wSrc",
        "description": "The width, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "hSrc",
        "description": "The height, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "BLENDFUNCTION",
        "name": "ftn",
        "description": "The alpha-blending function for source and destination bitmaps, a global alpha value to be applied to the entire source bitmap, and format information for the source bitmap. The source and destination blend functions are currently limited to AC_SRC_OVER. See the BLENDFUNCTION and EMRALPHABLEND structures."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "BitBlt only does clipping on the destination DC. If a rotation or shear transformation is in effect in the source device context, BitBlt returns an error. If other transformations exist in the source device context (and a matching transformation is not in effect in the destination device context), the rectangle in the destination device context is stretched, compressed, or rotated, as necessary. If the color formats of the source and destination device contexts do not match, the BitBlt function converts the source color format to match the destination format. When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context. Not all devices support the BitBlt function. For more information, see the RC_BITBLT raster capability entry in the GetDeviceCaps function as well as the following functions: MaskBlt, PlgBlt, and StretchBlt. BitBlt returns an error if the source and destination device contexts represent different devices. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling GetDIBits. To display the DIB to the second device, call SetDIBits or StretchDIBits. ICM: No color management is performed when blits occur. For an example, see Capturing an Image. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "BitBlt",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcDest",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXDest",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYDest",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width, in logical units, of the source and destination rectangles."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in logical units, of the source and the destination rectangles."
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcSrc",
        "description": "A handle to the source device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXSrc",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYSrc",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRop",
        "description": "A raster-operation code. These codes define how the color data for the source rectangle is to be combined with the color data for the destination rectangle to achieve the final color. The following list shows some common raster operation codes.  ValueMeaning  BLACKNESS   Fills the destination rectangle using the color associated with index 0 in the physical palette. (This color is black for the default physical palette.)   CAPTUREBLT   Includes any windows that are layered on top of your window in the resulting image. By default, the image only contains your window. Note that this generally cannot be used for printing device contexts.   DSTINVERT   Inverts the destination rectangle.   MERGECOPY   Merges the colors of the source rectangle with the brush currently selected in hdcDest, by using the Boolean AND operator.   MERGEPAINT   Merges the colors of the inverted source rectangle with the colors of the destination rectangle by using the Boolean OR operator.   NOMIRRORBITMAP   Prevents the bitmap from being mirrored.   NOTSRCCOPY   Copies the inverted source rectangle to the destination.   NOTSRCERASE   Combines the colors of the source and destination rectangles by using the Boolean OR operator and then inverts the resultant color.   PATCOPY   Copies the brush currently selected in hdcDest, into the destination bitmap.   PATINVERT   Combines the colors of the brush currently selected in hdcDest, with the colors of the destination rectangle by using the Boolean XOR operator.   PATPAINT   Combines the colors of the brush currently selected in hdcDest, with the colors of the inverted source rectangle by using the Boolean OR operator. The result of this operation is combined with the colors of the destination rectangle by using the Boolean OR operator.   SRCAND   Combines the colors of the source and destination rectangles by using the Boolean AND operator.   SRCCOPY   Copies the source rectangle directly to the destination rectangle.   SRCERASE   Combines the inverted colors of the destination rectangle with the colors of the source rectangle by using the Boolean AND operator.   SRCINVERT   Combines the colors of the source and destination rectangles by using the Boolean XOR operator.   SRCPAINT   Combines the colors of the source and destination rectangles by using the Boolean OR operator.   WHITENESS   Fills the destination rectangle using the color associated with index 1 in the physical palette. (This color is white for the default physical palette.)"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The CreateBitmap function creates a bitmap with the specified width, height, and color format (color planes and bits-per-pixel).",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to a bitmap. If the function fails, the return value is NULL. This function can return the following value.  ",
    "remarks": "The CreateBitmap function creates a device-dependent bitmap. After a bitmap is created, it can be selected into a device context by calling the SelectObject function. However, the bitmap can only be selected into a device context if the bitmap and the DC have the same format. The CreateBitmap function can be used to create color bitmaps. However, for performance reasons applications should use CreateBitmap to create monochrome bitmaps and CreateCompatibleBitmap to create color bitmaps. Whenever a color bitmap returned from CreateBitmap is selected into a device context, the system checks that the bitmap matches the format of the device context it is being selected into. Because CreateCompatibleBitmap takes a device context, it returns a bitmap that has the same format as the specified device context. Thus, subsequent calls to SelectObject are faster with a color bitmap from CreateCompatibleBitmap than with a color bitmap returned from CreateBitmap. If the bitmap is monochrome, zeros represent the foreground color and ones represent the background color for the destination device context. If an application sets the nWidth or nHeight parameters to zero, CreateBitmap returns the handle to a 1-by-1 pixel, monochrome bitmap. When you no longer need the bitmap, call the DeleteObject function to delete it. ",
    "return_type": "HBITMAP",
    "category": "Windows GDI",
    "name": "CreateBitmap",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The bitmap width, in pixels."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The bitmap height, in pixels."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cPlanes",
        "description": "The number of color planes used by the device."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cBitsPerPel",
        "description": "The number of bits required to identify the color of a single pixel."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lpvBits",
        "description": "A pointer to an array of color data used to set the colors in a rectangle of pixels. Each scan line in the rectangle must be word aligned (scan lines that are not word aligned must be padded with zeros). If this parameter is NULL, the contents of the new bitmap is undefined."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The CreateBitmapIndirect function creates a bitmap with the specified width, height, and color format (color planes and bits-per-pixel).",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the bitmap. If the function fails, the return value is NULL. This function can return the following values.  ",
    "remarks": "The CreateBitmapIndirect function creates a device-dependent bitmap. After a bitmap is created, it can be selected into a device context by calling the SelectObject function. However, the bitmap can only be selected into a device context if the bitmap and the DC have the same format. While the CreateBitmapIndirect function can be used to create color bitmaps, for performance reasons applications should use CreateBitmapIndirect to create monochrome bitmaps and CreateCompatibleBitmap to create color bitmaps. Whenever a color bitmap from CreateBitmapIndirect is selected into a device context, the system must ensure that the bitmap matches the format of the device context it is being selected into. Because CreateCompatibleBitmap takes a device context, it returns a bitmap that has the same format as the specified device context. Thus, subsequent calls to SelectObject are faster with a color bitmap from CreateCompatibleBitmap than with a color bitmap returned from CreateBitmapIndirect. If the bitmap is monochrome, zeros represent the foreground color and ones represent the background color for the destination device context. When you no longer need the bitmap, call the DeleteObject function to delete it. ",
    "return_type": "HBITMAP",
    "category": "Windows GDI",
    "name": "CreateBitmapIndirect",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const BITMAP*",
        "name": "lpbm",
        "description": "A pointer to a BITMAP structure that contains information about the bitmap. If an application sets the bmWidth or bmHeight members to zero, CreateBitmapIndirect returns the handle to a 1-by-1 pixel, monochrome bitmap."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CreateCompatibleBitmap function creates a bitmap compatible with the device that is associated with the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the compatible bitmap (DDB). If the function fails, the return value is NULL. ",
    "remarks": "The color format of the bitmap created by the CreateCompatibleBitmap function matches the color format of the device identified by the hdc parameter. This bitmap can be selected into any memory device context that is compatible with the original device. Because memory device contexts allow both color and monochrome bitmaps, the format of the bitmap returned by the CreateCompatibleBitmap function differs when the specified device context is a memory device context. However, a compatible bitmap that was created for a nonmemory device context always possesses the same color format and uses the same color palette as the specified device context. Note: When a memory device context is created, it initially has a 1-by-1 monochrome bitmap selected into it. If this memory device context is used in CreateCompatibleBitmap, the bitmap that is created is a monochrome bitmap. To create a color bitmap, use the HDC that was used to create the memory device context, as shown in the following code: If an application sets the nWidth or nHeight parameters to zero, CreateCompatibleBitmap returns the handle to a 1-by-1 pixel, monochrome bitmap. If a DIB section, which is a bitmap created by the CreateDIBSection function, is selected into the device context identified by the hdc parameter, CreateCompatibleBitmap creates a DIB section. When you no longer need the bitmap, call the DeleteObject function to delete it. For an example, see Scaling an Image. ",
    "return_type": "HBITMAP",
    "category": "Windows GDI",
    "name": "CreateCompatibleBitmap",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The bitmap width, in pixels."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The bitmap height, in pixels."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The CreateDIBitmap function creates a compatible bitmap (DDB) from a DIB and, optionally, sets the bitmap bits.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the compatible bitmap. If the function fails, the return value is NULL. ",
    "remarks": "The DDB that is created will be whatever bit depth your reference DC is. To create a bitmap that is of different bit depth, use CreateDIBSection. For a device to reach optimal bitmap-drawing speed, specify fdwInit as CBM_INIT. Then, use the same color depth DIB as the video mode. When the video is running 4- or 8-bpp, use DIB_PAL_COLORS. The CBM_CREATDIB flag for the fdwInit parameter is no longer supported. When you no longer need the bitmap, call the DeleteObject function to delete it. ICM: No color management is performed. The contents of the resulting bitmap are not color matched after the bitmap has been created. ",
    "return_type": "HBITMAP",
    "category": "Windows GDI",
    "name": "CreateDIBitmap",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "const BITMAPINFOHEADER*",
        "name": "lpbmih",
        "description": "A pointer to a bitmap information header structure, BITMAPV5HEADER. If fdwInit is CBM_INIT, the function uses the bitmap information header structure to obtain the desired width and height of the bitmap as well as other information. Note that a positive value for the height indicates a bottom-up DIB while a negative value for the height indicates a top-down DIB. Calling CreateDIBitmap with fdwInit as CBM_INIT is equivalent to calling the CreateCompatibleBitmap function to create a DDB in the format of the device and then calling the SetDIBits function to translate the DIB bits to the DDB."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "fdwInit",
        "description": "Specifies how the system initializes the bitmap bits. The following value is defined.  ValueMeaning  CBM_INIT   If this flag is set, the system uses the data pointed to by the lpbInit and lpbmi parameters to initialize the bitmap bits. If this flag is clear, the data pointed to by those parameters is not used.     If fdwInit is zero, the system does not initialize the bitmap bits."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lpbInit",
        "description": "A pointer to an array of bytes containing the initial bitmap data. The format of the data depends on the biBitCount member of the BITMAPINFO structure to which the lpbmi parameter points."
      },
      {
        "in_out": "_In_",
        "type": "const BITMAPINFO*",
        "name": "lpbmi",
        "description": "A pointer to a BITMAPINFO structure that describes the dimensions and color format of the array pointed to by the lpbInit parameter."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuUsage",
        "description": "Specifies whether the bmiColors member of the BITMAPINFO structure was initialized and, if so, whether bmiColors contains explicit red, green, blue (RGB) values or palette indexes. The fuUsage parameter must be one of the following values.  ValueMeaning  DIB_PAL_COLORS   A color table is provided and consists of an array of 16-bit indexes into the logical palette of the device context into which the bitmap is to be selected.   DIB_RGB_COLORS   A color table is provided and contains literal RGB values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The CreateDIBSection function creates a DIB that applications can write to directly. The function gives you a pointer to the location of the bitmap bit values. You can supply a handle to a file-mapping object that the function will use to create the bitmap, or you can let the system allocate the memory for the bitmap.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the newly created DIB, and *ppvBits points to the bitmap bit values. If the function fails, the return value is NULL, and *ppvBits is NULL. This function can return the following value.  ",
    "remarks": "As noted above, if hSection is NULL, the system allocates memory for the DIB. The system closes the handle to that memory when you later delete the DIB by calling the DeleteObject function. If hSection is not NULL, you must close the hSection memory handle yourself after calling DeleteObject to delete the bitmap. You cannot paste a DIB section from one application into another application. CreateDIBSection does not use the BITMAPINFOHEADER parameters biXPelsPerMeter or biYPelsPerMeter and will not provide resolution information in the BITMAPINFO structure. You need to guarantee that the GDI subsystem has completed any drawing to a bitmap created by CreateDIBSection before you draw to the bitmap yourself. Access to the bitmap must be synchronized. Do this by calling the GdiFlush function. This applies to any use of the pointer to the bitmap bit values, including passing the pointer in calls to functions such as SetDIBits. ICM: No color management is done. ",
    "return_type": "HBITMAP",
    "category": "Windows GDI",
    "name": "CreateDIBSection",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context. If the value of iUsage is DIB_PAL_COLORS, the function uses this device context's logical palette to initialize the DIB colors."
      },
      {
        "in_out": "_In_",
        "type": "const BITMAPINFO*",
        "name": "pbmi",
        "description": "A pointer to a BITMAPINFO structure that specifies various attributes of the DIB, including the bitmap dimensions and colors."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iUsage",
        "description": "The type of data contained in the bmiColors array member of the BITMAPINFO structure pointed to by pbmi (either logical palette indexes or literal RGB values). The following values are defined.  ValueMeaning  DIB_PAL_COLORS   The bmiColors member is an array of 16-bit indexes into the logical palette of the device context specified by hdc.   DIB_RGB_COLORS   The BITMAPINFO structure contains an array of literal RGB values."
      },
      {
        "in_out": "_Out_",
        "type": "VOID**",
        "name": "ppvBits",
        "description": "A pointer to a variable that receives a pointer to the location of the DIB bit values."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hSection",
        "description": "A handle to a file-mapping object that the function will use to create the DIB. This parameter can be NULL. If hSection is not NULL, it must be a handle to a file-mapping object created by calling the CreateFileMapping function with the PAGE_READWRITE or PAGE_WRITECOPY flag. Read-only DIB sections are not supported. Handles created by other means will cause CreateDIBSection to fail. If hSection is not NULL, the CreateDIBSection function locates the bitmap bit values at offset dwOffset in the file-mapping object referred to by hSection. An application can later retrieve the hSection handle by calling the GetObject function with the HBITMAP returned by CreateDIBSection. If hSection is NULL, the system allocates memory for the DIB. In this case, the CreateDIBSection function ignores the dwOffset parameter. An application cannot later obtain a handle to this memory. The dshSection member of the DIBSECTION structure filled in by calling the GetObject function will be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOffset",
        "description": "The offset from the beginning of the file-mapping object referenced by hSection where storage for the bitmap bit values is to begin. This value is ignored if hSection is NULL. The bitmap bit values are aligned on doubleword boundaries, so dwOffset must be a multiple of the size of a DWORD."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The ExtFloodFill function fills an area of the display surface with the current brush.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The following are some of the reasons this function might fail: If the fuFillType parameter is FLOODFILLBORDER, the system assumes that the area to be filled is completely bounded by the color specified by the crColor parameter. The function begins filling at the point specified by the nXStart and nYStart parameters and continues in all directions until it reaches the boundary. If fuFillType is FLOODFILLSURFACE, the system assumes that the area to be filled is a single color. The function begins to fill the area at the point specified by nXStart and nYStart and continues in all directions, filling all adjacent regions containing the color specified by crColor. Only memory device contexts and devices that support raster-display operations support the ExtFloodFill function. To determine whether a device supports this technology, use the GetDeviceCaps function. For an example, see \"Adding Lines and Graphs to a Menu\" in Using Menus. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "ExtFloodFill",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXStart",
        "description": "The x-coordinate, in logical units, of the point where filling is to start."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYStart",
        "description": "The y-coordinate, in logical units, of the point where filling is to start."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "The color of the boundary or of the area to be filled. The interpretation of crColor depends on the value of the fuFillType parameter. To create a COLORREF color value, use the RGB macro."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuFillType",
        "description": "The type of fill operation to be performed. This parameter must be one of the following values.  ValueMeaning  FLOODFILLBORDER   The fill area is bounded by the color specified by the crColor parameter. This style is identical to the filling performed by the FloodFill function.   FLOODFILLSURFACE   The fill area is defined by the color that is specified by crColor. Filling continues outward in all directions as long as the color is encountered. This style is useful for filling areas with multicolored boundaries."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The GetBitmapDimensionEx function retrieves the dimensions of a compatible bitmap. The retrieved dimensions must have been set by the SetBitmapDimensionEx function.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The function returns a data structure that contains fields for the height and width of the bitmap, in .01-mm units. If those dimensions have not yet been set, the structure that is returned will have zeros in those fields. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "GetBitmapDimensionEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hBitmap",
        "description": "A handle to a compatible bitmap (DDB)."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpDimension",
        "description": "A pointer to a SIZE structure to receive the bitmap dimensions. For more information, see Remarks."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The GetDIBColorTable function retrieves RGB (red, green, blue) color values from a range of entries in the color table of the DIB section bitmap that is currently selected into a specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of color table entries that the function retrieves. If the function fails, the return value is zero. ",
    "remarks": "The GetDIBColorTable function should be called to retrieve the color table for DIB section bitmaps that use 1, 4, or 8 bpp. The biBitCount member of a bitmap associated BITMAPINFOHEADER structure specifies the number of bits-per-pixel. DIB section bitmaps with a biBitCount value greater than eight do not have a color table, but they do have associated color masks. Call the GetObject function to retrieve those color masks. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "GetDIBColorTable",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context. A DIB section bitmap must be selected into this device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uStartIndex",
        "description": "A zero-based color table index that specifies the first color table entry to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cEntries",
        "description": "The number of color table entries to retrieve."
      },
      {
        "in_out": "_Out_",
        "type": "RGBQUAD*",
        "name": "pColors",
        "description": "A pointer to a buffer that receives an array of RGBQUAD data structures containing color information from the DIB color table. The buffer must be large enough to contain as many RGBQUAD data structures as the value of cEntries."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The GetDIBits function retrieves the bits of the specified compatible bitmap and copies them into a buffer as a DIB using the specified format.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the lpvBits parameter is non-NULL and the function succeeds, the return value is the number of scan lines copied from the bitmap. If the lpvBits parameter is NULL and GetDIBits successfully fills the BITMAPINFO structure, the return value is nonzero. If the function fails, the return value is zero. This function can return the following value.  ",
    "remarks": "If the requested format for the DIB matches its internal format, the RGB values for the bitmap are copied. If the requested format doesn't match the internal format, a color table is synthesized. The following table describes the color table synthesized for each format.  If the lpvBits parameter is a valid pointer, the first six members of the BITMAPINFOHEADER structure must be initialized to specify the size and format of the DIB. The scan lines must be aligned on a DWORD except for RLE compressed bitmaps. A bottom-up DIB is specified by setting the height to a positive number, while a top-down DIB is specified by setting the height to a negative number. The bitmap color table will be appended to the BITMAPINFO structure. If lpvBits is NULL, GetDIBits examines the first member of the first structure pointed to by lpbi. This member must specify the size, in bytes, of a BITMAPCOREHEADER or a BITMAPINFOHEADER structure. The function uses the specified size to determine how the remaining members should be initialized. If lpvBits is NULL and the bit count member of BITMAPINFO is initialized to zero, GetDIBits fills in a BITMAPINFOHEADER structure or BITMAPCOREHEADER without the color table. This technique can be used to query bitmap attributes. The bitmap identified by the hbmp parameter must not be selected into a device context when the application calls this function. The origin for a bottom-up DIB is the lower-left corner of the bitmap; the origin for a top-down DIB is the upper-left corner. For an example, see Capturing an Image. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetDIBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hbmp",
        "description": "A handle to the bitmap. This must be a compatible bitmap (DDB)."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uStartScan",
        "description": "The first scan line to retrieve."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cScanLines",
        "description": "The number of scan lines to retrieve."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpvBits",
        "description": "A pointer to a buffer to receive the bitmap data. If this parameter is NULL, the function passes the dimensions and format of the bitmap to the BITMAPINFO structure pointed to by the lpbi parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "LPBITMAPINFO",
        "name": "lpbi",
        "description": "A pointer to a BITMAPINFO structure that specifies the desired format for the DIB data."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uUsage",
        "description": "The format of the bmiColors member of the BITMAPINFO structure. It must be one of the following values.  ValueMeaning  DIB_PAL_COLORS   The color table should consist of an array of 16-bit indexes into the current logical palette.   DIB_RGB_COLORS   The color table should consist of literal red, green, blue (RGB) values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetPixel function retrieves the red, green, blue (RGB) color value of the pixel at the specified coordinates.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "The return value is the COLORREF value that specifies the RGB of the pixel. If the pixel is outside of the current clipping region, the return value is CLR_INVALID (0xFFFFFFFF defined in Wingdi.h). ",
    "remarks": "The pixel must be within the boundaries of the current clipping region. Not all devices support GetPixel. An application should call GetDeviceCaps to determine whether a specified device supports this function. A bitmap must be selected within the device context, otherwise, CLR_INVALID is returned on all pixels. ",
    "return_type": "COLORREF",
    "category": "Windows GDI",
    "name": "GetPixel",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXPos",
        "description": "The x-coordinate, in logical units, of the pixel to be examined."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYPos",
        "description": "The y-coordinate, in logical units, of the pixel to be examined."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The GetStretchBltMode function retrieves the current stretching mode. The stretching mode defines how color data is added to or removed from bitmaps that are stretched or compressed when the StretchBlt function is called.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the current stretching mode. This can be one of the following values.  If the function fails, the return value is zero. ",
    "remarks": "",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "GetStretchBltMode",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The GradientFill function fills rectangle and triangle structures.",
    "library": "Msimg32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "WinGdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. ",
    "remarks": "To add smooth shading to a triangle, call the GradientFill function with the three triangle endpoints. GDI will linearly interpolate and fill the triangle. Here is the drawing output of a shaded triangle. To add smooth shading to a rectangle, call GradientFill with the upper-left and lower-right coordinates of the rectangle. There are two shading modes used when drawing a rectangle. In horizontal mode, the rectangle is shaded from left-to-right. In vertical mode, the rectangle is shaded from top-to-bottom. Here is the drawing output of two shaded rectangles - one in horizontal mode, the other in vertical mode: The GradientFill function uses a mesh method to specify the endpoints of the object to draw. All vertices are passed to GradientFill in the pVertex array. The pMesh parameter specifies how these vertices are connected to form an object. When filling a rectangle, pMesh points to an array of GRADIENT_RECT structures. Each GRADIENT_RECT structure specifies the index of two vertices in the pVertex array. These two vertices form the upper-left and lower-right boundary of one rectangle. In the case of filling a triangle, pMesh points to an array of GRADIENT_TRIANGLE structures. Each GRADIENT_TRIANGLE structure specifies the index of three vertices in the pVertex array. These three vertices form one triangle. To simplify hardware acceleration, this routine is not required to be pixel-perfect in the triangle interior. Note that GradientFill does not use the Alpha member of the TRIVERTEX structure. To use GradientFill with transparency, call GradientFill and then call AlphaBlend with the desired values for the alpha channel of each vertex. For more information, see Smooth Shading, Drawing a Shaded Triangle, and Drawing a Shaded Rectangle. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "GradientFill",
    "is_callback": 0,
    "dll": "Msimg32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "PTRIVERTEX",
        "name": "pVertex",
        "description": "A pointer to an array of TRIVERTEX structures that each define a vertex."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "nVertex",
        "description": "The number of vertices in pVertex."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pMesh",
        "description": "An array of GRADIENT_TRIANGLE structures in triangle mode, or an array of GRADIENT_RECT structures in rectangle mode."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "nMesh",
        "description": "The number of elements (triangles or rectangles) in pMesh."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ulMode",
        "description": "The gradient fill mode. This parameter can be one of the following values.  ValueMeaning  GRADIENT_FILL_RECT_H   In this mode, two endpoints describe a rectangle. The rectangle is defined to have a constant color (specified by the TRIVERTEX structure) for the left and right edges. GDI interpolates the color from the left to right edge and fills the interior.   GRADIENT_FILL_RECT_V   In this mode, two endpoints describe a rectangle. The rectangle is defined to have a constant color (specified by the TRIVERTEX structure) for the top and bottom edges. GDI interpolates the color from the top to bottom edge and fills the interior.   GRADIENT_FILL_TRIANGLE   In this mode, an array of TRIVERTEX structures is passed to GDI along with a list of array indexes that describe separate triangles. GDI performs linear interpolation between triangle vertices and fills the interior. Drawing is done directly in 24- and 32-bpp modes. Dithering is performed in 16-, 8-, 4-, and 1-bpp mode."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "[LoadBitmap is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Instead, use LoadImage and DrawFrameControl.]",
    "library": "User32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winuser.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the handle to the specified bitmap. If the function fails, the return value is NULL. ",
    "remarks": "If the bitmap pointed to by the lpBitmapName parameter does not exist or there is insufficient memory to load the bitmap, the function fails. LoadBitmap creates a compatible bitmap of the display, which cannot be selected to a printer. To load a bitmap that you can select to a printer, call LoadImage and specify LR_CREATEDIBSECTION to create a DIB section. A DIB section can be selected to any device. An application can use the LoadBitmap function to access predefined bitmaps. To do so, the application must set the hInstance parameter to NULL and the lpBitmapName parameter to one of the following values.  Bitmap names that begin with OBM_OLD represent bitmaps used by 16-bit versions of Windows earlier than 3.0. For an application to use any of the OBM_ constants, the constant OEMRESOURCE must be defined before the Windows.h header file is included. The application must call the DeleteObject function to delete each bitmap handle returned by the LoadBitmap function. For an example, see Example of Menu-Item Bitmaps in Using Menus. ",
    "return_type": "HBITMAP",
    "category": "Windows GDI",
    "name": "LoadBitmap",
    "is_callback": 0,
    "dll": "User32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HINSTANCE",
        "name": "hInstance",
        "description": "A handle to the instance of the module whose executable file contains the bitmap to be loaded."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpBitmapName",
        "description": "A pointer to a null-terminated string that contains the name of the bitmap resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can be used to create this value."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "The MaskBlt function combines the color data for the source and destination bitmaps using the specified mask and raster operation.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The MaskBlt function uses device-dependent bitmaps. A value of 1 in the mask specified by hbmMask indicates that the foreground raster operation code specified by dwRop should be applied at that location. A value of 0 in the mask indicates that the background raster operation code specified by dwRop should be applied at that location. If the raster operations require a source, the mask rectangle must cover the source rectangle. If it does not, the function will fail. If the raster operations do not require a source, the mask rectangle must cover the destination rectangle. If it does not, the function will fail. If a rotation or shear transformation is in effect for the source device context when this function is called, an error occurs. However, other types of transformation are allowed. If the color formats of the source, pattern, and destination bitmaps differ, this function converts the pattern or source format, or both, to match the destination format. If the mask bitmap is not a monochrome bitmap, an error occurs. When an enhanced metafile is being recorded, an error occurs (and the function returns FALSE) if the source device context identifies an enhanced-metafile device context. Not all devices support the MaskBlt function. An application should call the GetDeviceCaps function with the nIndex parameter as RC_BITBLT to determine whether a device supports this function. If no mask bitmap is supplied, this function behaves exactly like BitBlt, using the foreground raster operation code. ICM: No color management is performed when blits occur. When used in a multiple monitor system, both hdcSrc and hdcDest must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap (compatible bitmap, or DDB) to a DIB by calling GetDIBits. To display the DIB to the second device, call SetDIBits or StretchDIBits. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "MaskBlt",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcDest",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXDest",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYDest",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width, in logical units, of the destination rectangle and source bitmap."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in logical units, of the destination rectangle and source bitmap."
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcSrc",
        "description": "A handle to the device context from which the bitmap is to be copied. It must be zero if the dwRop parameter specifies a raster operation that does not include a source."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXSrc",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the source bitmap."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYSrc",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the source bitmap."
      },
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hbmMask",
        "description": "A handle to the monochrome mask bitmap combined with the color bitmap in the source device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xMask",
        "description": "The horizontal pixel offset for the mask bitmap specified by the hbmMask parameter."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yMask",
        "description": "The vertical pixel offset for the mask bitmap specified by the hbmMask parameter."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRop",
        "description": "The foreground and background ternary raster operation codes (ROPs) that the function uses to control the combination of source and destination data. The background raster operation code is stored in the high-order byte of the high-order word of this value; the foreground raster operation code is stored in the low-order byte of the high-order word of this value; the low-order word of this value is ignored, and should be zero. The macro MAKEROP4 creates such combinations of foreground and background raster operation codes. For a discussion of foreground and background in the context of this function, see the following Remarks section. For a list of common raster operation codes (ROPs), see the BitBlt function. Note that the CAPTUREBLT ROP generally cannot be used for printing device contexts."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 10,
    "description": "The PlgBlt function performs a bit-block transfer of the bits of color data from the specified rectangle in the source device context to the specified parallelogram in the destination device context. If the given bitmask handle identifies a valid monochrome bitmap, the function uses this bitmap to mask the bits of color data from the source rectangle.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The PlgBlt function works with device-dependent bitmaps. The fourth vertex of the parallelogram (D) is defined by treating the first three points (A, B, and C ) as vectors and computing D = B +CA. If the bitmask exists, a value of one in the mask indicates that the source pixel color should be copied to the destination. A value of zero in the mask indicates that the destination pixel color is not to be changed. If the mask rectangle is smaller than the source and destination rectangles, the function replicates the mask pattern. Scaling, translation, and reflection transformations are allowed in the source device context; however, rotation and shear transformations are not. If the mask bitmap is not a monochrome bitmap, an error occurs. The stretching mode for the destination device context is used to determine how to stretch or compress the pixels, if that is necessary. When an enhanced metafile is being recorded, an error occurs if the source device context identifies an enhanced-metafile device context. The destination coordinates are transformed according to the destination device context; the source coordinates are transformed according to the source device context. If the source transformation has a rotation or shear, an error is returned. If the destination and source rectangles do not have the same color format, PlgBlt converts the source rectangle to match the destination rectangle. Not all devices support the PlgBlt function. For more information, see the description of the RC_BITBLT raster capability in the GetDeviceCaps function. If the source and destination device contexts represent incompatible devices, PlgBlt returns an error. When used in a multiple monitor system, both hdcSrc and hdcDest must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling GetDIBits. To display the DIB to the second device, call SetDIBits or StretchDIBits. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "PlgBlt",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcDest",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "const POINT*",
        "name": "lpPoint",
        "description": "A pointer to an array of three points in logical space that identify three corners of the destination parallelogram. The upper-left corner of the source rectangle is mapped to the first point in this array, the upper-right corner to the second point in this array, and the lower-left corner to the third point. The lower-right corner of the source rectangle is mapped to the implicit fourth point in the parallelogram."
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcSrc",
        "description": "A handle to the source device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXSrc",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYSrc",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hbmMask",
        "description": "A handle to an optional monochrome bitmap that is used to mask the colors of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xMask",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the monochrome bitmap."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yMask",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the monochrome bitmap."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SetBitmapDimensionEx function assigns preferred dimensions to a bitmap. These dimensions can be used by applications; however, they are not used by the system.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "An application can retrieve the dimensions assigned to a bitmap with the SetBitmapDimensionEx function by calling the GetBitmapDimensionEx function. The bitmap identified by hBitmap cannot be a DIB section, which is a bitmap created by the CreateDIBSection function. If the bitmap is a DIB section, the SetBitmapDimensionEx function fails. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetBitmapDimensionEx",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hBitmap",
        "description": "A handle to the bitmap. The bitmap cannot be a DIB-section bitmap."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width, in 0.1-millimeter units, of the bitmap."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in 0.1-millimeter units, of the bitmap."
      },
      {
        "in_out": "_Out_",
        "type": "LPSIZE",
        "name": "lpSize",
        "description": "A pointer to a SIZE structure to receive the previous dimensions of the bitmap. This pointer can be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SetDIBColorTable function sets RGB (red, green, blue) color values in a range of entries in the color table of the DIB that is currently selected into a specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of color table entries that the function sets. If the function fails, the return value is zero. ",
    "remarks": "This function should be called to set the color table for DIBs that use 1, 4, or 8 bpp. The BitCount member of a bitmap's associated bitmap information header structure. BITMAPINFOHEADER          structure specifies the number of bits-per-pixel. Device-independent bitmaps with a biBitCount value greater than 8 do not have a color table. The bV5BitCount member of a bitmap's associated BITMAPV5HEADER structure specifies the number of bits-per-pixel. Device-independent bitmaps with a bV5BitCount value greater than 8 do not have a color table. ICM: No color management is performed. ",
    "return_type": "UINT",
    "category": "Windows GDI",
    "name": "SetDIBColorTable",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A device context. A DIB must be selected into this device context."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uStartIndex",
        "description": "A zero-based color table index that specifies the first color table entry to set."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cEntries",
        "description": "The number of color table entries to set."
      },
      {
        "in_out": "_In_",
        "type": "const RGBQUAD*",
        "name": "pColors",
        "description": "A pointer to an array of RGBQUAD structures containing new color information for the DIB's color table."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The SetDIBits function sets the pixels in a compatible bitmap (DDB) using the color data found in the specified DIB.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of scan lines copied. If the function fails, the return value is zero. This can be the following value.  ",
    "remarks": "Optimal bitmap drawing speed is obtained when the bitmap bits are indexes into the system palette. Applications can retrieve the system palette colors and indexes by calling the GetSystemPaletteEntries function. After the colors and indexes are retrieved, the application can create the DIB. For more information, see System Palette. The device context identified by the hdc parameter is used only if the DIB_PAL_COLORS constant is set for the fuColorUse parameter; otherwise it is ignored. The bitmap identified by the hbmp parameter must not be selected into a device context when the application calls this function. The scan lines must be aligned on a DWORD except for RLE-compressed bitmaps. The origin for bottom-up DIBs is the lower-left corner of the bitmap; the origin for top-down DIBs is the upper-left corner of the bitmap. ICM: Color management is performed if color management has been enabled with a call to SetICMMode with the iEnableICM parameter set to ICM_ON. If the bitmap specified by lpbmi has a BITMAPV4HEADER that specifies the gamma and endpoints members, or a BITMAPV5HEADER that specifies either the gamma and endpoints members or the profileData and profileSize members, then the call treats the bitmap's pixels as being expressed in the color space described by those members, rather than in the device context's source color space. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "SetDIBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hbmp",
        "description": "A handle to the compatible bitmap (DDB) that is to be altered using the color data from the specified DIB."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uStartScan",
        "description": "The starting scan line for the device-independent color data in the array pointed to by the lpvBits parameter."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cScanLines",
        "description": "The number of scan lines found in the array containing device-independent color data."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lpvBits",
        "description": "A pointer to the DIB color data, stored as an array of bytes. The format of the bitmap values depends on the biBitCount member of the BITMAPINFO structure pointed to by the lpbmi parameter."
      },
      {
        "in_out": "_In_",
        "type": "const BITMAPINFO*",
        "name": "lpbmi",
        "description": "A pointer to a BITMAPINFO structure that contains information about the DIB."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuColorUse",
        "description": "Indicates whether the bmiColors member of the BITMAPINFO structure was provided and, if so, whether bmiColors contains explicit red, green, blue (RGB) values or palette indexes. The fuColorUse parameter must be one of the following values.  ValueMeaning  DIB_PAL_COLORS   The color table consists of an array of 16-bit indexes into the logical palette of the device context identified by the hdc parameter.   DIB_RGB_COLORS   The color table is provided and contains literal RGB values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "The SetDIBitsToDevice function sets the pixels in the specified rectangle on the device that is associated with the destination device context using color data from a DIB, JPEG, or PNG image.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of scan lines set. If zero scan lines are set (such as when dwHeight is 0) or the function fails, the function returns zero. If the driver cannot support the JPEG or PNG file image passed to SetDIBitsToDevice, the function will fail and return GDI_ERROR. If failure does occur, the application must fall back on its own JPEG or PNG support to decompress the image into a bitmap, and then pass the bitmap to SetDIBitsToDevice. ",
    "remarks": "Optimal bitmap drawing speed is obtained when the bitmap bits are indexes into the system palette. Applications can retrieve the system palette colors and indexes by calling the GetSystemPaletteEntries function. After the colors and indexes are retrieved, the application can create the DIB. For more information about the system palette, see Colors. The scan lines must be aligned on a DWORD except for RLE-compressed bitmaps. The origin of a bottom-up DIB is the lower-left corner of the bitmap; the origin of a top-down DIB is the upper-left corner. To reduce the amount of memory required to set bits from a large DIB on a device surface, an application can band the output by repeatedly calling SetDIBitsToDevice, placing a different portion of the bitmap into the lpvBits array each time. The values of the uStartScan and cScanLines parameters identify the portion of the bitmap contained in the lpvBits array. The SetDIBitsToDevice function returns an error if it is called by a process that is running in the background while a full-screen MS-DOS session runs in the foreground. ICM: Color management is performed if color management has been enabled with a call to SetICMMode with the iEnableICM parameter set to ICM_ON. If the bitmap specified by lpbmi has a BITMAPV4HEADER that specifies the gamma and endpoints members, or a BITMAPV5HEADER that specifies either the gamma and endpoints members or the profileData and profileSize members, then the call treats the bitmap's pixels as being expressed in the color space described by those members, rather than in the device context's source color space. For an example, see Testing a Printer for JPEG or PNG Support. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "SetDIBitsToDevice",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "XDest",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "YDest",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwWidth",
        "description": "The width, in logical units, of the image."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwHeight",
        "description": "The height, in logical units, of the image."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "XSrc",
        "description": "The x-coordinate, in logical units, of the lower-left corner of the image."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "YSrc",
        "description": "The y-coordinate, in logical units, of the lower-left corner of the image."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uStartScan",
        "description": "The starting scan line in the image."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "cScanLines",
        "description": "The number of DIB scan lines contained in the array pointed to by the lpvBits parameter."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lpvBits",
        "description": "A pointer to the color data stored as an array of bytes. For more information, see the following Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "const BITMAPINFO*",
        "name": "lpbmi",
        "description": "A pointer to a BITMAPINFO structure that contains information about the DIB."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "fuColorUse",
        "description": "Indicates whether the bmiColors member of the BITMAPINFO structure contains explicit red, green, blue (RGB) values or indexes into a palette. For more information, see the following Remarks section. The fuColorUse parameter must be one of the following values.  ValueMeaning  DIB_PAL_COLORS   The color table consists of an array of 16-bit indexes into the currently selected logical palette.   DIB_RGB_COLORS   The color table contains literal RGB values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SetPixel function sets the pixel at the specified coordinates to the specified color.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the RGB value that the function sets the pixel to. This value may differ from the color specified by crColor; that occurs when an exact match for the specified color cannot be found. If the function fails, the return value is -1. This can be the following value.  ",
    "remarks": "The function fails if the pixel coordinates lie outside of the current clipping region. Not all devices support the SetPixel function. For more information, see GetDeviceCaps. ",
    "return_type": "COLORREF",
    "category": "Windows GDI",
    "name": "SetPixel",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "The x-coordinate, in logical units, of the point to be set."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "The y-coordinate, in logical units, of the point to be set."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "The color to be used to paint the point. To create a COLORREF color value, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The SetPixelV function sets the pixel at the specified coordinates to the closest approximation of the specified color. The point must be in the clipping region and the visible part of the device surface.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "Not all devices support the SetPixelV function. For more information, see the description of the RC_BITBLT capability in the GetDeviceCaps function. SetPixelV is faster than SetPixel because it does not need to return the color value of the point actually painted. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "SetPixelV",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "X",
        "description": "The x-coordinate, in logical units, of the point to be set."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "Y",
        "description": "The y-coordinate, in logical units, of the point to be set."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crColor",
        "description": "The color to be used to paint the point. To create a COLORREF color value, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "The SetStretchBltMode function sets the bitmap stretching mode in the specified device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the previous stretching mode. If the function fails, the return value is zero. This function can return the following value.  ",
    "remarks": "The stretching mode defines how the system combines rows or columns of a bitmap with existing pixels on a display device when an application calls the StretchBlt function. The BLACKONWHITE (STRETCH_ANDSCANS) and WHITEONBLACK (STRETCH_ORSCANS) modes are typically used to preserve foreground pixels in monochrome bitmaps. The COLORONCOLOR (STRETCH_DELETESCANS) mode is typically used to preserve color in color bitmaps. The HALFTONE mode is slower and requires more processing of the source image than the other three modes; but produces higher quality images. Also note that SetBrushOrgEx must be called after setting the HALFTONE mode to avoid brush misalignment. Additional stretching modes might also be available depending on the capabilities of the device driver. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "SetStretchBltMode",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "iStretchMode",
        "description": "The stretching mode. This parameter can be one of the following values.  ValueMeaning  BLACKONWHITE   Performs a Boolean AND operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves black pixels at the expense of white pixels.   COLORONCOLOR   Deletes the pixels. This mode deletes all eliminated lines of pixels without trying to preserve their information.   HALFTONE   Maps pixels from the source rectangle into blocks of pixels in the destination rectangle. The average color over the destination block of pixels approximates the color of the source pixels. After setting the HALFTONE stretching mode, an application must call the SetBrushOrgEx function to set the brush origin. If it fails to do so, brush misalignment occurs.   STRETCH_ANDSCANS   Same as BLACKONWHITE.   STRETCH_DELETESCANS   Same as COLORONCOLOR.   STRETCH_HALFTONE   Same as HALFTONE.   STRETCH_ORSCANS   Same as WHITEONBLACK.   WHITEONBLACK   Performs a Boolean OR operation using the color values for the eliminated and existing pixels. If the bitmap is a monochrome bitmap, this mode preserves white pixels at the expense of black pixels."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "The StretchBlt function copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap to fit the dimensions of the destination rectangle, if necessary. The system stretches or compresses the bitmap according to the stretching mode currently set in the destination device context.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "StretchBlt stretches or compresses the source bitmap in memory and then copies the result to the destination rectangle. This bitmap can be either a compatible bitmap (DDB) or the output from CreateDIBSection. The color data for pattern or destination pixels is merged after the stretching or compression occurs. When an enhanced metafile is being recorded, an error occurs (and the function returns FALSE) if the source device context identifies an enhanced-metafile device context. If the specified raster operation requires a brush, the system uses the brush currently selected into the destination device context. The destination coordinates are transformed by using the transformation currently specified for the destination device context; the source coordinates are transformed by using the transformation currently specified for the source device context. If the source transformation has a rotation or shear, an error occurs. If destination, source, and pattern bitmaps do not have the same color format, StretchBlt converts the source and pattern bitmaps to match the destination bitmap. If StretchBlt must convert a monochrome bitmap to a color bitmap, it sets white bits (1) to the background color and black bits (0) to the foreground color. To convert a color bitmap to a monochrome bitmap, it sets pixels that match the background color to white (1) and sets all other pixels to black (0). The foreground and background colors of the device context with color are used. StretchBlt creates a mirror image of a bitmap if the signs of the nWidthSrc and nWidthDest parameters or if the nHeightSrc and nHeightDest parameters differ. If nWidthSrc and nWidthDest have different signs, the function creates a mirror image of the bitmap along the x-axis. If nHeightSrc and nHeightDest have different signs, the function creates a mirror image of the bitmap along the y-axis. Not all devices support the StretchBlt function. For more information, see the GetDeviceCaps. ICM: No color management is performed when a blit operation occurs. When used in a multiple monitor system, both hdcSrc and hdcDest must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling GetDIBits. To display the DIB to the second device, call SetDIBits or StretchDIBits. For an example, see Scaling an Image. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "StretchBlt",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcDest",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXOriginDest",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYOriginDest",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidthDest",
        "description": "The width, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeightDest",
        "description": "The height, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcSrc",
        "description": "A handle to the source device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXOriginSrc",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYOriginSrc",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidthSrc",
        "description": "The width, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeightSrc",
        "description": "The height, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRop",
        "description": "The raster operation to be performed. Raster operation codes define how the system combines colors in output operations that involve a brush, a source bitmap, and a destination bitmap. See BitBlt for a list of common raster operation codes (ROPs). Note that the CAPTUREBLT ROP generally cannot be used for printing device contexts."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 13,
    "description": "The StretchDIBits function copies the color data for a rectangle of pixels in a DIB, JPEG, or PNG image to the specified destination rectangle. If the destination rectangle is larger than the source rectangle, this function stretches the rows and columns of color data to fit the destination rectangle. If the destination rectangle is smaller than the source rectangle, this function compresses the rows and columns by using the specified raster operation.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of scan lines copied. Note that this value can be negative for mirrored content. If the function fails, or no scan lines are copied, the return value is 0. If the driver cannot support the JPEG or PNG file image passed to StretchDIBits, the function will fail and return GDI_ERROR. If failure does occur, the application must fall back on its own JPEG or PNG support to decompress the image into a bitmap, and then pass the bitmap to StretchDIBits. ",
    "remarks": "The origin of a bottom-up DIB is the lower-left corner; the origin of a top-down DIB is the upper-left corner. StretchDIBits creates a mirror image of a bitmap if the signs of the nSrcWidth and nDestWidth parameters, or if the nSrcHeight and nDestHeight parameters differ. If nSrcWidth and nDestWidth have different signs, the function creates a mirror image of the bitmap along the x-axis. If nSrcHeight and nDestHeight have different signs, the function creates a mirror image of the bitmap along the y-axis. StretchDIBits creates a top-down image if the sign of the biHeight member of the BITMAPINFOHEADER structure for the DIB is negative. For a code example, see Sizing a JPEG or PNG Image. This function allows a JPEG or PNG image to be passed as the source image. How each parameter is used remains the same, except: ICM: Color management is performed if color management has been enabled with a call to SetICMMode with the iEnableICM parameter set to ICM_ON. If the bitmap specified by lpBitsInfo has a BITMAPV4HEADER that specifies the gamma and endpoints members, or a BITMAPV5HEADER that specifies either the gamma and endpoints members or the profileData and profileSize members, then the call treats the bitmap's pixels as being expressed in the color space described by those members, rather than in the device context's source color space. For an example, see Sizing a JPEG or PNG Image. ",
    "return_type": "int",
    "category": "Windows GDI",
    "name": "StretchDIBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "XDest",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "YDest",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nDestWidth",
        "description": "The width, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nDestHeight",
        "description": "The height, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "XSrc",
        "description": "The x-coordinate, in pixels, of the source rectangle in the image."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "YSrc",
        "description": "The y-coordinate, in pixels, of the source rectangle in the image."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nSrcWidth",
        "description": "The width, in pixels, of the source rectangle in the image."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nSrcHeight",
        "description": "The height, in pixels, of the source rectangle in the image."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lpBits",
        "description": "A pointer to the image bits, which are stored as an array of bytes. For more information, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "const BITMAPINFO*",
        "name": "lpBitsInfo",
        "description": "A pointer to a BITMAPINFO structure that contains information about the DIB."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "iUsage",
        "description": "Specifies whether the bmiColors member of the BITMAPINFO structure was provided and, if so, whether bmiColors contains explicit red, green, blue (RGB) values or indexes. The iUsage parameter must be one of the following values.  ValueMeaning  DIB_PAL_COLORS   The array contains 16-bit indexes into the logical palette of the source device context.   DIB_RGB_COLORS   The color table contains literal RGB values.     For more information, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRop",
        "description": "A raster-operation code that specifies how the source pixels, the destination device context's current brush, and the destination pixels are to be combined to form the new image. For a list of some common raster operation codes, see BitBlt."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "The TransparentBlt function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.",
    "library": "Msimg32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "WinGdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. ",
    "remarks": "The TransparentBlt function works with compatible bitmaps (DDBs). The TransparentBlt function supports all formats of source bitmaps. However, for 32 bpp bitmaps, it just copies the alpha value over. Use AlphaBlend to specify 32 bits-per-pixel bitmaps with transparency. If the source and destination rectangles are not the same size, the source bitmap is stretched to match the destination rectangle. When the SetStretchBltMode function is used, the iStretchMode modes of BLACKONWHITE and WHITEONBLACK are converted to COLORONCOLOR for the TransparentBlt function. The destination device context specifies the transformation type for the destination coordinates. The source device context specifies the transformation type for the source coordinates. TransparentBlt does not mirror a bitmap if either the width or height, of either the source or destination, is negative. When used in a multiple monitor system, both hdcSrc and hdcDest must refer to the same device or the function will fail. To transfer data between DCs for different devices, convert the memory bitmap to a DIB by calling GetDIBits. To display the DIB to the second device, call SetDIBits or StretchDIBits. ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "TransparentBlt",
    "is_callback": 0,
    "dll": "Msimg32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcDest",
        "description": "A handle to the destination device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xoriginDest",
        "description": "The x-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yoriginDest",
        "description": "The y-coordinate, in logical units, of the upper-left corner of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "wDest",
        "description": "The width, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "hDest",
        "description": "The height, in logical units, of the destination rectangle."
      },
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdcSrc",
        "description": "A handle to the source device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "xoriginSrc",
        "description": "The x-coordinate, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "yoriginSrc",
        "description": "The y-coordinate, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "wSrc",
        "description": "The width, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "hSrc",
        "description": "The height, in logical units, of the source rectangle."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "crTransparent",
        "description": "The RGB color in the source bitmap to treat as transparent."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The CreateDiscardableBitmap function creates a discardable bitmap that is compatible with the specified device. The bitmap has the same bits-per-pixel format and the same color palette as the device. An application can select this bitmap as the current bitmap for a memory device that is compatible with the specified device.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is a handle to the compatible bitmap (DDB). If the function fails, the return value is NULL. ",
    "remarks": "When you no longer need the bitmap, call the DeleteObject function to delete it. ",
    "return_type": "HBITMAP",
    "category": "Windows GDI",
    "name": "CreateDiscardableBitmap",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nWidth",
        "description": "The width, in pixels, of the bitmap."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nHeight",
        "description": "The height, in pixels, of the bitmap."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The FloodFill function fills an area of the display surface with the current brush. The area is assumed to be bounded as specified by the crFill parameter.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "The following are reasons this function might fail: ",
    "return_type": "BOOL",
    "category": "Windows GDI",
    "name": "FloodFill",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HDC",
        "name": "hdc",
        "description": "A handle to a device context."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nXStart",
        "description": "The x-coordinate, in logical units, of the point where filling is to start."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nYStart",
        "description": "The y-coordinate, in logical units, of the point where filling is to start."
      },
      {
        "in_out": "_In_",
        "type": "COLORREF",
        "name": "crFill",
        "description": "The color of the boundary or the area to be filled. To create a COLORREF color value, use the RGB macro."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The GetBitmapBits function copies the bitmap bits of a specified device-dependent bitmap into a buffer.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of bytes copied to the buffer. If the function fails, the return value is zero. ",
    "remarks": "",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "GetBitmapBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hbmp",
        "description": "A handle to the device-dependent bitmap."
      },
      {
        "in_out": "_In_",
        "type": "LONG",
        "name": "cbBuffer",
        "description": "The number of bytes to copy from the bitmap into the buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpvBits",
        "description": "A pointer to a buffer to receive the bitmap bits. The bits are stored as an array of byte values."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The SetBitmapBits function sets the bits of color data for a bitmap to the specified values.",
    "library": "Gdi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Wingdi.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is the number of bytes used in setting the bitmap bits. If the function fails, the return value is zero. ",
    "remarks": "The array identified by lpBits must be WORD aligned. ",
    "return_type": "LONG",
    "category": "Windows GDI",
    "name": "SetBitmapBits",
    "is_callback": 0,
    "dll": "Gdi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HBITMAP",
        "name": "hbmp",
        "description": "A handle to the bitmap to be set. This must be a compatible bitmap (DDB)."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cBytes",
        "description": "The number of bytes pointed to by the lpBits parameter."
      },
      {
        "in_out": "_In_",
        "type": "const VOID*",
        "name": "lpBits",
        "description": "A pointer to an array of bytes that contain color data for the specified bitmap."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]