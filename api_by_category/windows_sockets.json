[
  {
    "n_arguments": 3,
    "description": "The  accept function permits an incoming connection attempt on a socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  accept returns a value of type SOCKET that is a descriptor for the new socket. This returned value is a handle for the socket on which the actual connection is made. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling  WSAGetLastError. The integer referred to by addrlen initially contains the amount of space pointed to by addr. On return it will contain the actual length in bytes of the address returned.  ",
    "remarks": "The  accept function extracts the first connection on the queue of pending connections on socket s. It then creates and returns a handle to the new socket. The newly created socket is the socket that will handle the actual connection; it has the same properties as socket s, including the asynchronous events registered with the  WSAAsyncSelect or  WSAEventSelect functions. The  accept function can block the caller until a connection is present if no pending connections are present on the queue, and the socket is marked as blocking. If the socket is marked as nonblocking and no pending connections are present on the queue,  accept returns an error as described in the following. After the successful completion of  accept returns a new socket handle, the accepted socket cannot be used to accept more connections. The original socket remains open and listens for new connection requests. The parameter addr is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer. The exact format of the addr parameter is determined by the address family in which the communication is occurring. The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr; on return it will contain the actual length (in bytes) of the address returned. The  accept function is used with connection-oriented socket types such as SOCK_STREAM. If addr and/or addrlen are equal to NULL, then no information about the remote address of the accepted socket is returned. The following example demonstrates the use of the accept function. For another example that uses the  accept function, see Getting Started With Winsock.  The following are important issues associated with connection setup, and must be considered when using Asynchronous Transfer Mode (ATM) with Windows Sockets 2: Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "SOCKET",
    "category": "Windows Sockets (Winsock)",
    "name": "accept",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies a socket that has been placed in a listening state with the  listen function. The connection is actually made with the socket that is returned by  accept."
      },
      {
        "in_out": "_Out_",
        "type": "struct sockaddr*",
        "name": "addr",
        "description": "An optional pointer to a buffer that receives the address of the connecting entity, as known to the communications layer. The exact format of the addr parameter is determined by the address family that was established when the socket from the  sockaddr structure was created."
      },
      {
        "in_out": "_Inout_",
        "type": "int*",
        "name": "addrlen",
        "description": "An optional pointer to an integer that contains the length of structure pointed to by the addr parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "The  AcceptEx function accepts a new connection, returns the local and remote address, and receives the first block of data sent by the client application.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the  AcceptEx function completed successfully and a value of TRUE is returned. If the function fails,  AcceptEx returns FALSE. The  WSAGetLastError function can then be called to return extended error information. If  WSAGetLastError returns ERROR_IO_PENDING, then the operation was successfully initiated and is still in progress. If the error is WSAECONNRESET, an incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call. ",
    "remarks": " The  AcceptEx function combines several socket functions into a single API/kernel transition. The  AcceptEx function, when successful, performs three tasks:  A program can make a connection to a socket more quickly using  AcceptEx instead of the  accept function. A single output buffer receives the data, the local socket address (the server), and the remote socket address (the client). Using a single buffer improves performance. When using  AcceptEx, the  GetAcceptExSockaddrs function must be called to parse the buffer into its three distinct parts (data, local socket address, and remote socket address). On Windows XP and later, once the  AcceptEx function completes and the SO_UPDATE_ACCEPT_CONTEXT option is set on the accepted socket, the local address associated with the accepted socket can also be retrieved using the  getsockname function. Likewise, the remote address associated with the accepted socket can be retrieved using the  getpeername function. The buffer size for the local and remote address must be 16 bytes more than the size of the  sockaddr structure for the transport protocol in use because the addresses are written in an internal format. For example, the size of a sockaddr_in (the address structure for TCP/IP) is 16 bytes. Therefore, a buffer size of at least 32 bytes must be specified for the local and remote addresses. The  AcceptEx function uses overlapped I/O, unlike the  accept function. If your application uses  AcceptEx, it can service a large number of clients with a relatively small number of threads. As with all overlapped Windows functions, either Windows events or completion ports can be used as a completion notification mechanism.  Another key difference between the  AcceptEx function and the  accept function is that  AcceptEx requires the caller to already have two sockets: The sAcceptSocket parameter must be an open socket that is neither bound nor connected. The lpNumberOfBytesTransferred parameter of the  GetQueuedCompletionStatus function or the  GetOverlappedResult function indicates the number of bytes received in the request.  When this operation is successfully completed, sAcceptSocket can be passed, but to the following functions only: When the  AcceptEx function returns, the socket sAcceptSocket is in the default state for a connected socket. The socket sAcceptSocket does not inherit the properties of the socket associated with sListenSocket parameter until SO_UPDATE_ACCEPT_CONTEXT is set on the socket. Use the  setsockopt function to set the SO_UPDATE_ACCEPT_CONTEXT option, specifying sAcceptSocket as the socket handle and sListenSocket as the option value. For example: If a receive buffer is provided, the overlapped operation will not complete until a connection is accepted and data is read. Use the  getsockopt function with the SO_CONNECT_TIME option to check whether a connection has been accepted. If it has been accepted, you can determine how long the connection has been established. The return value is the number of seconds that the socket has been connected. If the socket is not connected, the  getsockopt returns 0xFFFFFFFF. Applications that check whether the overlapped operation has completed, in combination with the SO_CONNECT_TIME option, can determine that a connection has been accepted but no data has been received. Scrutinizing a connection in this manner enables an application to determine whether connections that have been established for a while have received no data. It is recommended such connections be terminated by closing the accepted socket, which forces the  AcceptEx function call to complete with an error. For example:  Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. The following example uses the AcceptEx function using overlapped I/O and completion ports. The  TransmitFile function allows the setting of two flags, TF_DISCONNECT or TF_REUSE_SOCKET, that return the socket to a \"disconnected, reusable\" state after the file has been transmitted. These flags should not be used on a socket where quality of service has been requested, since the service provider may immediately delete any quality of service associated with the socket before the file transfer has completed. The best approach for a QoS-enabled socket is to simply call the  closesocket function when the file transfer has completed, rather than relying on these flags. There are important issues associated with connection setup when using Asynchronous Transfer Mode (ATM) with Windows Sockets 2. Please see the Remarks section in the  accept function documentation for important ATM connection setup information. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "AcceptEx",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "sListenSocket",
        "description": "A descriptor identifying a socket that has already been called with the  listen function. A server application waits for attempts to connect on this socket."
      },
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "sAcceptSocket",
        "description": "A descriptor identifying a socket on which to accept an incoming connection. This socket must not be bound or connected."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpOutputBuffer",
        "description": "A pointer to a buffer that receives the first block of data sent on a new connection, the local address of the server, and the remote address of the client. The receive data is written to the first part of the buffer starting at offset zero, while the addresses are written to the latter part of the buffer. This parameter must be specified."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwReceiveDataLength",
        "description": "The number of bytes in lpOutputBuffer that will be used for actual receive data at the beginning of the buffer. This size should not include the size of the local address of the server, nor the remote address of the client; they are appended to the output buffer. If dwReceiveDataLength is zero, accepting the connection will not result in a receive operation. Instead,  AcceptEx completes as soon as a connection arrives, without waiting for any data."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLocalAddressLength",
        "description": "The number of bytes reserved for the local address information. This value must be at least 16 bytes more than the maximum address length for the transport protocol in use."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRemoteAddressLength",
        "description": "The number of bytes reserved for the remote address information. This value must be at least 16 bytes more than the maximum address length for the transport protocol in use. Cannot be zero."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwBytesReceived",
        "description": "A pointer to a DWORD that receives the count of bytes received. This parameter is set only if the operation completes synchronously. If it returns ERROR_IO_PENDING and is completed later, then this DWORD is never set and you must obtain the number of bytes read from the completion notification mechanism."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "An  OVERLAPPED structure that is used to process the request. This parameter must be specified; it cannot be NULL."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  bind function associates a local address with a socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  bind returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  bind function is required on an unconnected socket before subsequent calls to the  listen function. It is normally used to bind to either connection-oriented (stream) or connectionless (datagram) sockets. The  bind function may also be used to bind to a raw socket (the socket was created by calling the socket \t\t\tfunction with the type parameter set to SOCK_RAW). The  bind function may also be used on an unconnected socket before subsequent calls to the  connect, ConnectEx, WSAConnect, WSAConnectByList, or WSAConnectByName functions before send operations. When a socket is created with a call to the  socket function, it exists in a namespace (address family), but it has no name assigned to it. Use the  bind function to establish the local association of the socket by assigning a local name to an unnamed socket.  A name consists of three parts when using the Internet address family: In Windows Sockets 2, the name parameter is not strictly interpreted as a pointer to a  sockaddr structure. It is cast this way for Windows Sockets 1.1 compatibility. Service providers are free to regard it as a pointer to a block of memory of size namelen. The first 2 bytes in this block (corresponding to the sa_family member of the sockaddr structure, the sin_family member of the sockaddr_in structure, or the sin6_family member of the sockaddr_in6 structure) must contain the address family that was used to create the socket. Otherwise, an error WSAEFAULT occurs. If an application does not care what local address is assigned, specify the constant value INADDR_ANY for an IPv4 local address or the constant value in6addr_any for an IPv6 local address in the sa_data member of the name parameter. This allows the underlying service provider to use any appropriate network address, potentially simplifying application programming in the presence of multihomed hosts (that is, hosts that have more than one network interface and address). For TCP/IP, if the port is specified as zero, the service provider assigns a unique port to the application from the dynamic client port range. On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000.  The maximum value for the client dynamic port range can be changed by setting a value under  the following registry key: HKLM\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters The MaxUserPort registry value sets the value to use for the maximum value of the dynamic client port range. You must restart the computer for this setting to take effect. On Windows Vista and later, the dynamic client port range can be viewed and changed using netsh commands. The dynamic client port range can be set differently for UDP and TCP and also for IPv4 and IPv6. For more information, see KB 929851. The application can use  getsockname after calling  bind to learn the address and the port that has been assigned to the socket. If the Internet address is equal to INADDR_ANY or in6addr_any,  getsockname cannot necessarily supply the address until the socket is connected, since several addresses can be valid if the host is multihomed. Binding to a specific port number other than port 0 is discouraged for client applications, since there is a danger of conflicting with another socket already using that port number on the local computer. For multicast operations, the preferred method is to call the bind function to associate a socket with a local IP address  and then join the multicast group. Although this order of operations is not mandatory, it is strongly recommended. So a multicast application would first select an IPv4 or IPv6  address on the local computer, the wildcard IPv4 address (INADDR_ANY), or the wildcard IPv6 address (in6addr_any). The the multicast application would then call the bind function with this address in the in the sa_data member of the name parameter to associate the local IP address with the socket. If a wildcard address was specified, then Windows will select the local IP address to use. After the bind function completes, an application would then join the multicast group of interest. For more information on how to join a multicast group, see the section on Multicast Programming. This socket can then be used to receive multicast packets from the multicast group using the recv, recvfrom, WSARecv, WSARecvEx, WSARecvFrom, or WSARecvMsg functions. The bind function is not normally required  for send operations to  a multicast group. The sendto,WSASendMsg, and  WSASendTo functions implicitly bind the socket to the wildcard address if the socket is not already bound.  The bind function is required before the use of the send  or WSASend functions which do not perform an implicit bind and are allowed only on connected sockets, which means the socket must have already been bound for it to be connected. The bind function might be used before send operations using the sendto,WSASendMsg, or WSASendTo functions if an application wanted to select a specific local  IP address on a local computer with multiple network interfaces and local IP addresses. Otherwise an implicit bind to the wildcard address using the sendto,WSASendMsg , or WSASendTo functions might result in a different local IP address being used for send operations.  Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. The following example demonstrates the use of the bind function. For another example that uses the bind function, see Getting Started With Winsock. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "bind",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying an unbound socket."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "name",
        "description": "A pointer to a sockaddr structure of the local address to assign to the bound socket ."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "namelen",
        "description": "The length, in bytes, of the value pointed to by the name parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  closesocket function closes an existing socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  closesocket returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The closesocket function closes a socket. Use it to release the socket descriptor passed in the s parameter. Note that the socket descriptor passed in the s  parameter may immediately be reused by the system as soon as closesocket function is issued. As a result, it is not reliable to expect further references to the socket descriptor passed in the s parameter to fail with the error WSAENOTSOCK. A Winsock client must never issue closesocket on s concurrently with another Winsock function call. Any pending overlapped send and receive operations ( WSASend/ WSASendTo/ WSARecv/ WSARecvFrom with an overlapped socket) issued by any thread in this process are also canceled. Any event, completion routine, or completion port action specified for these overlapped operations is performed. The pending overlapped operations fail with the error status  WSA_OPERATION_ABORTED. An application should not assume that any outstanding I/O operations on a socket will all be guaranteed to completed when closesocket returns. The closesocket function will initiate cancellation on the outstanding I/O operations, but that does not mean that an application will receive I/O completion for these I/O operations by the time the closesocket function returns. Thus, an application should not cleanup any resources (WSAOVERLAPPED structures, for example) referenced by the outstanding I/O requests until the I/O requests are indeed completed. An application should always have a matching call to  closesocket for each successful call to  socket to return any socket resources to the system. The  linger structure maintains information about a specific socket that specifies how that socket should behave when data is queued to be sent and the  closesocket function is called on the socket. The l_onoff member of the linger structure determines whether a socket should remain open for a specified amount of time after a  closesocket function call to enable queued data to be sent. This member can be modified in two ways: The l_linger member of the linger structure determines the amount of time, in seconds, a socket should remain open. This member is only applicable if the l_onoff member of the linger structure is nonzero. The default parameters for a socket are the l_onoff member of the linger structure is zero, indicating that the socket should not remain open.  The default value for the l_linger member of the linger structure is zero, but this value is ignored when the l_onoff member is set to zero. To enable a socket to remain open, an application should set the l_onoff member to a nonzero value and set the l_linger member  to the desired timeout in seconds. To disable a socket from remaining open, an application only needs to set the  l_onoff member of the linger structure to zero. If an application calls the setsockopt function with the optname parameter set to SO_DONTLINGER to set the l_onoff member to a nonzero value, the value for the l_linger member is not specified. In this case, the timeout used is implementation dependent. If a previous timeout has been established for a socket (by previously calling the setsockopt function with the optname parameter set to SO_LINGER), this timeout value should be reinstated by the service provider. The semantics of  the closesocket function are affected by the socket options that set members of linger structure.  If the l_onoff member of the  LINGER structure is zero on a stream socket, the  closesocket call will return immediately and does not receive  WSAEWOULDBLOCK whether the socket is blocking or nonblocking. However, any data queued for transmission will be sent, if possible, before the underlying socket is closed. This is also called a graceful disconnect or close. In this case, the Windows Sockets provider cannot release the socket and other resources for an arbitrary period, thus affecting applications that expect to use all available sockets. This is the default behavior for a socket. If the  l_onoff member of the linger structure is nonzero and l_linger member is zero,  closesocket is not blocked even if queued data has not yet been sent or acknowledged. This is called a hard or abortive close, because the socket's virtual circuit is reset immediately, and any unsent data is lost. On Windows, any  recv call on the remote side of the circuit will fail with  WSAECONNRESET. If the  l_onoff member of the linger structure is set to nonzero and l_linger member is set to a nonzero timeout on a blocking socket, the  closesocket call blocks until the remaining data has been sent or until the timeout expires. This is called a graceful disconnect or close if all of the data is sent within timeout value specified in the l_linger member. If the timeout expires before all data has been sent, the Windows Sockets implementation terminates the connection before  closesocket returns and this is called a hard or abortive close. Setting the l_onoff member of the linger structure to nonzero and the l_linger member with a nonzero timeout interval on a nonblocking socket is not recommended. In this case, the call to  closesocket will fail with an error of  WSAEWOULDBLOCK if the close operation cannot be completed immediately. If  closesocket fails with WSAEWOULDBLOCK the socket handle is still valid, and a disconnect is not initiated. The application must call  closesocket again to close the socket. If the l_onoff member of the linger structure is nonzero and the l_linger member is a nonzero timeout interval on a blocking socket, the result of the  closesocket function can't be used to determine whether all data has been sent to the peer. If the data is sent before the timeout specified in the l_linger member expires or if the connection was aborted, the closesocket function won't return an error code (the return value from the closesocket function is zero).    The closesocket call will only block until all data has been delivered to the peer or the timeout expires. If the connection is reset because the timeout expires, then the socket will not go into TIME_WAIT state. If all data is sent within the timeout period, then the socket can go into TIME_WAIT state. If the l_onoff member of the linger structure is nonzero and the l_linger member is a zero timeout interval on a blocking socket,  then a call to closesocket will reset the connection. The socket will not go to the TIME_WAIT state. The getsockopt function can be called with the optname parameter set to SO_LINGER to retrieve the current value of the linger structure associated with a socket.   Here is a summary of  closesocket behavior: For additional information please see  Graceful Shutdown, Linger Options, and Socket Closure for more information.  Keep the following in mind:  The following are important issues associated with connection teardown when using Asynchronous Transfer Mode (ATM) and Windows Sockets 2: Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "closesocket",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying the socket to close."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  connect function establishes a connection to a specified socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  connect returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling  WSAGetLastError. On a blocking socket, the return value indicates success or failure of the connection attempt.  With a nonblocking socket, the connection attempt cannot be completed immediately. In this case,  connect will return SOCKET_ERROR, and  WSAGetLastError will return  WSAEWOULDBLOCK. In this case, there are three possible scenarios: Until the connection attempt completes on a nonblocking socket, all subsequent calls to  connect on the same socket will fail with the error code  WSAEALREADY, and  WSAEISCONN when the connection completes successfully. Due to ambiguities in version 1.1 of the Windows Sockets specification, error codes returned from  connect while a connection is already pending may vary among implementations. As a result, it is not recommended that applications use multiple calls to connect to detect connection completion. If they do, they must be prepared to handle  WSAEINVAL and  WSAEWOULDBLOCK error values the same way that they handle  WSAEALREADY, to assure robust operation. If the error code returned indicates the connection attempt failed (that is,  WSAECONNREFUSED,  WSAENETUNREACH,  WSAETIMEDOUT) the application can call  connect again for the same socket.  ",
    "remarks": "The  connect function is used to create a connection to the specified destination. If socket s, is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound. For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using name (an address in the namespace of the socket; for a detailed description, see  bind and  sockaddr). When the socket call completes successfully, the socket is ready to send and receive data. If the address member of the structure specified by the name parameter is filled with zeros,  connect will return the error  WSAEADDRNOTAVAIL. Any attempt to reconnect an active connection will fail with the error code  WSAEISCONN. For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such a case, this function returns the error  WSAEWOULDBLOCK. However, the operation proceeds.  When the success or failure outcome becomes known, it may be reported in one of two ways, depending on how the client registers for notification. For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by  connect is merely to establish a default destination address that can be used on subsequent  send/ WSASend and  recv/ WSARecv calls. Any datagrams received from an address other than the destination address specified will be discarded. If the address member of the structure specified by name is filled with zeros, the socket will be disconnected. Then, the default remote address will be indeterminate, so  send/ \t\t\t\tWSASend and  recv/ \t\t\t\tWSARecv calls will return the error code  WSAENOTCONN. However,  sendto/ \t\t\t\tWSASendTo and  recvfrom/ \t\t\t\tWSARecvFrom can still be used. The default destination can be changed by simply calling  connect again, even if the socket is already connected. Any datagrams queued for receipt are discarded if name is different from the previous  connect. For connectionless sockets, name can indicate any valid address, including a broadcast address. However, to connect to a broadcast address, a socket must use  setsockopt to enable the SO_BROADCAST option. Otherwise,  connect will fail with the error code  WSAEACCES. When a connection between sockets is broken, the socket that was connected should be discarded and new socket should be created. When a problem develops on a connected socket, the application must discard the socket and create the socket again in order to return to a stable point. The following example demonstrates the use of the connect function. For another example that uses the connect function, see Getting Started With Winsock.  IrDA implements the connect function with addresses of the form sockaddr_irda. Typically, a client application will create a socket with the socket function, scan the immediate vicinity for IrDA devices with the IRLMP_ENUMDEVICES socket option, choose a device from the returned list, form an address, and then call  connect. There is no difference between blocking and nonblocking semantics. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "connect",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying an unconnected socket."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "name",
        "description": "A pointer to the  sockaddr structure to which the connection should be established."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "namelen",
        "description": "The length, in bytes, of the sockaddr structure pointed to by the name parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  ConnectEx function establishes a connection to a specified socket, and optionally sends data once the connection is established. The  ConnectEx function is only supported on connection-oriented sockets.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "On success,  the ConnectEx function returns TRUE. On failure, the function returns FALSE. Use the  WSAGetLastError function to get extended error information. If a call to the  WSAGetLastError function returns ERROR_IO_PENDING, the operation initiated successfully and is in progress. Under such circumstances, the call may still fail when the overlapped operation completes. If the error code returned is WSAECONNREFUSED, WSAENETUNREACH, or WSAETIMEDOUT, the application can call  ConnectEx,  WSAConnect, or  connect again on the same socket.  ",
    "remarks": "The  ConnectEx function combines several socket functions into a single API/kernel transition. The following operations are performed when a call to the  ConnectEx function completes successfully: For applications targeted to Windows Vista and later, consider using the WSAConnectByList or WSAConnectByName function which greatly simplify client application design. The  ConnectEx function can only be used with connection-oriented sockets. The socket passed in the s parameter must be created with a socket type of SOCK_STREAM, SOCK_RDM, or SOCK_SEQPACKET. The lpSendBuffer parameter points to a buffer of data to send after the connection is established. The dwSendDataLength parameter specifies the length in bytes of this data to send. An application can request to send a large buffer of data using the ConnectEx in the same way that the send and WSASend functions can be used. But developers are strongly advised against sending  a huge buffer in a single call using ConnectEx, because this operation uses a large amount of system memory resources until the whole buffer has been sent. If the ConnectEx function is successful, a connection was established and all of the data pointed to by the lpSendBuffer parameter was sent to the address specified in the sockaddr structure pointed to by the name parameter.  The  ConnectEx function uses overlapped I/O. As a result, the  ConnectEx function enables an application to service a large number of clients with relatively few threads. In contrast, the  WSAConnect function, which does not use overlapped I/O, usually requires a separate thread to service each connection request when simultaneous  requests are received. Connection-oriented sockets are often unable to complete their connection immediately, and therefore the operation is initiated and the function immediately returns with the ERROR_IO_PENDING or WSA_IO_PENDING error. When the connect operation completes and success or failure is achieved, status is reported using the completion notification mechanism indicated in lpOverlapped. As with all overlapped function calls, you can use events or completion ports as the completion notification mechanism. The lpNumberOfBytesTransferred parameter of the  GetQueuedCompletionStatus or  GetOverlappedResult or  WSAGetOverlappedResult function indicates the number of bytes sent in the request. When the  ConnectEx function successfully completes, socket handle s can be passed to only the following functions: If the  TransmitFile function is called on a previously connected socket with both TF_DISCONNECT and TF_REUSE_SOCKET flags, the specified socket is returned to a state in which it is not connected, but still bound. In such cases, the handle of the socket can be passed to the  ConnectEx function in its s parameter, but the socket cannot be reused in an  AcceptEx function call. Similarly, the accepted socket reused using the  TransmitFile function cannot be used in a call to  ConnectEx. Note that in the case of a reused socket, ConnectEx is subject to the behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing  the ConnectEx call to be delayed. When the  ConnectEx function returns TRUE, the socket s is in the default state for a connected socket. The socket s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the  setsockopt function to set the SO_UPDATE_CONNECT_CONTEXT option. For example: The  getsockopt function can be used with the SO_CONNECT_TIME socket option to check whether a connection has been established while  ConnectEx is in progress. If a connection has been established, the   value returned in the optval parameter passed to the getsockopt function is the number of seconds the socket has been connected. If the socket is not connected,  the returned optval parameter contains 0xFFFFFFFF. Checking a connection in this manner is necessary to determine whether connections have been established for a period of time without sending any data; in such cases, it is recommended that such connections be terminated. For example:  If the address parameter of the  sockaddr structure pointed to in the name parameter is all zeros,  ConnectEx returns the error WSAEADDRNOTAVAIL. Any attempt to reconnect an active connection will fail with the error code WSAEISCONN. When a connected socket becomes closed for any reason, it is recommended that the socket be discarded and a new socket created. The reasoning for this is that it  is safest to assume that when things go awry on a connected socket for any reason, the application must discard teh socket and create the needed socket again in order to return to a stable point. If the  DisconnectEx function is called with the TF_REUSE_SOCKET flag, the specified socket is returned to a state in which it is not connected, but still bound. In such cases, the handle of the socket can be passed to the  ConnectEx function in its s parameter. The interval of  time that must elapse before TCP can release a closed connection and reuse its resources is known as the TIME_WAIT state or the  2MSL state. During this time, the connection can be reopened at much less cost to the client and server than establishing a new connection.  The TIME_WAIT behavior is specified in RFC 793, which requires that TCP maintains a closed connection for an interval at least equal to twice the maximum segment lifetime (MSL) of the network. When a connection is released, its socket pair and internal resources used for the socket can be used to support another connection. Windows TCP reverts to a TIME_WAIT state subsequent to the closing of a connection. While in the TIME_WAIT state, a socket pair cannot be reused. The TIME_WAIT period is configurable by modifying the following DWORD registry setting that represents the TIME_WAIT period in seconds.  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\TCPIP\\Parameters\\TcpTimedWaitDelay By default, the MSL is defined to be 120 seconds. The TcpTimedWaitDelay registry setting defaults to a value 240 seconds, which represents 2 times the maximum segment lifetime of 120 seconds or 4 minutes. However, you can use this entry to customize the interval.  Reducing the value of this entry allows TCP to release closed connections faster, providing more resources for new connections. However, if the value is too low, TCP might release connection resources before the connection is complete, requiring the server to use additional resources to re-establish the connection.  This registry setting can be set from 0 to 300 seconds. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL PASCAL",
    "category": "Windows Sockets (Winsock)",
    "name": "ConnectEx",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies an unconnected, previously bound socket. See Remarks for more information."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "name",
        "description": "A pointer to   a sockaddr structure that specifies the address to which to connect. For  IPv4, the sockaddr contains AF_INET for the address family, the destination IPv4 address, and the destination port. For  IPv6, the sockaddr structure contains AF_INET6 for the address family, the destination IPv6 address, the destination port, and may contain additional IPv6 flow and scope-id information."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "namelen",
        "description": "The length, in bytes, of the sockaddr structure pointed to by the name parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "PVOID",
        "name": "lpSendBuffer",
        "description": "A pointer to the buffer to be transferred after a connection is established. This parameter is optional. If the TCP_FASTOPEN option is enabled  on s before ConnectEx is called, then some of this data may be sent during connection establishment."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwSendDataLength",
        "description": "The length, in bytes, of data pointed to by the lpSendBuffer parameter. This parameter is ignored when the lpSendBuffer parameter is NULL."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwBytesSent",
        "description": "On successful return, this parameter points to a DWORD value that indicates the number of bytes that were sent after the connection was established. The bytes sent are from the buffer pointed to by the lpSendBuffer parameter. This parameter is ignored when the lpSendBuffer parameter is NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "An  OVERLAPPED structure used to process the request. The lpOverlapped parameter must be specified, and cannot be NULL."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  DisconnectEx function closes a connection on a socket, and allows the socket handle to be reused.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "On success, the DisconnectEx function  returns TRUE. On failure, the function returns FALSE.  Use the  WSAGetLastError function to get extended error information. If a call to the  WSAGetLastError function returns ERROR_IO_PENDING, the operation initiated successfully and is in progress. Under such circumstances, the call may still fail when the operation completes.  ",
    "remarks": "The  DisconnectEx function does not support datagram sockets. Therefore, the socket specified by hSocket must be connection-oriented, such as a SOCK_STREAM, SOCK_SEQPACKET, or SOCK_RDM socket.  When lpOverlapped is not NULL, overlapped I/O might not finish before  DisconnectEx returns, resulting in the  DisconnectEx function returning FALSE and a call to the  WSAGetLastError function returning ERROR_IO_PENDING. This design enables the caller to continue processing while the disconnect operation completes. Upon completion of the request, Windows sets either the event specified by the hEvent member of the  OVERLAPPED structure, or the socket specified by hSocket, to the signaled state.  The TIME_WAIT state determines the time that must elapse before TCP can release a closed connection and reuse its resources. This interval between closure and release is known as the TIME_WAIT state or 2MSL state. During this time, the connection can be reopened at much less cost to the client and server than establishing a new connection.  The TIME_WAIT behavior is specified in RFC 793 which requires that TCP maintains a closed connection for an interval at least equal to twice the maximum segment lifetime (MSL) of the network. When a connection is released, its socket pair and internal resources used for the socket can be used to support another connection. Windows TCP reverts to a TIME_WAIT state subsequent to the closing of a connection. While in the TIME_WAIT state, a socket pair cannot be re-used. The TIME_WAIT period is configurable by modifying the following DWORD registry setting that represents the TIME_WAIT period in seconds.  HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\TCPIP\\Parameters\\TcpTimedWaitDelay By default, the MSL is defined to be 120 seconds. The TcpTimedWaitDelay registry setting defaults to a value 240 seconds, which represents 2 times the maximum segment lifetime of 120 seconds or 4 minutes. However, you can use this entry to customize the interval.  Reducing the value of this entry allows TCP to release closed connections faster, providing more resources for new connections. However, if the value is too low, TCP might release connection resources before the connection is complete, requiring the server to use additional resources to re-establish the connection.  This registry setting can be set from 0 to 300 seconds. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "DisconnectEx",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "hSocket",
        "description": "A handle to a connected, connection-oriented socket."
      },
      {
        "in_out": "_In_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure. If the socket handle has been opened as overlapped, specifying this parameter results in an overlapped (asynchronous) I/O operation."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of flags that customizes processing of the function call. When this parameter is set to zero, no flags are set. The dwFlags parameter can have the following value.   FlagMeaning  TF_REUSE_SOCKET   Prepares the socket handle to be reused. When the  DisconnectEx request completes, the socket handle can be passed to the  AcceptEx or  ConnectEx function.  Note  The socket level disconnect is subject to the behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing  the DisconnectEx call to be delayed."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "reserved",
        "description": "Reserved. Must be zero. If nonzero, WSAEINVAL is returned."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  EnumProtocols function retrieves information about a specified set of network protocols that are active on a local host.",
    "library": "Mswsock.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Nspapi.h",
    "return_value": "If the function succeeds, the return value is the number of  PROTOCOL_INFO data structures written to the buffer pointed to by lpProtocolBuffer. If the function fails, the return value is SOCKET_ERROR(\u00e2\u0080\u00931). To get extended error information, call  GetLastError, which returns the following extended error code.  ",
    "remarks": "In the following sample code, the  EnumProtocols function retrieves information about all protocols that are available on a system. The code then examines each of the protocols in greater detail. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "EnumProtocols",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPINT",
        "name": "lpiProtocols",
        "description": "A pointer to a null-terminated array of protocol identifiers. The  EnumProtocols function retrieves information about the protocols specified by this array.     If lpiProtocols is NULL, the function retrieves information about all available protocols. The following protocol identifier values are defined.  ValueMeaning  IPPROTO_TCP   The Transmission Control Protocol (TCP), a connection-oriented stream protocol.   IPPROTO_UDP   The User Datagram Protocol (UDP), a connectionless datagram protocol.   ISOPROTO_TP4   The ISO connection-oriented transport protocol.   NSPROTO_IPX   The Internet Packet Exchange (IPX) protocol, a connectionless datagram protocol.   NSPROTO_SPX   The Sequenced Packet Exchange (SPX) protocol, a connection-oriented stream protocol.   NSPROTO_SPXII   The Sequenced Packet Exchange (SPX) protocol version 2, a connection-oriented stream protocol."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpProtocolBuffer",
        "description": "A pointer to a buffer that the function fills with an array of  PROTOCOL_INFO data structures."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by lpProtocolBuffer.     On output, the function sets this variable to the minimum buffer size needed to retrieve all of the requested information. For the function to succeed, the buffer must be at least this size."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  freeaddrinfo function frees address information that the  getaddrinfo function dynamically allocates in addrinfo structures.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The  freeaddrinfo function frees addrinfo structures dynamically allocated by the ANSI getaddrinfo function. The freeaddrinfo function frees the initial  addrinfo structure pointed to in the ai parameter, including any buffers to which structure members point, then continues freeing any  addrinfo structures linked by the ai_next member of the addrinfo structure. The  freeaddrinfo function continues freeing linked structures until a NULL ai_next member is encountered. Macros in the Winsock header file define a mixed-case function name of FreeAddrInfo and an ADDRINFOT structure. This FreeAddrInfo function should be called with the ai parameter of a pointer of type ADDRINFOT. When UNICODE or _UNICODE is not defined, FreeAddrInfo is defined to freeaddrinfo, the ANSI version of the function, and ADDRINFOT is defined to the addrinfo structure. When UNICODE or _UNICODE is defined, FreeAddrInfo is defined to FreeAddrInfoW, the Unicode version of the function, and ADDRINFOT is defined to the addrinfoW structure. The freeaddrinfo function was added to the Ws2_32.dll on Windows XP and later. The FreeAddrInfoW function is the Unicode version of  freeaddrinfo.  The FreeAddrInfoW function was added to the Ws2_32.dll in Windows XP with Service Pack 2 (SP2). The FreeAddrInfoW function cannot be used on versions of Windows earlier than Windows XP with SP2. Windows Phone 8: The freeaddrinfo function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The freeaddrinfo and  FreeAddrInfoW functions are supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "void",
    "category": "Windows Sockets (Winsock)",
    "name": "freeaddrinfo",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct addrinfo*",
        "name": "ai",
        "description": "A pointer to the  addrinfo structure or linked list of  addrinfo structures to be freed. All dynamic storage pointed to within the  addrinfo structure or structures is also freed."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  getaddrinfo function provides protocol-independent translation from an ANSI host name to an address.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "Success returns zero. Failure returns a nonzero Windows Sockets error code, as found in the  Windows Sockets Error Codes. Most nonzero error codes returned by the  getaddrinfo function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.  Use the  gai_strerror function to print error messages based on the EAI codes returned by the  getaddrinfo function. The  gai_strerror function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as  WSAGetLastError is recommended.  ",
    "remarks": "The getaddrinfo function is the ANSI version of a function that provides protocol-independent translation from host name to address. The Unicode version of this function is GetAddrInfoW. Developers are encouraged to use the GetAddrInfoW Unicode function rather than the getaddrinfo ANSI function. The getaddrinfo function returns results for the NS_DNS namespace. The getaddrinfo function aggregates all responses if more than     one namespace provider returns information. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local hosts file, or by other naming mechanisms for the NS_DNS namespace. Another name that can be used for the getaddrinfo function is GetAddrInfoA. Macros in the Ws2tcpip.h header file define GetAddrInfoA to getaddrinfo. Macros in the Ws2tcpip.h header file define a mixed-case function name of GetAddrInfo and a ADDRINFOT structure. This GetAddrInfo function should be called with the pNodeName and pServiceName parameters of a pointer of type  TCHAR and the pHints and ppResult parameters of a pointer of type ADDRINFOT. When UNICODE or _UNICODE is not defined, GetAddrInfo is defined to getaddrinfo, the ANSI version of the function, and  ADDRINFOT is defined to the addrinfo structure. When UNICODE or _UNICODE is defined, GetAddrInfo is defined to GetAddrInfoW, the Unicode version of the function, and  ADDRINFOT is defined to the addrinfoW structure. The parameter names and parameter types for the getaddrinfo function defined in the Ws2tcpip.h header file on the Platform Software Development Kit (SDK) for   Windows Server 2003, and Windows XP were different. One or both of the pNodeName or pServiceName parameters must point to a NULL-terminated ANSI string; generally both are provided. Upon success, a linked list of  addrinfo structures is returned in the ppResult parameter. The list can be processed by following the pointer provided in the ai_next member of each returned  addrinfo structure until a NULL pointer is encountered. In each returned  addrinfo structure, the ai_family, ai_socktype, and ai_protocol members correspond to respective arguments in a  socket   or WSASocket function call. Also, the ai_addr member in each returned  addrinfo structure points to a filled-in socket address structure, the length of which is specified in its ai_addrlen member. If the pNodeName parameter points to a computer name, all permanent addresses for the computer that can be used as a source address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the SkipAsSource member is set to false in the MIB_UNICASTIPADDRESS_ROW structure. If the pNodeName parameter points to a string equal to \"localhost\", all loopback addresses on the local computer are returned. If the pNodeName parameter contains an empty string, all registered addresses on the local computer are returned. On Windows Server 2003 and later if the pNodeName parameter points to a string equal to \"..localmachine\", all registered addresses on the local computer are returned. If the pNodeName parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the SkipAsSource member is set to true in the MIB_UNICASTIPADDRESS_ROW structure. See Windows Clustering for more information about clustering. Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This also changes the behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS. A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address.  This hotfix also changes behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS.  For more information, see Knowledge Base (KB) 2386184. A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2) that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS.  For more information, see Knowledge Base (KB) 975808.  Callers of the  getaddrinfo function can provide hints about the type of socket supported through an  addrinfo structure pointed to by the pHints parameter. When the pHints parameter is used, the following rules apply to its associated  addrinfo structure: A value of AF_UNSPEC for ai_family indicates the caller will accept any protocol family. This value can be used to return both IPv4 and IPv6 addresses for the host name pointed to by the pNodeName parameter. On Windows Server 2003 and Windows XP, IPv6 addresses are returned only if IPv6 is installed on the local computer. Other values in the  addrinfo structure provided in the pHints parameter indicate specific requirements. For example, if the caller handles only IPv4 and does not handle IPv6, the ai_family member should be set to AF_INET. For another example, if the caller handles only TCP and does not handle UDP, the ai_socktype member should be set to SOCK_STREAM. If the pHints parameter is a NULL pointer, the  getaddrinfo function treats it as if the  addrinfo structure in pHints were initialized with its ai_family member set to AF_UNSPEC and all other members set to zero. On Windows Vista and later when getaddrinfo is called from a service, if the operation is the result of a user process calling the service, then the service should impersonate the user.  This is to allow security to be properly enforced. The  getaddrinfo function can be used to convert a text string representation of an IP address to an addrinfo \t\t\tstructure that contains a sockaddr structure for the IP address and other information. To be used in this way, the string pointed to by the pNodeName parameter must contain a text representation of an IP address and the addrinfo \t\t\tstructure pointed to by the pHints parameter must have the AI_NUMERICHOST flag set in the ai_flags member. The string pointed to by the pNodeName parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an addrinfo \t\t\tstructure pointed to by the ppResult parameter. The returned addrinfo \t\t\tstructure contains a sockaddr structure for the IP address along with addition information about the IP address. For this method to work with an IPv6 address string on Windows Server 2003 and Windows XP, the IPv6 protocol must be installed on the local computer. Otherwise, the WSAHOST_NOT_FOUND error is returned. All information returned by the  getaddrinfo function pointed to by the ppResult parameter is dynamically allocated, including all  addrinfo structures, socket address structures, and canonical host name strings pointed to by  addrinfo structures. Memory allocated by a successful call to this function must be released with a subsequent call to freeaddrinfo. The following code example shows how to use the getaddrinfo function.  Internet host names typically consist of a very restricted set of characters:  With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as special ASCII character strings are known as Internationalized Domain Names (IDNs). A  mechanism called    Internationalizing Domain Names in Applications (IDNA) is used to handle    IDNs in a standard fashion.  The specifications for IDNs and IDNA are documented in RFC 3490, RTF 5890, and RFC 6365 published by the Internet Engineering Task Force (IETF). On Windows 8 and Windows Server 2012, the getaddrinfo function provides support for Internationalized Domain Name (IDN) parsing applied to the name passed in the pNodeName parameter. Winsock performs Punycode/IDN encoding and conversion.  This behavior can be disabled using the AI_DISABLE_IDN_ENCODING flag discussed below. On Windows 7 and Windows Server 2008 R2 or earlier, the getaddrinfo function does not currently provide support IDN parsing applied to the name passed in the pNodeName parameter. Winsock does not perform any Punycode/IDN conversion.  The wide character version of the GetAddrInfo function does not use Punycode to convert an IDN as per RFC 3490. The wide character version of the GetAddrInfo function when querying DNS encodes the Unicode name in UTF-8 format, the format used by Microsoft DNS servers in an enterprise environment. Several functions on Windows Vista and later support conversion between Unicode labels in an IDN to their ASCII equivalents. The resulting representation of each  Unicode label contains only ASCII characters and starts with the xn-- prefix if the Unicode label contained any non-ASCII characters. The reason for this is to support existing DNS servers on the Internet, since some DNS tools and servers only support ASCII characters (see RFC 3490). The IdnToAscii function uses Punycode to convert an IDN to the ASCII representation of the original Unicode string using the standard algorithm defined in RFC 3490. The IdnToUnicode function converts the ASCII form of an IDN to the normal Unicode UTF-16 encoding syntax. For more information and links to related draft standards, see Handling Internationalized Domain Names (IDNs). The IdnToAscii function can be used to convert an IDN name to the ASCII form that then can be passed in the pNodeName parameter to the getaddrinfo function. To pass this IDN name to the  GetAddrInfo function when the wide character version of this function is used (when UNICODE or _UNICODE is defined), you can use the MultiByteToWideChar function to convert the CHAR string into a WCHAR string.   Flags in the ai_flags member of the optional  addrinfo structure provided in the pHints parameter modify the behavior of the function. These flag bits are defined in the Ws2def.h header file on the Microsoft Windows Software Development Kit (SDK) for Windows 7. These flag bits are defined in the Ws2tcpip.h header file on the Windows SDK for Windows Server 2008 and Windows Vista.  These flag bits are defined in the Ws2tcpip.h header file on the Platform SDK for   Windows Server 2003, and Windows XP. The flag bits can be a combination of the following:  The following code example shows how to use the getaddrinfo function to convert a text string representation of an IP address to an addrinfo \t\t\tstructure that contains a sockaddr structure for the IP address and other information. The getaddrinfo function was added to the Ws2_32.dll on Windows XP and later. To execute an application that uses this function on earlier versions of Windows, then you need to include the Ws2tcpip.h and Wspiapi.h files. When the Wspiapi.h include file is added, the getaddrinfo function is defined to the WspiapiGetAddrInfo inline function in the Wspiapi.h file. At runtime, the WspiapiGetAddrInfo function is implemented in such a way that if the Ws2_32.dll or the Wship6.dll (the file containing getaddrinfo in the IPv6 Technology Preview for Windows 2000) does not include getaddrinfo, then a version of  getaddrinfo is implemented inline based on code in the Wspiapi.h header file. This inline code will be used on older Windows platforms that do not natively support the getaddrinfo function. The IPv6  protocol is supported on Windows 2000 when the IPv6 Technology Preview for Windows 2000 is installed. Otherwise getaddrinfo support on versions of Windows earlier than Windows XP is limited to handling IPv4 name resolution. The GetAddrInfoW function is the Unicode version of  getaddrinfo.  The GetAddrInfoW function was added to the Ws2_32.dll in Windows XP with Service Pack 2 (SP2). The GetAddrInfoW function cannot be used on versions of Windows earlier than Windows XP with SP2. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "getaddrinfo",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PCSTR",
        "name": "pNodeName",
        "description": "A pointer to a NULL-terminated ANSI string that contains a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCSTR",
        "name": "pServiceName",
        "description": "A pointer to a NULL-terminated ANSI string that contains either a service name or port number represented as a string. ..."
      },
      {
        "in_out": "_In_opt_",
        "type": "const ADDRINFOA*",
        "name": "pHints",
        "description": "A pointer to an  addrinfo structure that provides hints about the type of socket the caller supports.  The ai_addrlen, ai_canonname, ai_addr, and ai_next members of the addrinfo structure pointed to by the pHints parameter must be zero or NULL. Otherwise the GetAddrInfoEx function will fail with WSANO_RECOVERY. See the Remarks for more details."
      },
      {
        "in_out": "_Out_",
        "type": "PADDRINFOA*",
        "name": "ppResult",
        "description": "A pointer to a linked list of one or more  addrinfo structures that contains response information about the host."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  FreeAddrInfoEx function frees address information that the  GetAddrInfoEx function dynamically allocates in addrinfoex structures.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The  FreeAddrInfoEx function frees addrinfoex structures dynamically allocated by the  GetAddrInfoEx function. The FreeAddrInfoEx function frees the initial  addrinfoex structure pointed to in the pAddrInfo parameter, including any buffers to which structure members point, then continues freeing any  addrinfoex structures linked by the ai_next member of the addrinfoex structure. The  FreeAddrInfoEx function continues freeing linked structures until a NULL ai_next member is encountered. When UNICODE or _UNICODE is defined, FreeAddrInfoEx is defined to FreeAddrInfoExW, the Unicode version of the function, and ADDRINFOEX is defined to the addrinfoexW structure. When UNICODE or _UNICODE is not defined, FreeAddrInfoEx is defined to FreeAddrInfoExA, the ANSI version of the function, and ADDRINFOEX is defined to the addrinfoexA structure. Windows 8.1 and Windows Server 2012 R2: The FreeAddrInfoExW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "void WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "FreeAddrInfoEx",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PADDRINFOEX",
        "name": "pAddrInfo",
        "description": "A pointer to the  addrinfoex structure or linked list of  addrinfoex structures to be freed. All dynamic storage pointed to within the  addrinfoex structure or structures is also freed."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 10,
    "description": "The  GetAddrInfoEx function provides protocol-independent name resolution with additional parameters to qualify which namespace providers should handle the request.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  GetAddrInfoEx returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as found in the  Windows Sockets Error Codes. Most nonzero error codes returned by the  GetAddrInfoEx function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.  Use the  gai_strerror function to print error messages based on the EAI codes returned by the  GetAddrInfoEx function. The  gai_strerror function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as  WSAGetLastError is recommended.  ",
    "remarks": "The GetAddrInfoEx  function provides protocol-independent translation from host name to address and from service name to port number. The GetAddrInfoEx  function is an enhanced version of the getaddrinfo and GetAddrInfoW functions. The GetAddrInfoEx  function allows specifying the namespace provider to resolve the query. The GetAddrInfoEx  function aggregates and returns results from multiple namespace providers, unless a specific namespace provider is specified. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local hosts file, an email provider (the NS_EMAIL namespace), or by other naming mechanisms. When UNICODE or _UNICODE is defined, GetAddrInfoEx is defined to GetAddrInfoExW, the Unicode version of this function. The string parameters are defined to the PWSTR data type and the ADDRINFOEXW structure is used. On Windows 8 and Windows Server 2012, the timeout, lpOverlapped, lpCompletionRoutine, and lpNameHandle parameters may be used to call the GetAddrInfoEx function so that it can complete asynchronously. When UNICODE or _UNICODE is not defined, GetAddrInfoEx is defined to GetAddrInfoExA, the ANSI version of this function. The string parameters are of the PCSTR data type and the ADDRINFOEXA structure is used. The timeout, lpOverlapped, lpCompletionRoutine, and lpNameHandle parameters must be set to NULL. One or both of the pName or pServiceName parameters must point to a NULL-terminated string. Generally both are provided. Upon success, a linked list of  addrinfoex structures is returned in the ppResult parameter. The list can be processed by following the pointer provided in the ai_next member of each returned  addrinfoex structure until a NULL pointer is encountered. In each returned  addrinfoex structure, the ai_family, ai_socktype, and ai_protocol members correspond to respective arguments in a  socket or WSASocket function call. Also, the ai_addr member in each returned  addrinfoex structure points to a filled-in socket address structure, the length of which is specified in its ai_addrlen member. If the pName parameter points to a computer name, all permanent addresses for the computer that can be used as a source address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the SkipAsSource member is set to false in the MIB_UNICASTIPADDRESS_ROW structure. If the pName parameter points to a string equal to \"localhost\", all loopback addresses on the local computer are returned. If the pName parameter contains an empty string, all registered addresses on the local computer are returned. On Windows Server 2003 and later if the pName parameter points to a string equal to \"..localmachine\", all registered addresses on the local computer are returned. If the pName parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the SkipAsSource member is set to true in the MIB_UNICASTIPADDRESS_ROW structure. See Windows Clustering for more information about clustering. Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This also changes the behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS. A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address.  This hotfix also changes behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS.  For more information, see Knowledge Base (KB) 2386184. A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2) that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS.  For more information, see Knowledge Base (KB) 975808.  Callers of the  GetAddrInfoEx function can provide hints about the type of socket supported through an  addrinfoex structure pointed to by the pHints parameter. When the pHints parameter is used, the following rules apply to its associated  addrinfoex structure: Other values in the  addrinfoex structure provided in the pHints parameter indicate specific requirements. For example, if the caller handles only IPv4 and does not handle IPv6, the ai_family member should be set to AF_INET. For another example, if the caller handles only TCP and does not handle UDP, the ai_socktype member should be set to SOCK_STREAM. If the pHints parameter is a NULL pointer, the  GetAddrInfoEx function treats it as if the  addrinfoex structure in pHints were initialized with its ai_family member set to AF_UNSPEC and all other members set to NULL or zero. When GetAddrInfoEx is called from a service, if the operation is the result of a user process calling the service, the service should impersonate the user.  This is to allow security to be properly enforced. The  GetAddrInfoEx function can be used to convert a text string representation of an IP address to an addrinfoex \t\t\tstructure that contains a   sockaddr structure for the IP address and other information. To be used in this way, the string pointed to by the pName parameter must contain a text representation of an IP address and the addrinfoex \t\t\tstructure pointed to by the pHints parameter must have the AI_NUMERICHOST flag set in the ai_flags member. The string pointed to by the pName parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an addrinfoex \t\t\tstructure pointed to by the ppResult parameter. The returned addrinfoex \t\t\tstructure contains a sockaddr structure for the IP address along with additional information about the IP address. Multiple namespace providers may be installed on a local computer for the same namespace. For example, the base Windows TCP/IP networking software registers for the NS_DNS namespace. The Microsoft Forefront Threat Management Gateway (TMG) and the older Microsoft Internet Security and Acceleration (ISA) Server include Firewall Client software that also registers for the NS_DNS namespace. When the dwNameSpace parameter is set to a value (NS_DNS, for example) and the lpNspId parameter is NULL, the results returned by the GetAddrInfoEx function are the merged results from all namespace providers that register for the specified namespace with duplicate results eliminated. The lpNspId parameter should be set to the GUID of the specific namespace provider if only a single namespace provider is to be queried. If the pNameSpace parameter is set to NS_ALL, then the results from querying all namespace providers is merged and returned. In this case, duplicate responses may be returned in the results pointed to by the ppResult parameter if multiple namespace providers return the same information. On Windows 8 and Windows Server 2012, if the GetAddrInfoEx function will complete asynchronously, the pointer returned in the lpNameHandle parameter may be used with the GetAddrInfoExCancel function. The handle returned is valid when GetAddrInfoEx returns until the completion routine is called, the event is triggered, or GetAddrInfoExCancel function is called with this handle. All information returned by the  GetAddrInfoEx function pointed to by the ppResult parameter is dynamically allocated, including all  addrinfoex structures, socket address structures, and canonical host name strings pointed to by  addrinfoex structures. Memory allocated by a successful call to this function must be released with a subsequent call to FreeAddrInfoEx. The following example demonstrates the use of the GetAddrInfoEx function. The following example demonstrates how to use the GetAddrInfoEx function asynchronous to resolve a name to an IP address..  Internet host names typically consist of a very restricted set of characters:  With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as special ASCII character strings are known as Internationalized Domain Names (IDNs). A  mechanism called    Internationalizing Domain Names in Applications (IDNA) is used to handle    IDNs in a standard fashion.  The specifications for IDNs and IDNA are documented in RFC 3490, RTF 5890, and RFC 6365 published by the Internet Engineering Task Force (IETF). On Windows 8 and Windows Server 2012, the GetAddrInfoEx function provides support for Internationalized Domain Name (IDN) parsing applied to the name passed in the pName parameter. Winsock performs Punycode/IDN encoding and conversion. This behavior can be disabled using the AI_DISABLE_IDN_ENCODING flag discussed below. On Windows 7 and Windows Server 2008 R2 or earlier, the GetAddrInfoEx function does not currently provide support for  IDN parsing applied to the name passed in the pName parameter. The wide character version of the GetAddrInfoEx function does not use Punycode to convert an IDN Punycode format as per RFC 3490. The wide character version of the GetAddrInfoEx  function when querying DNS encodes the Unicode name in UTF-8 format, the format used by Microsoft DNS servers in an enterprise environment. Several functions on Windows Vista and later support conversion between Unicode labels in an IDN to their ASCII equivalents. The resulting representation of each  Unicode label contains only ASCII characters and starts with the xn-- prefix if the Unicode label contained any non-ASCII characters. The reason for this is to support existing DNS servers on the Internet, since some DNS tools and servers only support ASCII characters (see RFC 3490). The IdnToAscii function uses Punycode to convert an IDN to the ASCII  representation of the original Unicode string using the standard algorithm defined in RFC 3490. The IdnToUnicode function converts the ASCII form of an IDN to the normal Unicode UTF-16 encoding syntax. For more information and links to related draft standards, see Handling Internationalized Domain Names (IDNs). The IdnToAscii function can be used to convert an IDN name to an ASCII form that then can be passed in the pName parameter to the GetAddrInfoEx function when the ASCII version of this function is used (when UNICODE and _UNICODE are not  defined). To pass this IDN name to the  GetAddrInfoEx function when the wide character version of this function is used (when UNICODE or _UNICODE is defined), you can use the MultiByteToWideChar function to convert the  CHARstring into a WCHAR string.   Flags in the ai_flags member of the optional  addrinfoex structure provided in the hints parameter modify the behavior of the function. These flag bits are defined in the Ws2def.h header file on the Microsoft Windows Software Development Kit (SDK) for Windows 7. These flag bits are defined in the Ws2tcpip.h header file on the Windows SDK for Windows Server 2008 and Windows Vista.  These flag bits are defined in the Ws2tcpip.h header file on the Platform Software Development Kit (SDK) for   Windows Server 2003, and Windows XP. The flag bits can be a combination of the following:  ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "GetAddrInfoEx",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PCTSTR",
        "name": "pName",
        "description": "A pointer to a NULL-terminated string containing a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCTSTR",
        "name": "pServiceName",
        "description": "A pointer to an optional NULL-terminated string that contains either a service name or port number represented as a string. ..."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNameSpace",
        "description": "An optional namespace identifier that determines which namespace providers are queried.  Passing a specific namespace identifier will result in only namespace providers that support the specified namespace being queried. Specifying NS_ALL will result in all installed and active namespace providers being queried.   Options for the dwNameSpace parameter are listed in the Winsock2.h include file. Several namespace providers are added on Windows Vista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many other values are possible.  ValueMeaning  NS_ALL 0   All installed and active namespaces.   NS_DNS 12   The domain name system (DNS) namespace.   NS_NETBT 13   The NetBIOS over TCP/IP (NETBT) namespace.   NS_WINS 14   The Windows Internet Naming Service (NS_WINS) namespace.   NS_NLA 15   The network location awareness (NLA) namespace.  This namespace identifier is supported on Windows XP and later.   NS_BTH 16   The Bluetooth namespace.  This namespace identifier is supported on Windows Vista and later.   NS_NTDS 32   The Windows NT Directory Services (NS_NTDS) namespace.    NS_EMAIL 37   The email namespace.  This namespace identifier is supported on Windows Vista and later.   NS_PNRPNAME 38   The peer-to-peer namespace for a specific peer name.  This namespace identifier is supported on Windows Vista and later.   NS_PNRPCLOUD 39   The peer-to-peer namespace for a collection of peer names.  This namespace identifier is supported on Windows Vista and later."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPGUID",
        "name": "lpNspId",
        "description": "A pointer to an optional GUID of a specific namespace provider to query in the case where  multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for specific namespace provider will result in only the specified namespace provider being queried. The WSAEnumNameSpaceProviders function can be called to retrieve the GUID for a namespace provider."
      },
      {
        "in_out": "_In_opt_",
        "type": "const ADDRINFOEX*",
        "name": "pHints",
        "description": "A pointer to an  addrinfoex structure that provides hints about the type of socket the caller supports.  The ai_addrlen, ai_canonname, ai_addr, and ai_next members of the addrinfoex structure pointed to by the pHints parameter must be zero or NULL. Otherwise the GetAddrInfoEx function will fail with WSANO_RECOVERY. See the Remarks for more details."
      },
      {
        "in_out": "_Out_",
        "type": "PADDRINFOEX*",
        "name": "ppResult",
        "description": "A pointer to a linked list of one or more  addrinfoex structures that contains response information about the host."
      },
      {
        "in_out": "_In_opt_",
        "type": "struct timeval*",
        "name": "timeout",
        "description": "An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call.  This parameter is only supported when the UNICODE or _UNICODE macro has been defined in the sources before calling the GetAddrInfoEx function. Otherwise, this parameter is currently reserved and must be set to NULL since a timeout option is not supported."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "An optional pointer to an overlapped structure used for asynchronous operation.  This parameter is only supported when the UNICODE or _UNICODE macro has been defined in the sources before calling the GetAddrInfoEx function. On Windows 8 and Windows Server 2012, if no lpCompletionRoutine parameter is specified, the hEvent member of the OVERLAPPED structure must be set to a manual-reset event to be called upon completion of an asynchronous call. If a completion routine has been specified, the hEvent member must be NULL. When the event specified by hEvent has been set, the result of the operation can be retrieved by calling GetAddrInfoExOverlappedResult function. On Windows 8 and Windows Server 2012 whenever the UNICODE or _UNICODE macro is not defined,  this parameter is currently reserved and must be set to NULL.  On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to NULL since asynchronous operations are not supported."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPLOOKUPSERVICE_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "An optional pointer to a function to be invoked upon successful completion for asynchronous operations.  This parameter is only supported when the UNICODE or _UNICODE macro has been defined in the sources before calling the GetAddrInfoEx function. On Windows 8 and Windows Server 2012, if this parameter is specified, it must be a pointer to a function with the following signature:   C++     Copy      typedef    void    (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(        __in      DWORD    dwError,        __in      DWORD    dwBytes,        __in      LPWSAOVERLAPPED lpOverlapped        );          When the asynchronous operation has completed, the completion routine will be invoked with lpOverlapped parameter set to the value of lpOverlapped parameter passed to GetAddrInfoEx. The Pointer member of the OVERLAPPED structure will be set to the value of the ppResult parameter of the original call. If the Pointer member points to a non-NULL pointer to the addrinfoex structure, it is the caller's responsibility to call FreeAddrInfoEx to free the addrinfoex  structure. The dwError parameter passed to the completion routine will be set to a Winsock error code. The dwBytes parameter is reserved for future use and must be ignored. On Windows 8 and Windows Server 2012 whenever the UNICODE or _UNICODE macro is not defined,  this parameter is currently reserved and must be set to NULL.  On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to NULL since asynchronous operations are not supported."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPHANDLE",
        "name": "lpNameHandle",
        "description": "An optional pointer used only for asynchronous operations.   This parameter is only supported when the UNICODE or _UNICODE macro has been defined in the sources before calling the GetAddrInfoEx function. On Windows 8 and Windows Server 2012, if the GetAddrInfoEx function will complete asynchronously, the pointer returned in this field may be used with the GetAddrInfoExCancel function. The handle returned is valid when GetAddrInfoEx returns until the completion routine is called, the event is triggered, or GetAddrInfoExCancel function is called with this handle. On Windows 8 and Windows Server 2012 whenever the UNICODE or _UNICODE macro is not defined,  this parameter is currently reserved and must be set to NULL.  On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to NULL since asynchronous operations are not supported."
      }
    ],
    "min_client": "Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  FreeAddrInfoW function frees address information that the  GetAddrInfoW function dynamically allocates in addrinfoW structures.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The  FreeAddrInfoW function frees addrinfoW structures dynamically allocated by the Unicode GetAddrInfoW function. The FreeAddrInfoW function frees the initial  addrinfoW structure pointed to in the pAddrInfo parameter, including any buffers to which structure members point, then continues freeing any  addrinfoW structures linked by the ai_next member of the addrinfoW structure. The  FreeAddrInfoW function continues freeing linked structures until a NULL ai_next member is encountered. Macros in the Winsock header file define a mixed-case function name of FreeAddrInfo and an ADDRINFOT structure. This FreeAddrInfo function should be called with the pAddrInfo parameter of a pointer of type ADDRINFOT. When UNICODE or _UNICODE is defined, FreeAddrInfo is defined to FreeAddrInfoW, the Unicode version of the function, and ADDRINFOT is defined to the addrinfoW structure. When UNICODE or _UNICODE is not defined, FreeAddrInfo is defined to freeaddrinfo, the ANSI version of the function, and ADDRINFOT is defined to the addrinfo structure. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "void WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "FreeAddrInfoW",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PADDRINFOW",
        "name": "pAddrInfo",
        "description": "A pointer to the  addrinfoW structure or linked list of  addrinfoW structures to be freed. All dynamic storage pointed to within the  addrinfoW structure or structures is also freed."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  GetAddrInfoW function provides protocol-independent translation from a Unicode host name to an address.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "Success returns zero. Failure returns a nonzero Windows Sockets error code, as found in the  Windows Sockets Error Codes. Most nonzero error codes returned by the GetAddrInfoW function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.  Use the  gai_strerror function to print error messages based on the EAI_* codes returned by the  GetAddrInfoW function. The  gai_strerror function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of a traditional Windows Sockets function, such as  WSAGetLastError, is recommended.  ",
    "remarks": "The GetAddrInfoW function is the Unicode version of a function that provides protocol-independent translation from host name to address. The ANSI version of this function is getaddrinfo. The GetAddrInfoW function returns results for the NS_DNS namespace. The GetAddrInfoW function aggregates all responses if more than     one namespace provider returns information. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local hosts file, or by other naming mechanisms  for the NS_DNS namespace. Macros in the Winsock header file define a mixed-case function name of GetAddrInfo and a ADDRINFOT structure. This GetAddrInfo function should be called with the pNodeName and pServiceName parameters of a pointer of type  TCHAR and the pHints and ppResult parameters of a pointer of type ADDRINFOT. When UNICODE or _UNICODE is defined, GetAddrInfo is defined to GetAddrInfoW, the Unicode version of the function, and ADDRINFOT is defined to the addrinfoW structure. When UNICODE or _UNICODE is not defined, GetAddrInfo is defined to getaddrinfo, the ANSI version of the function, and ADDRINFOT is defined to the addrinfo structure. One or both of the pNodeName or pServiceName parameters must point to a NULL-terminated Unicode string; generally both are provided. Upon success, a linked list of  addrinfoW structures is returned in the ppResult parameter. The list can be processed by following the pointer provided in the ai_next member of each returned  addrinfoW structure until a NULL pointer is encountered. In each returned  addrinfoW structure, the ai_family, ai_socktype, and ai_protocol members correspond to respective arguments in a  socket  or WSASocket function call. Also, the ai_addr member in each returned  addrinfoW structure points to a filled-in socket address structure, the length of which is specified in its ai_addrlen member. If the pNodeName parameter points to a computer name, all permanent addresses for the computer that can be used as a source address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the SkipAsSource member is set to false in the MIB_UNICASTIPADDRESS_ROW structure. If the pNodeName parameter points to a string equal to \"localhost\", all loopback addresses on the local computer are returned. If the pNodeName parameter contains an empty string, all registered addresses on the local computer are returned. On Windows Server 2003 and later if the pNodeName parameter points to a string equal to \"..localmachine\", all registered addresses on the local computer are returned. If the pNodeName parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the SkipAsSource member is set to true in the MIB_UNICASTIPADDRESS_ROW structure. See Windows Clustering for more information about clustering. Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This also changes the behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS. A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address.  This hotfix also changes behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS.  For more information, see Knowledge Base (KB) 2386184. A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2) that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such that if the SkipAsSource member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the SkipAsSource member is set to true, the IP address is not registered in DNS.  For more information, see Knowledge Base (KB) 975808.  Callers of the  GetAddrInfoW function can provide hints about the type of socket supported through an  addrinfoW structure pointed to by the pHints parameter. When the pHints parameter is used, the following rules apply to its associated  addrinfoW structure: Other values in the  addrinfoW structure provided in the pHints parameter indicate specific requirements. For example, if the caller handles only IPv4 and does not handle IPv6, the ai_family member should be set to AF_INET. For another example, if the caller handles only TCP and does not handle UDP, the ai_socktype member should be set to SOCK_STREAM. If the pHints parameter is a NULL pointer, the  GetAddrInfoW function handles it as if the  addrinfoW structure in pHints were initialized with its ai_family member set to AF_UNSPEC and all other members set to zero. On Windows Vista and later when GetAddrInfoW is called from a service, if the operation is the result of a user process calling the service, then the service should impersonate the user.  This is to allow security to be properly enforced. The  GetAddrInfoW function can be used to convert a text string representation of an IP address to an addrinfoW \t\t\tstructure that contains a sockaddr structure for the IP address and other information. To be used in this way, the string pointed to by the pNodeName parameter must contain a text representation of an IP address and the addrinfoW \t\t\tstructure pointed to by the pHints parameter must have the AI_NUMERICHOST flag set in the ai_flags member. The string pointed to by the pNodeName parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an addrinfoW \t\t\tstructure pointed to by the ppResult parameter. The returned addrinfoW \t\t\tstructure contains a sockaddr structure for the IP address along with additional information about the IP address. For this method to work with an IPv6 address string on Windows Server 2003 and Windows XP, the IPv6 protocol must be installed on the local computer. Otherwise, the WSAHOST_NOT_FOUND error is returned. All information returned by the  GetAddrInfoW function pointed to by the ppResult parameter is dynamically allocated, including all  addrinfoW structures, socket address structures, and canonical host name strings pointed to by  addrinfoW structures. Memory allocated by a successful call to this function must be released with a subsequent call to FreeAddrInfoW. The following code example shows how to use the GetAddrInfoW function.  Internet host names typically consist of a very restricted set of characters:  With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as special ASCII character strings are known as Internationalized Domain Names (IDNs). A  mechanism called    Internationalizing Domain Names in Applications (IDNA) is used to handle    IDNs in a standard fashion.  The specifications for IDNs and IDNA are documented in RFC 3490, RTF 5890, and RFC 6365 published by the Internet Engineering Task Force (IETF). On Windows 8 and Windows Server 2012, the GetAddrInfoW function provides support for Internationalized Domain Name (IDN) parsing applied to the name passed in the pNodeName parameter. Winsock performs Punycode/IDN encoding and conversion.  This behavior can be disabled using the AI_DISABLE_IDN_ENCODING flag discussed below. On Windows 7 and Windows Server 2008 R2 or earlier, the GetAddrInfoW function does not currently provide support for IDN parsing applied to the name passed in the pNodeName parameter. Winsock does not perform any Punycode/IDN conversion.  The GetAddrInfoW function does not use Punycode to convert an IDN as per RFC 3490. The GetAddrInfoW function when querying DNS encodes the Unicode name in UTF-8 format, the format used by Microsoft DNS servers in an enterprise environment. Several functions on Windows Vista and later support conversion between Unicode labels in an IDN to their ASCII equivalents. The resulting representation of each  Unicode label contains only ASCII characters and starts with the xn-- prefix if the Unicode label contained any non-ASCII characters. The reason for this is to support existing DNS servers on the Internet, since some DNS tools and servers only support ASCII characters (see RFC 3490). The IdnToAscii function use Punycode to convert an IDN to the ASCII representation of the original Unicode string using the standard algorithm defined in RFC 3490. The IdnToUnicode function converts the ASCII form of an IDN to the normal Unicode UTF-16 encoding syntax. For more information and links to related draft standards, see Handling Internationalized Domain Names (IDNs). The IdnToAscii function can be used to convert an IDN name to the ASCII form. To pass this ASCII form to the  GetAddrInfoW function, you can use the MultiByteToWideChar function to convert the CHAR string into a WCHAR string that then can be passed in the pNodeName parameter to the GetAddrInfoW function.   Flags in the ai_flags member of the optional  addrinfoW structure provided in the pHints parameter modify the behavior of the function. These flag bits are defined in the Ws2def.h header file on the Microsoft Windows Software Development Kit (SDK) for Windows 7. These flag bits are defined in the Ws2tcpip.h header file on the Windows SDK for Windows Server 2008 and Windows Vista.  These flag bits are defined in the Ws2tcpip.h header file on the Platform Software Development Kit (SDK) for   Windows Server 2003, and Windows XP. The flag bits can be a combination of the following:  Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "GetAddrInfoW",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "pNodeName",
        "description": "A pointer to a NULL-terminated Unicode string that contains a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address."
      },
      {
        "in_out": "_In_opt_",
        "type": "PCWSTR",
        "name": "pServiceName",
        "description": "A pointer to a NULL-terminated Unicode string that contains either a service name or port number represented as a string. ..."
      },
      {
        "in_out": "_In_opt_",
        "type": "const ADDRINFOW*",
        "name": "pHints",
        "description": "A pointer to an  addrinfoW structure that provides hints about the type of socket the caller supports.  The ai_addrlen, ai_canonname, ai_addr, and ai_next members of the addrinfoW structure pointed to by the pHints parameter must be zero or NULL. Otherwise the GetAddrInfoEx function will fail with WSANO_RECOVERY. See the Remarks for more details."
      },
      {
        "in_out": "_Out_",
        "type": "PADDRINFOW*",
        "name": "ppResult",
        "description": "A pointer to a linked list of one or more  addrinfoW structures that contains response information about the host."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  gai_strerror function assists in printing error messages based on the EAI_* errors returned by the  getaddrinfo function. Note that the  gai_strerror function is not thread safe, and therefore, use of traditional Windows Sockets functions such as the  WSAGetLastError function is recommended.",
    "library": "",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Ws2tcpip.h;  Wspiapi.h on Windows 2000",
    "return_value": "",
    "remarks": "If the ecode parameter is not an error code value that  getaddrinfo returns, the  gai_strerror function returns a pointer to a string that indicates an unknown error. ",
    "return_type": "char*",
    "category": "Windows Sockets (Winsock)",
    "name": "gai_strerror",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "ecode",
        "description": "Error code from the list of available  getaddrinfo error codes. For a complete listing of error codes, see the  getaddrinfo function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "The  GetAcceptExSockaddrs function parses the data obtained from a call to the  AcceptEx function and passes the local and remote addresses to a  sockaddr structure.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The  GetAcceptExSockaddrs function is used exclusively with the  AcceptEx function to parse the first data that the socket receives into local and remote addresses. The  AcceptEx function returns local and remote address information in an internal format. Application developers need to use the GetAcceptExSockaddrs function if there is a need for the sockaddr structures containing the local or remote addresses.  Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "void",
    "category": "Windows Sockets (Winsock)",
    "name": "GetAcceptExSockaddrs",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "lpOutputBuffer",
        "description": "A pointer to a buffer that receives the first block of data sent on a connection resulting from an  AcceptEx call. Must be the same lpOutputBuffer parameter that was passed to the  AcceptEx \t\t\t function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwReceiveDataLength",
        "description": "The number of bytes in the buffer used for receiving the first data. This value must be equal to the dwReceiveDataLength parameter that was passed to the  AcceptEx \t\t\t function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwLocalAddressLength",
        "description": "The number of bytes reserved for the local address information. This value must be equal to the dwLocalAddressLength parameter that was passed to the  AcceptEx function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwRemoteAddressLength",
        "description": "The number of bytes reserved for the remote address information. This value must be equal to the dwRemoteAddressLength parameter that was passed to the  AcceptEx function."
      },
      {
        "in_out": "_Out_",
        "type": "LPSOCKADDR*",
        "name": "LocalSockaddr",
        "description": "A pointer to the  sockaddr structure that receives the local address of the connection (the same information that would be returned by the  getsockname function). This parameter must be specified."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "LocalSockaddrLength",
        "description": "The size, in bytes, of the local address. This parameter must be specified."
      },
      {
        "in_out": "_Out_",
        "type": "LPSOCKADDR*",
        "name": "RemoteSockaddr",
        "description": "A pointer to the sockaddr structure that receives the remote address of the connection (the same information that would be returned by the  getpeername function). This parameter must be specified."
      },
      {
        "in_out": "_Out_",
        "type": "LPINT",
        "name": "RemoteSockaddrLength",
        "description": "The size, in bytes, of the local address. This parameter must be specified."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 10,
    "description": "[GetAddressByName is no longer available for use as of Windows Sockets 2. Instead, use the functions detailed in  Protocol-Independent Name Resolution.]",
    "library": "Mswsock.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Nspapi.h",
    "return_value": "If the function succeeds, the return value is the number of  CSADDR_INFO data structures written to the buffer pointed to by lpCsaddrBuffer. If the function fails, the return value is SOCKET_ERROR( \u00e2\u0080\u00931). To get extended error information, call  GetLastError, which returns the following extended error value.  ",
    "remarks": "This function is a more powerful version of the  gethostbyname function. The  GetAddressByName function works with multiple name services.  The  GetAddressByName function lets a client obtain a Windows Sockets address for a network service. The client specifies the service of interest by its service type and service name. Many name services support a default prefix or suffix that the name service provider considers when resolving service names. For example, in the DNS namespace, if a domain is named \"nt.microsoft.com\", and \"ftp millikan\" is provided as input, the DNS software fails to resolve \"millikan\", but successfully resolves \"millikan.nt.microsoft.com\". Note that the  GetAddressByName function can search for a service address in two ways: within a particular namespace, or within a set of default namespaces. Using a default namespace, an administrator can specify that certain namespaces will be searched for service addresses only if specified by name. An administrator or namespace\u00e2\u0080\u0094setup program can also control the ordering of namespace searches. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "GetAddressByName",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNameSpace",
        "description": "The namespace, or set of default namespaces, that the operating system should query for network address information. Use one of the following constants to specify a namespace.  ValueMeaning  NS_DEFAULT   A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. This is the value that most applications should use for dwNameSpace.   NS_DNS   The Domain Name System (DNS) used in the Internet for host name resolution.   NS_NETBT   The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration. Note that NS_NETBT can access a WINS server to perform the resolution.   NS_SAP   The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.   NS_TCPIP_HOSTS   Lookup value in the <systemroot>\\system32\\drivers\\etc\\hosts file.   NS_TCPIP_LOCAL   Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.     Most calls to  GetAddressByName should use the special value NS_DEFAULT. This lets a client get by with no knowledge of which namespaces are available on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes."
      },
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "lpServiceType",
        "description": "A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes definitions of several GUID service types, and macros for working with them. The Svcguid.h header file is not automatically included by the Winsock2.h header file."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpServiceName",
        "description": "A pointer to a zero-terminated string that uniquely represents the service name. For example, \"MY SNA SERVER\". Setting lpServiceName to NULL is the equivalent of setting dwResolution to RES_SERVICE. The function operates in its second mode, obtaining the local address to which a service of the specified type should bind. The function stores the local address within the LocalAddr member of the  CSADDR_INFO structures stored into *lpCsaddrBuffer. If dwResolution is set to RES_SERVICE, the function ignores the lpServiceName parameter. If dwNameSpace is set to NS_DNS, *lpServiceName is the name of the host."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPINT",
        "name": "lpiProtocols",
        "description": "A pointer to a zero-terminated array of protocol identifiers. The function restricts a name resolution attempt to namespace providers that offer these protocols. This lets the caller limit the scope of the search. If lpiProtocols is set to NULL, the function retrieves information on all available protocols."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwResolution",
        "description": "A set of bit flags that specify aspects of the service name resolution process. The following bit flags are defined.  ValueMeaning  RES_SERVICE   If set, the function retrieves the address to which a service of the specified type should bind. This is the equivalent to setting the lpServiceName parameter to NULL. If this flag is clear, normal name resolution occurs.   RES_FIND_MULTIPLE   If this flag is set, the operating system performs an extensive search of all namespaces for the service. It asks every appropriate namespace to resolve the service name. If this flag is clear, the operating system stops looking for service addresses as soon as one is found.   RES_SOFT_SEARCH   This flag is valid if the namespace supports multiple levels of searching. If this flag is valid and set, the operating system performs a simple and quick search of the namespace. This is useful if an application only needs to obtain easy-to-find addresses for the service. If this flag is valid and clear, the operating system performs a more extensive search of the namespace."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSERVICE_ASYNC_INFO",
        "name": "lpServiceAsyncInfo",
        "description": "Reserved for future use; must be set to NULL."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpCsaddrBuffer",
        "description": "A pointer to a buffer to receive one or more  CSADDR_INFO data structures. The number of structures written to the buffer depends on the amount of information found in the resolution attempt. You should assume that multiple structures will be written, although in many cases there will only be one."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "A pointer to a variable that, upon input, specifies the size, in bytes, of the buffer pointed to by lpCsaddrBuffer. Upon output, this variable contains the total number of bytes required to store the array of  CSADDR_INFO structures. If this value is less than or equal to the input value of *lpdwBufferLength, and the function is successful, this is the number of bytes actually stored in the buffer. If this value is greater than the input value of *lpdwBufferLength, the buffer was too small, and the output value of *lpdwBufferLength is the minimal required buffer size."
      },
      {
        "in_out": "_Inout_",
        "type": "LPTSTR",
        "name": "lpAliasBuffer",
        "description": "A pointer to a buffer to receive alias information for the network service. If a namespace supports aliases, the function stores an array of zero-terminated name strings into the buffer pointed to by lpAliasBuffer. There is a double zero-terminator at the end of the list. The first name in the array is the service's primary name. Names that follow are aliases. An example of a namespace that supports aliases is DNS. If a namespace does not support aliases, it stores a double zero-terminator into the buffer. This parameter is optional, and can be set to NULL."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwAliasBufferLength",
        "description": "A pointer to a variable that, upon input, specifies the size, in elements (characters), of the buffer pointed to by lpAliasBuffer. Upon output, this variable contains the total number of elements (characters) required to store the array of name strings. If this value is less than or equal to the input value of *lpdwAliasBufferLength, and the function is successful, this is the number of elements actually stored in the buffer. If this value is greater than the input value of *lpdwAliasBufferLength, the buffer was too small, and the output value of *lpdwAliasBufferLength is the minimal required buffer size. If lpAliasBuffer is NULL, lpdwAliasBufferLength is meaningless and can also be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetAddrInfoExCancel function cancels an asynchronous operation by the GetAddrInfoEx function.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  GetAddrInfoExCancel returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as found in the  Windows Sockets Error Codes. ",
    "remarks": "The GetAddrInfoExCancel function cancels an asynchronous GetAddrInfoEx operation. The result is that the user's completion     mechanism, either a callback or an event, is immediately invoked. No results are returned,     and the error code returned for the GetAddrInfoEx asynchronous operation is set to WSA_E_CANCELLED. If the GetAddrInfoEx request has already completed or timed out,     or the handle is invalid, and WSA_INVALID_HANDLE will be returned by GetAddrInfoExCancel function. Since many of the underlying operations (legacy name service providers, for example) are synchronous, these operations     will not actually be cancelled. These operations will continue running and consuming resources. Once the     last outstanding name service provider request has completed, the resources will be released. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "GetAddrInfoExCancel",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPHANDLE",
        "name": "lpHandle",
        "description": "The handle of the asynchronous operation to cancel. This is the handle returned in the lpNameHandle parameter by the GetAddrInfoEx function."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  GetAddrInfoExOverlappedResult function gets the return code for an OVERLAPPED structure used by an asynchronous operation for the  GetAddrInfoEx function.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  the GetAddrInfoExOverlappedResult function returns NO_ERROR (0). When the     underlying operation hasn't yet completed, the GetAddrInfoExOverlappedResult function  returns WSAEINPROGRESS. On failure, the GetAddrInfoExOverlappedResult function  returns WSAEINVAL. ",
    "remarks": "The  GetAddrInfoExOverlappedResult function is used with the GetAddrInfoEx function for asynchronous operations. If the GetAddrInfoExOverlappedResult function returns WSAEINVAL, the only way to distinguish whether GetAddrInfoExOverlappedResult function or the asynchronous operation returned  the     error is to check that the lpOverlapped parameter was not NULL. If the lpOverlapped parameter was NULL, then the GetAddrInfoExOverlappedResult function was passed a NULL pointer and failed. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "GetAddrInfoExOverlappedResult",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an OVERLAPPED structure for the asynchronous operation."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "[gethostbyaddr is no longer recommended for use as of Windows Sockets 2. Instead, use getnameinfo.]",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  gethostbyaddr returns a pointer to the  hostent structure. Otherwise, it returns a null pointer, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  gethostbyaddr function returns a pointer to the  hostent structure that contains the name and address corresponding to the given network address. The memory for the hostent structure  returned by the gethostbyaddr function is allocated internally by the Winsock DLL from thread local storage. Only a single hostent structure is allocated and used, no matter how many times the gethostbyaddr or gethostbyname functions are called on the thread. The returned  hostent structure  must be copied to an application buffer if additional calls are to be made to the gethostbyaddr or gethostbyname functions on the same thread. Otherwise, the return value will be overwritten by subsequent gethostbyaddr or gethostbyname calls on the same thread. The internal memory allocated for the returned  hostent structure is released by the Winsock DLL when the thread exits. An application should not try to release the memory used by the returned hostent structure. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other function calls to gethostbyaddr or gethostbyname. Although  gethostbyaddr no longer recommended for use as of Windows Sockets 2 and the getnameinfo function should be used,  gethostbyaddr is capable of returning a NetBIOS name;  getnameinfo is not. Developers requiring NetBIOS name resolution may need to use gethostbyaddr until their applications are completely independent of NetBIOS names.  The following example demonstrates the use of the gethostbyaddr function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "struct hostent* FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "gethostbyaddr",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "addr",
        "description": "A pointer to an address in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "len",
        "description": "The length, in bytes, of the address."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "type",
        "description": "The type of the address, such as the AF_INET address family type (used with TCP, UDP, and other associated Internet protocols). Possible values for the address family are defined in the Winsock2.h header file.  On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. The table below lists the possible values for address family that are supported.   ValueMeaning  AF_INET 2   The Internet Protocol version 4 (IPv4) address family.   AF_NETBIOS 17   The NetBIOS address family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed.   AF_INET6 23   The Internet Protocol version 6 (IPv6) address family."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  gethostbyname function retrieves host information corresponding to a host name from a host database.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  gethostbyname returns a pointer to the  hostent structure described above. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  gethostbyname function returns a pointer to a  hostent structure\u00e2\u0080\u0094a structure allocated by Windows Sockets. The  hostent structure contains the results of a successful search for the host specified in the name parameter. If the host specified in the name parameter has both IPv4 and IPv6 addresses, only the IPv4 addresses will be returned. The  gethostbyname function can only return IPv4 addresses for the name parameter. The  getaddrinfo function and associated addrinfo structure should be used if IPv6 addresses for the host are required or if both IPv4 and IPv6 addresses for the host are required. If the name parameter points to an empty string or name is NULL, the returned string is the same as the string returned by a successful  gethostname function call (the standard host name for the local computer). If the name parameter contains a string representation of a legal IPv4 address, then the binary IPv4 address that represents the string is returned in the hostent structure. The h_name member of the hostent structure contains the string representation of the IPv4 address and the h_addr_list  contains the binary IPv4 address. If the name parameter contains a string representation of an IPv6 address or an illegal IPv4 address, then the  gethostbyname function will fail and return WSANO_DATA. The memory for the hostent structure  returned by the gethostbyname function is allocated internally by the Winsock DLL from thread local storage. Only a single hostent structure is allocated and used, no matter how many times the gethostbyaddr  \t\t or gethostbyname functions are called on the thread. The returned  hostent structure  must be copied to an application buffer if additional calls are to be made to the gethostbyname or gethostbyaddr functions on the same thread. Otherwise, the return value will be overwritten by subsequent gethostbyname or gethostbyaddr  \t\t calls on the same thread. The internal memory allocated for the returned  hostent structure is released by the Winsock DLL when the thread exits. An application should not try to release the memory used by the returned hostent structure. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other function calls to gethostbyname or gethostbyaddr  \t\t. The  gethostbyname function cannot take an IP address string as a parameter passed to it in the name and resolve it to a host name. Such a request is treated exactly as a string representation of an IPv4 address or an unknown host name were passed. An application can use the inet_addr to convert an IPv4 address string to a binary IPv4 address, then use another function,  gethostbyaddr, to resolve the IPv4 address to a host name.  The following examples demonstrates the use of the gethostbyname function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "struct hostent* FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "gethostbyname",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "name",
        "description": "A pointer to the null-terminated name of the host to resolve."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  gethostname function retrieves the standard host name for the local computer.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  gethostname returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  gethostname function returns the name of the local host into the buffer specified by the name parameter. The host name is returned as a null-terminated string. The form of the host name is dependent on the Windows Sockets provider\u00e2\u0080\u0094it can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed that the name returned will be successfully parsed by  gethostbyname and  WSAAsyncGetHostByName. The maximum length of the name returned in the buffer pointed to by the name parameter is dependent on the namespace provider. If the  gethostname function is used on a cluster resource on Windows Server 2008, Windows Server 2003, or    Windows 2000 Server and the _CLUSTER_NETWORK_NAME_ environment variable is defined, then the value in this environment variable overrides the actual hostname and is returned. On a cluster resource, the _CLUSTER_NETWORK_NAME_ environment variable contains the name of the cluster. The  gethostname function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID defined in the Svgguid.h header file. If no namespace provider responds, then the  gethostname function returns the NetBIOS name of the local computer. The maximum length, in bytes, of the string returned in the buffer pointed to by the name parameter is dependent on the namespace provider, but this string must be 256 bytes or less. So if a buffer of 256 bytes is passed in the name parameter and the namelen parameter is set to 256, the buffer size will always be adequate.  Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "gethostname",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "name",
        "description": "A pointer to a buffer that receives the local host name."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "namelen",
        "description": "The length, in bytes, of the buffer pointed to by the name parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetHostNameW function retrieves the standard host name for the local computer as a Unicode string.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  GetHostNameW returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  GetHostNameW function returns the name of the local host into the buffer specified by the name parameter in Unicode (UTF-16). The host name is returned as a null-terminated Unicode string. The form of the host name is dependent on the Windows Sockets provider\u00e2\u0080\u0094it can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed that the name returned will be successfully parsed by  GetAddrInfoW. With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as special ASCII character strings (Punycode) are known as Internationalized Domain Names (IDNs). A  mechanism called    Internationalizing Domain Names in Applications (IDNA) is used to handle    IDNs in a standard fashion. The GetHostNameW function does not convert the local hostname between Punycode and Unicode. The GetAddrInfoW function provides support for Internationalized Domain Name (IDN) parsing and performs Punycode/IDN encoding and conversion. If the  GetHostNameW function is used on a cluster resource on Windows Server 2012 and the _CLUSTER_NETWORK_NAME_ environment variable is defined, then the value in this environment variable overrides the actual hostname and is returned. On a cluster resource, the _CLUSTER_NETWORK_NAME_ environment variable contains the name of the cluster. The  GetHostNameW function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID defined in the Svgguid.h header file. If no namespace provider responds, then the  GetHostNameW function returns the NetBIOS name of the local computer in Unicode. The maximum length, in wide characters, of the string returned in the buffer pointed to by the name parameter is dependent on the namespace provider, but this string must be 256 wide characters or less. So if a buffer of 256 wide characters is passed in the name parameter and the namelen parameter is set to 256, the buffer size will always be adequate.  Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "GetHostNameW",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "PWSTR",
        "name": "name",
        "description": "A pointer to a buffer that receives the local host name as a null-terminated Unicode string."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "namelen",
        "description": "The length, in wide characters, of the buffer pointed to by the name parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "The  getipv4sourcefilter inline function  retrieves the multicast filter state for an IPv4  socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  getipv4sourcefilter returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getipv4sourcefilter inline function is used to retrieve the multicast filter state for an IPv4  socket. If the app does not know the size of the source list    beforehand, it can make a guess (zero, for example). If upon    completion, the SourceCount parameter holds a larger value, the operation can be    repeated with a large enough buffer. On return, the SourceCount parameter is always updated to be the total number    of sources in the filter, while the buffer pointed to by the SourceList parameter  will hold as many source    addresses as fit, up to the minimum of the array size passed in as    the original SourceCount value and the total number of sources in the    filter. This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can  use these functions to retrieve and set the multicast source address filters associated with a socket. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "getipv4sourcefilter",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor that identifies a multicast socket."
      },
      {
        "in_out": "_In_",
        "type": "IN_ADDR",
        "name": "Interface",
        "description": "The local IPv4 address of the interface or the interface index on which the multicast group should be joined or dropped.  This value is in network byte order. If this member specifies an IPv4 address of 0.0.0.0, the default IPv4 multicast interface is used. Any IP address in the 0.x.x.x block (first octet of 0) except IPv4 address 0.0.0.0 is treated as an interface index. An interface index is a 24-bit number, and the 0.0.0.0/8 IPv4 address block is not used (this range is reserved).  To use an interface index of 1 would be the same as an IP address of 0.0.0.1."
      },
      {
        "in_out": "_In_",
        "type": "IN_ADDR",
        "name": "Group",
        "description": "The IPv4 address of the multicast group."
      },
      {
        "in_out": "_Out_",
        "type": "MULTICAST_MODE_TYPE*",
        "name": "FilterMode",
        "description": "A pointer to a value to receive the multicast filter mode for multicast group address when the function returns."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "SourceCount",
        "description": "On input, a pointer to a value that indicates the maximum number of source addresses that will fit in the buffer pointed to by the SourceList parameter. On output, a pointer to a value that indicates the total number of source addresses associated with the multicast filter."
      },
      {
        "in_out": "_Out_",
        "type": "IN_ADDR*",
        "name": "SourceList",
        "description": "A pointer to a buffer to receive the list of IP addresses associated with the multicast filter. If SourceCount is zero on input, a NULL pointer    may be supplied."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  GetNameByType function retrieves the name of a network service for the specified service type.",
    "library": "Mswsock.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Nspapi.h",
    "return_value": "If the function succeeds, the return value is not SOCKET_ERROR (\u00e2\u0080\u00931). If the function fails, the return value is SOCKET_ERROR (\u00e2\u0080\u00931). To get extended error information, call  GetLastError. ",
    "remarks": "",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "GetNameByType",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "lpServiceType",
        "description": "A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes definitions of several GUID service types, and macros for working with them. The Svcguid.h header file is not automatically included by the Winsock2.h header file."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpServiceName",
        "description": "A pointer to a buffer to receive a zero-terminated string that uniquely represents the name of the network service."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNameLength",
        "description": "A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by lpServiceName. On output, the variable contains the actual size of the service name string, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The  getnameinfo function provides protocol-independent name resolution from an address to an ANSI host name and from a port number  to the ANSI service name.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  getnameinfo returns zero. Any nonzero return value indicates failure and a specific error code can be retrieved by calling  WSAGetLastError. Nonzero error codes returned by the  getnameinfo function also map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.  Use the  gai_strerror function to print error messages based on the EAI codes returned by the  getnameinfo function. The  gai_strerror function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as  WSAGetLastError is recommended. In addition, the following error codes can be returned.  ",
    "remarks": "The getnameinfo function is the ANSI version of a function that provides protocol-independent name resolution. The getnameinfo function is used to translate the contents of a socket address structure to a node name and/or a service name. For IPv6 and IPv4 protocols, Name resolution can be by the Domain Name System (DNS), a local hosts file, or by other naming mechanisms. This function can be used to determine the host name for an IPv4 or IPv6  address, a reverse DNS lookup, or determine the service name for a port number. The getnameinfo function can also be used to convert an IP address or  a port number in a sockaddr structure to an ANSI string. This function can also be used to determine the IP address for a host name. Another name that can be used for the getnameinfo function is GetNameInfoA. Macros in the Ws2tcpip.h header file define GetNameInfoA to getnameinfo. The Unicode version of this function available on Windows XP with Service Pack 2 (SP2) and later is GetNameInfoW. Macros in the Winsock header file define a mixed-case function name of GetNameInfo that can be used when the application is targeted for  Windows XP with SP2 and later (_WIN32_WINNT >= 0x0502). This GetNameInfo function should be called with the host and serv parameters of a pointer of type  TCHAR. When UNICODE or _UNICODE is not defined, GetNameInfo is defined to the ANSI version and getnameinfo is called with the host and serv parameters of a pointer of type char. When UNICODE or _UNICODE is defined, GetNameInfo is defined to the Unicode version and GetNameInfoW is called with the pNodeBuffer and pServiceBuffer parameters of a pointer of type PWCHAR. To simplify determining buffer requirements for the host and serv parameters, the following values for maximum host name length and maximum service name are defined in the Ws2tcpip.h header file.  The flags parameter can be used to customize processing of the  getnameinfo function. The following flags are available: When the NI_NAMEREQD flag is set, a host name that cannot be resolved by DNS results in an error. Setting the NI_NOFQDN flag results in local hosts having only their Relative Distinguished Name (RDN) returned in the host parameter. Setting the NI_NUMERICHOST flag returns the numeric form of the host name instead of its name. The numeric form of the host name is also returned if the host name cannot be resolved by DNS. Setting the NI_NUMERICSERV flag returns the port number of the service instead of its name. Also, if  a host name is not found for an IP address (127.0.0.2, for example), the hostname is returned as the  IP address. On Windows Vista and later, if NI_NUMERICSERV is not specified in the flags parameter and the port number contained in sockaddr structure pointed to by the sa  parameter does not resolve to a well known service, the getnameinfo function returns the numeric form of the    service address (the port number) as a numeric string. When NI_NUMERICSERV is specified, the port number is returned as a numeric string. This behavior is specified in section 6.2 of RFC 3493. For more information, see www.ietf.org/rfc3493.txt On Windows Server 2003 and earlier, if NI_NUMERICSERV is not specified in the flags parameter, and the port number contained in the sockaddr structure pointed to by the sa  parameter does not resolve to a well known service, the getnameinfo function fails. When NI_NUMERICSERV is specified, the port number is returned as a numeric string. Setting the NI_DGRAM flag indicates that the service is a datagram service. This flag is necessary for the few services that provide different port numbers for UDP and TCP service.   The following code example shows how to use the getnameinfo function. The getnameinfo function was added to the Ws2_32.dll on Windows XP and later. If you want to execute an application using this function on earlier versions of Windows (Windows 2000, Windows NT, and Windows Me/98/95), then you need to include the Ws2tcpip.h file and also include the Wspiapi.h file. When the Wspiapi.h include file is added, the getnameinfo function is defined to the WspiapiGetNameInfo inline function in the Wspiapi.h file. At runtime, the WspiapiGetNameInfo function is implemented in such a way that if the Ws2_32.dll or the Wship6.dll (the file containing getnameinfo in the IPv6 Technology Preview for Windows 2000) does not include getnameinfo, then a version of  getnameinfo is implemented inline based on code in the Wspiapi.h header file. This inline code will be used on older Windows platforms that do not natively support the getnameinfo function. The IPv6  protocol is supported on Windows 2000 when the IPv6 Technology Preview for Windows 2000 is installed. Otherwise getnameinfo support on versions of Windows earlier than Windows XP is limited to handling IPv4 name resolution. The GetNameInfoW function is the Unicode version of  getnameinfo.  The GetNameInfoW function was added to the Ws2_32.dll in Windows XP with SP2. The GetNameInfoW function cannot be used on versions of Windows earlier than Windows XP with SP2. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "getnameinfo",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const struct sockaddr FAR*",
        "name": "sa",
        "description": "A pointer to a socket address structure that contains the address and port number of the socket. For IPv4, the sa parameter points to a  sockaddr_in structure. For IPv6, the sa parameter points to a sockaddr_in6 structure."
      },
      {
        "in_out": "_In_",
        "type": "socklen_t",
        "name": "salen",
        "description": "The length, in bytes, of the structure pointed to by the sa parameter."
      },
      {
        "in_out": "_Out_",
        "type": "char FAR*",
        "name": "host",
        "description": "A pointer to  an ANSI string used to hold the host name. On success, the host name is returned as a Fully Qualified Domain Name (FQDN) by default. If the host parameter is NULL, this indicates the caller does not want to receive a host name string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "hostlen",
        "description": "The length, in bytes, of the buffer pointed to by the host parameter. The caller must provide a buffer large enough to hold the host name, including the terminating NULL character."
      },
      {
        "in_out": "_Out_",
        "type": "char FAR*",
        "name": "serv",
        "description": "A pointer to  an ANSI string to hold the service name. On success, an ANSI string that represents the service name associated with the port number is returned. If the serv parameter is NULL, this indicates the caller does not want to receive a service name string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "servlen",
        "description": "The length, in bytes, of the buffer pointed to by the serv parameter. The caller must provide a buffer large enough to hold the service name, including the terminating NULL character."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "flags",
        "description": "A value used to customize processing of the  getnameinfo function. See the Remarks section."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  GetNameInfoW function provides protocol-independent name resolution from an address to a Unicode host name and from a port number  to the Unicode service name.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  GetNameInfoW returns zero. Any nonzero return value indicates failure and a specific error code can be retrieved by calling  WSAGetLastError. Nonzero error codes returned by the  GetNameInfoW function also map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.  You can use the  gai_strerror function to print error messages based on the EAI codes returned by the  GetNameInfoW function. The  gai_strerror function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as  WSAGetLastError is recommended. In addition, the following error codes can be returned.  ",
    "remarks": "The GetNameInfoW function is the Unicode version of a function that provides protocol-independent name resolution. The GetNameInfoW function is used to translate the contents of a socket address structure to a node name and/or a service name. For the IPv6 and IPv4 protocols, name resolution can be by the Domain Name System (DNS), a local hosts file, or by other naming mechanisms. This function can be used to determine the host name for an IPv4 or IPv6  address, a reverse DNS lookup, or determine the service name for a port number. The GetNameInfoW function can also be used to convert an IP address or  a port number in a SOCKADDR structure to an Unicode string. This function can also be used to determine the IP address for a host name. The ANSI version of this function is getnameinfo. Macros in the Winsock header file define a mixed-case function name of GetNameInfo that can be used when the application is targeted for  Windows XP with Service Pack 2 (SP2) and later (_WIN32_WINNT >= 0x0502). This GetNameInfo function should be called with the pNodeBuffer and pServiceBuffer parameters of a pointer of type  TCHAR. When UNICODE or _UNICODE is defined, GetNameInfo is defined to the Unicode version and GetNameInfoW is called with the host and serv parameters of a pointer of type char. When UNICODE or _UNICODE is not defined, GetNameInfo is defined to the ANSI version and getnameinfo is called with the pNodeBuffer and pServiceBuffer parameters of a pointer of type PWCHAR. To simplify determining buffer requirements for the pNodeBuffer and pServiceBuffer parameters, the following values for maximum host name length and maximum service name are defined in the Ws2tcpip.h header file:  The Flags parameter can be used to customize processing of the  GetNameInfoW function. The following flags are available: When the NI_NAMEREQD flag is set, a host name that cannot be resolved by the DNS results in an error. Setting the NI_NOFQDN flag results in local hosts having only their Relative Distinguished Name (RDN) returned in the pNodeBuffer parameter. Setting the NI_NUMERICHOST flag returns the numeric form of the host name instead of its name. The numeric form of the host name is also returned if the host name cannot be resolved by DNS. Setting the NI_NUMERICSERV flag returns the port number of the service instead of its name. Also, if  a host name is not found for an IP address (127.0.0.2, for example), the hostname is returned as the  IP address. On Windows Vista and later, if NI_NUMERICSERV is not specified in the flags parameter, and the port number contained in sockaddr structure pointed to by the sa  parameter does not resolve to a well known service, the GetNameInfoW function returns the numeric form of the    service address (the port number) as a numeric string. When NI_NUMERICSERV is specified, the port number is returned as a numeric string. This behavior is specified in section 6.2 of RFC 3493. For more information, see www.ietf.org/rfc/rfc3493.txt On Windows Server 2003 and earlier, if NI_NUMERICSERV is not specified in the flags parameter and the port number contained in sockaddr structure pointed to by the sa  parameter does not resolve to a well known service, the GetNameInfoW function fails. When NI_NUMERICSERV is specified, the port number is returned as a numeric string. Setting the NI_DGRAM flag indicates that the service is a datagram service. This flag is necessary for the few services that provide different port numbers for UDP and TCP service.   Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. The following example demonstrates the use of the GetNameInfoW function. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "GetNameInfoW",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const SOCKADDR*",
        "name": "pSockaddr",
        "description": "A pointer to a socket address structure containing the IP address and port number of the socket. For IPv4, the pSockaddr parameter points to a  sockaddr_in structure. For IPv6, the pSockaddr parameter points to a sockaddr_in6 structure."
      },
      {
        "in_out": "_In_",
        "type": "socklen_t",
        "name": "SockaddrLength",
        "description": "The length, in bytes, of the structure pointed to by the pSockaddr parameter."
      },
      {
        "in_out": "_Out_",
        "type": "PWCHAR",
        "name": "pNodeBuffer",
        "description": "A pointer to  a Unicode string to hold the host name. On success, a pointer to the Unicode host name is returned as a Fully Qualified Domain Name (FQDN) by default. If the pNodeBuffer parameter is NULL, this indicates the caller does not want to receive a host name string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "NodeBufferSize",
        "description": "The number of WCHAR characters in the buffer pointed to by the pNodeBuffer parameter. The caller must provide a buffer large enough to hold the Unicode host name, including the terminating NULL character."
      },
      {
        "in_out": "_Out_",
        "type": "PWCHAR",
        "name": "pServiceBuffer",
        "description": "A pointer to  a Unicode string to hold the service name. On success, a pointer is returned to a Unicode string representing the service name associated with the port number. If the pServiceBuffer parameter is NULL, this indicates the caller does not want to receive a service name string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ServiceBufferSize",
        "description": "The number of WCHAR characters in the buffer pointed to by the pServiceBuffer parameter. The caller must provide a buffer large enough to hold the Unicode service name, including the terminating NULL character."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "Flags",
        "description": "A value used to customize processing of the  GetNameInfoW function. See the Remarks section."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  getpeername function retrieves the address of the peer to which a socket is connected.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  getpeername returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getpeername function retrieves the address of the peer connected to the socket s and stores the address in the SOCKADDR structure identified by the name parameter. This function works with any address family and it simply returns the address to which the socket is connected. The  getpeername function can be used only on a connected socket. For datagram sockets, only the address of a peer specified in a previous  connect call will be returned. Any address specified by a previous  sendto call will not be returned by  getpeername. On call, the namelen parameter contains the size, in bytes, of the name buffer. On return, the namelen parameter contains the actual size, in bytes, of the name parameter returned. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "getpeername",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a connected socket."
      },
      {
        "in_out": "_Out_",
        "type": "struct sockaddr*",
        "name": "name",
        "description": "The  SOCKADDR structure that receives the address of the peer."
      },
      {
        "in_out": "_Inout_",
        "type": "int*",
        "name": "namelen",
        "description": "A pointer to the size, in bytes, of the name parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  getprotobyname function retrieves the protocol information corresponding to a protocol name.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  getprotobyname returns a pointer to the  protoent. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getprotobyname function returns a pointer to the  protoent structure containing the name(s) and protocol number that correspond to the protocol specified in the name parameter. All strings are null-terminated. The  protoent structure is allocated by the Windows Sockets library. An application must never attempt to modify this structure or to free any of its components. Furthermore, like  hostent, only one copy of this structure is allocated per thread, so the application should copy any information that it needs before issuing any other Windows Sockets function calls. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "struct PROTOENT* FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "getprotobyname",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "name",
        "description": "Pointer to a null-terminated protocol name."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  getprotobynumber function retrieves protocol information corresponding to a protocol number.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  getprotobynumber returns a pointer to the  protoent structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "This  getprotobynumber function returns a pointer to the  protoent structure as previously described in  getprotobyname. The contents of the structure correspond to the given protocol number. The pointer that is returned points to the structure allocated by Windows Sockets. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information that it needs before issuing any other Windows Sockets function calls. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "struct PROTOENT* FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "getprotobynumber",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "number",
        "description": "Protocol number, in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  getservbyname function retrieves service information corresponding to a service name and protocol.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  getservbyname returns a pointer to the  servent structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getservbyname function returns a pointer to the  servent structure containing the name(s) and service number that match the string in the name parameter. All strings are null-terminated. The pointer that is returned points to the  servent structure allocated by the Windows Sockets library. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other Windows Sockets function calls. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "struct servent* FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "getservbyname",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "name",
        "description": "A pointer to a null-terminated service name."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "proto",
        "description": "A pointer to a null-terminated protocol name. If this pointer is NULL,  the getservbyname function returns the first service entry where name matches the s_name member of the  servent structure or the s_aliases member of the  servent structure. Otherwise,  getservbyname matches both the name and the proto."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  getservbyport function retrieves service information corresponding to a port and protocol.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  getservbyport returns a pointer to the  servent structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getservbyport function returns a pointer to a  servent structure as it does in the  getservbyname function. The  servent structure is allocated by Windows Sockets. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other Windows Sockets function calls. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "struct servent* FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "getservbyport",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "port",
        "description": "Port for a service, in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "proto",
        "description": "Optional pointer to a protocol name. If this is null,  getservbyport returns the first service entry for which the port matches the s_port of the  servent structure. Otherwise,  getservbyport matches both the port and the proto parameters."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  GetService function retrieves information about a network service in the context of a set of default namespaces or a specified namespace. The network service is specified by its type and name. The information about the service is obtained as a set of  NS_SERVICE_INFO data structures.",
    "library": "Mswsock.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Nspapi.h",
    "return_value": "If the function succeeds, the return value is the number of  NS_SERVICE_INFO structures stored in *lpBuffer. Zero indicates that no structures were stored. If the function fails, the return value is SOCKET_ERROR ( \u00e2\u0080\u0093 1). To get extended error information, call  GetLastError, which returns one of the following extended error values.  ",
    "remarks": "",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "GetService",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNameSpace",
        "description": "The namespace, or a set of default namespaces, that the operating system should query for information about the specified network service. Use one of the following constants to specify a namespace.  ValueMeaning  NS_DEFAULT   A set of default namespaces. The operating system queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for dwNameSpace.   NS_DNS   The Domain Name System used in the Internet for host name resolution.   NS_NETBT   The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to resolve a computer name into an IP address using this registration. Note that NS_NETBT can access a WINS server to perform the resolution.   NS_SAP   The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.   NS_TCPIP_HOSTS   Looks up host names and IP addresses in the <systemroot>\\system32\\drivers\\etc\\hosts file.   NS_TCPIP_LOCAL   Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.     Most calls to  GetService should use the special value NS_DEFAULT. This lets a client get by without knowing available namespaces on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes."
      },
      {
        "in_out": "_In_",
        "type": "PGUID",
        "name": "lpGuid",
        "description": "A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes GUID service types from many well-known services within the DNS and SAP namespaces. The Svcguid.h header file is not automatically included by the Winsock2.h header file."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpServiceName",
        "description": "A pointer to a zero-terminated string that uniquely represents the service name. For example, \"MY SNA SERVER.\""
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwProperties",
        "description": "A set of bit flags that specify the service information that the function retrieves. Each of these bit flag constants, other than PROP_ALL, corresponds to a particular member of the  SERVICE_INFO data structure. If the flag is set, the function puts information into the corresponding member of the data structures stored in *lpBuffer. The following bit flags are defined.  ValueMeaning  PROP_COMMENT   If this flag is set, the function stores data in the lpComment member of the data structures stored in *lpBuffer.   PROP_LOCALE   If this flag is set, the function stores data in the lpLocale member of the data structures stored in *lpBuffer.   PROP_DISPLAY_HINT   If this flag is set, the function stores data in the dwDisplayHint member of the data structures stored in *lpBuffer.   PROP_VERSION   If this flag is set, the function stores data in the dwVersion member of the data structures stored in *lpBuffer.   PROP_START_TIME   If this flag is set, the function stores data in the dwTime member of the data structures stored in *lpBuffer.   PROP_MACHINE   If this flag is set, the function stores data in the lpMachineName member of the data structures stored in *lpBuffer.   PROP_ADDRESSES   If this flag is set, the function stores data in the lpServiceAddress member of the data structures stored in *lpBuffer.   PROP_SD   If this flag is set, the function stores data in the ServiceSpecificInfo member of the data structures stored in *lpBuffer.   PROP_ALL   If this flag is set, the function stores data in all of the members of the data structures stored in *lpBuffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpBuffer",
        "description": "A pointer to a buffer to receive an array of  NS_SERVICE_INFO structures and associated service information. Each  NS_SERVICE_INFO structure contains service information in the context of a particular namespace. Note that if dwNameSpace is NS_DEFAULT, the function stores more than one structure into the buffer; otherwise, just one structure is stored. Each  NS_SERVICE_INFO structure contains a  SERVICE_INFO structure. The members of these  SERVICE_INFO structures will contain valid data based on the bit flags that are set in the dwProperties parameter. If a member's corresponding bit flag is not set in dwProperties, the member's value is undefined. The function stores the  NS_SERVICE_INFO structures in a consecutive array, starting at the beginning of the buffer. The pointers in the contained  SERVICE_INFO structures point to information that is stored in the buffer between the end of the  NS_SERVICE_INFO structures and the end of the buffer."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferSize",
        "description": "A pointer to a variable that, on input, contains the size, in bytes, of the buffer pointed to by lpBuffer. On output, this variable contains the number of bytes required to store the requested information. If this output value is greater than the input value, the function has failed due to insufficient buffer size."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSERVICE_ASYNC_INFO",
        "name": "lpServiceAsyncInfo",
        "description": "Reserved for future use. Must be set to NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  getsockname function retrieves the local name for a socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  getsockname returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getsockname function retrieves the current name for the specified socket descriptor in name. It is used on the bound or connected socket specified by the s parameter. The local association is returned. This call is especially useful when a  connect call has been made without doing a  bind first; the  getsockname function provides the only way to determine the local association that has been set by the system. On call, the namelen parameter contains the size of the name buffer, in bytes. On return, the namelen parameter contains the actual size in bytes of the name parameter. The  getsockname function does not always return information about the host address when the socket has been bound to an unspecified address, unless the socket has been connected with  connect or  accept (for example, using ADDR_ANY). A Windows Sockets application must not assume that the address will be specified unless the socket is connected. The address that will be used for the socket is unknown unless the socket is connected when used in a multihomed host. If the socket is using a connectionless protocol, the address may not be available until I/O occurs on the socket. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "getsockname",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "Descriptor identifying a socket."
      },
      {
        "in_out": "_Out_",
        "type": "struct sockaddr*",
        "name": "name",
        "description": "Pointer to a  SOCKADDR structure that receives the address (name) of the socket."
      },
      {
        "in_out": "_Inout_",
        "type": "int*",
        "name": "namelen",
        "description": "Size of the name buffer, in bytes."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  getsockopt function retrieves a socket option.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  getsockopt returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getsockopt function retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in optval. Options can exist at multiple protocol levels, but they are always present at the uppermost socket level. Options affect socket operations, such as the packet routing and OOB data transfer. The value associated with the selected option is returned in the buffer optval. The integer pointed to by optlen should originally contain the size of this buffer; on return, it will be set to the size of the value returned. For SO_LINGER, this will be the size of a  LINGER structure. For most other options, it will be the size of an integer. The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specified. If the option was never set with  setsockopt, then  getsockopt returns the default value for the option. The following options are supported for  getsockopt. The Type column identifies the type of data addressed by optval. For more information on socket options, see Socket Options. The following table of value for the optname parameter are valid when the level parameter is set to SOL_SOCKET.   The following table of value for the optname parameter are valid when the level parameter is set to IPPROTO_TCP.   The following table of value for the optname parameter are valid when the level parameter is set to NSPROTO_IPX.   The following table lists value for the optname that represent BSD socket options that are not supported by the getsockopt function.   Calling  getsockopt with an unsupported option will result in an error code of  WSAENOPROTOOPT being returned from  WSAGetLastError. More detailed information  on some of the socket options for the optname parameter supported by the getsockopt function are listed below.   The following code sample demonstrates the use of the getsockopt function.  Before an IrDA socket connection can be initiated, a device address must be obtained by performing a  getsockopt(,,IRLMP_ENUMDEVICES,,) function call, which returns a list of all available IrDA devices. A device address returned from the function call is copied into a  SOCKADDR_IRDA structure, which in turn is used by a subsequent call to the  connect function call. Discovery can be performed in two ways: The DEVICELIST structure shown in the Type column in the previous table is an extendible array of device descriptions. IrDA fills in as many device descriptions as can fit in the specified buffer. The device description consists of a device identifier necessary to form a sockaddr_irda structure, and a displayable string describing the device. The IAS_QUERY structure shown in the Type column in the previous table is used to retrieve a single attribute of a single class from a peer device's IAS database. The application specifies the device and class to query and the attribute and attribute type. Note that the device would have been obtained previously by a call to  getsockopt(IRLMP_ENUMDEVICES). It is expected that the application allocates a buffer, of the necessary size, for the returned parameters. Many level socket options are not meaningful to IrDA; only SO_LINGER and SO_DONTLINGER are specifically supported. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "getsockopt",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "level",
        "description": "The level at which the option is defined. Example:  SOL_SOCKET."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "optname",
        "description": "The socket option for which the value is to be retrieved. Example: SO_ACCEPTCONN. The optname value must be a socket option defined within the specified level, or behavior is undefined."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "optval",
        "description": "A pointer to the buffer in which the value for the requested option is to be returned."
      },
      {
        "in_out": "_Inout_",
        "type": "int*",
        "name": "optlen",
        "description": "A pointer to the size, in bytes, of the optval buffer."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  getsourcefilter inline function  retrieves the multicast filter state for an IPv4 or IPv6    socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  getsourcefilter returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  getsourcefilter inline function is used to retrieve the multicast filter state for an IPv4  or IPv6 socket. If the app does not know the size of the source list    beforehand, it can make a guess (zero, for example). If upon    completion, the SourceCount parameter holds a larger value, the operation can be    repeated with a large enough buffer. On return, the SourceCount parameter is always updated to be the total number    of sources in the filter, while the buffer pointed to by the SourceList parameter  will hold as many source    addresses as fit, up to the minimum of the array size passed in as    the original SourceCount value and the total number of sources in the    filter. This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can  use these functions to retrieve and set the multicast source address filters associated with a socket. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "getsourcefilter",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor that identifies a multicast socket."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Interface",
        "description": "The interface index of the multicast interface."
      },
      {
        "in_out": "_In_",
        "type": "const SOCKADDR*",
        "name": "Group",
        "description": "A pointer to the socket address of the multicast group."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "GroupLength",
        "description": "The length, in bytes, of the socket address pointed to by the Group parameter."
      },
      {
        "in_out": "_Out_",
        "type": "MULTICAST_MODE_TYPE*",
        "name": "FilterMode",
        "description": "A pointer to a value to receive the multicast filter mode for the multicast group address when the function returns."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "SourceCount",
        "description": "On input, a pointer to a value that indicates the maximum number of source addresses that will fit in the buffer pointed to by the SourceList parameter. On output, a pointer to a value that indicates the total number of source addresses associated with the multicast filter."
      },
      {
        "in_out": "_Out_",
        "type": "SOCKADDR_STORAGE*",
        "name": "SourceList",
        "description": "A pointer to a buffer to receive the list of IP addresses associated with the multicast filter. If SourceCount is zero on input, a NULL pointer    may be supplied."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  GetTypeByName function retrieves a service type GUID for a network service specified by name.",
    "library": "Mswsock.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Nspapi.h",
    "return_value": "If the function succeeds, the return value is zero. If the function fails, the return value is SOCKET_ERROR( \u00e2\u0080\u0093 1). To get extended error information, call  GetLastError, which returns the following extended error value.  ",
    "remarks": "",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "GetTypeByName",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "lpServiceName",
        "description": "A pointer to a zero-terminated string that uniquely represents the name of the service. For example, \"MY SNA SERVER.\""
      },
      {
        "in_out": "_Inout_",
        "type": "PGUID",
        "name": "lpServiceType",
        "description": "A pointer to a variable to receive a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes definitions of several GUID service types and macros for working with them. The Svcguid.h header file is not automatically included by the Winsock2.h header file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  htond inline function converts a double from host to TCP/IP network byte order (which is big-endian).",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  htond function returns the value in TCP/IP's network byte order. ",
    "remarks": "The  htond inline function takes a double that contains number in host byte order and returns a 64-bit unsigned number in the network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family). The  htond inline function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the value parameter is a valid IPv4 address. The htond \t\t\tinline function does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "unsigned __int64 __inline",
    "category": "Windows Sockets (Winsock)",
    "name": "htond",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "double",
        "name": "value",
        "description": "A double that contains a number in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  htonf inline function converts a float from host to TCP/IP network byte order (which is big-endian).",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  htonf function returns the value in TCP/IP's network byte order. ",
    "remarks": "The  htonf inline function takes a float that contains number in host byte order and returns a 32-bit unsigned number in the network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family). The  htonf inline function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the value parameter is a valid IPv4 address. The htonf \t\t\tinline function does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "unsigned __int32 __inline",
    "category": "Windows Sockets (Winsock)",
    "name": "htonf",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "float",
        "name": "value",
        "description": "A float that contains a number in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  htonl function converts a u_long from host to TCP/IP network byte order (which is big-endian).",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  htonl function returns the value in TCP/IP's network byte order. ",
    "remarks": "The  htonl function takes a 32-bit number in host byte order and returns a 32-bit number in the network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family). The  htonl function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the hostlong parameter is a valid IPv4 address. The htonl \t\t\tfunction does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "u_long WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "htonl",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "u_long",
        "name": "hostlong",
        "description": "A 32-bit number in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  htonll inline function converts an unsigned __int64 from host to TCP/IP network byte order (which is big-endian).",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  htonll function returns the value in TCP/IP's network byte order. ",
    "remarks": "The  htonll inline function takes a 64-bit number in host byte order and returns a 64-bit number in the network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family). The  htonll inline function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the value parameter is a valid IPv4 address. The htonll \t\t\tinline function does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "unsigned __int64 __inline",
    "category": "Windows Sockets (Winsock)",
    "name": "htonll",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "unsigned",
        "type": "__int64",
        "name": "value",
        "description": "A 64-bit unsigned number in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  htons function converts a u_short from host to TCP/IP network byte order (which is big-endian).",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  htons function returns the value in TCP/IP network byte order. ",
    "remarks": "The  htons function takes a 16-bit number in host byte order and returns a 16-bit number in network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family). The  htons function can be used to convert an IP port number in host byte order to the IP port number in network byte order. The htons \t\t\tfunction does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "u_short WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "htons",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "u_short",
        "name": "hostshort",
        "description": "A 16-bit number in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  inet_addr function converts a string containing an IPv4 dotted-decimal address into a proper address for the  IN_ADDR structure.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  the inet_addr function returns an unsigned long value containing a suitable binary representation of the Internet address given. If the string in the cp parameter does not contain a legitimate Internet address, for example if a portion of an \"a.b.c.d\" address exceeds 255, then  inet_addr returns the value INADDR_NONE. On Windows Server 2003    and later if the string in the cp parameter is an empty string, then  inet_addr returns the value INADDR_NONE.  If NULL is passed in the cp parameter, then  inet_addr returns the value INADDR_NONE. On Windows XP   and earlier if the string in the cp parameter is an empty string, then  inet_addr returns the value INADDR_ANY. If NULL is passed in the cp parameter, then  inet_addr returns the value INADDR_NONE. ",
    "remarks": "The  inet_addr function interprets the character string specified by the cp parameter. This string represents a numeric Internet address expressed in the Internet standard \".'' notation. The value returned is a number suitable for use as an Internet address. All Internet addresses are returned in IP's network order (bytes ordered from left to right). If you pass in \" \" (a space) to the  inet_addr function,  inet_addr returns zero. On Windows Vista and later, the RtlIpv4StringToAddress function can be used to convert a string representation of an IPv4 address to a binary IPv4 address represented as an IN_ADDR structure. On Windows Vista and later, the RtlIpv6StringToAddress function can be used to convert a string representation of an IPv6 address to a binary IPv6 address represented as an IN6_ADDR structure. Values specified using the \".'' notation take one of the following forms: a.b.c.d a.b.c a.b a When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the 4 bytes of an Internet address. When an Internet address is viewed as a 32-bit integer quantity on the Intel architecture, the bytes referred to above appear as \"d.c.b.a''. That is, the bytes on an Intel processor are ordered from right to left. The parts that make up an address in \".\" notation can be decimal, octal or hexadecimal as specified in the C language. Numbers that start with \"0x\" or \"0X\" imply hexadecimal. Numbers that start with \"0\" imply octal. All other numbers are interpreted as decimal.  The inet_addr function supports the decimal, octal, hexadecimal, and mixed notations for the string passed in the cp parameter. When a three-part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right-most 2 bytes of the network address. This makes the three-part address format convenient for specifying Class B network addresses as \"128.net.host'' When a two-part address is specified, the last part is interpreted as a 24-bit quantity and placed in the right-most 3 bytes of the network address. This makes the two-part address format convenient for specifying Class A network addresses as \"net.host''. When only one part is given, the value is stored directly in the network address without any byte rearrangement. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. The following code example shows how to use the inet_addr function. ",
    "return_type": "unsigned long",
    "category": "Windows Sockets (Winsock)",
    "name": "inet_addr",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "cp",
        "description": "A NULL-terminated character string representing a number expressed in the Internet standard \".'' (dotted) notation."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  inet_ntoa function converts an (Ipv4) Internet network address into an ASCII string in Internet standard dotted-decimal format.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  inet_ntoa returns a character pointer to a static buffer containing the text address in standard \".'' notation. Otherwise, it returns NULL. ",
    "remarks": "The  inet_ntoa function takes an Internet address structure specified by the in parameter and returns a NULL-terminated ASCII string that represents the address in \".\" (dot) notation as in \"192.168.16.0\", an example of an IPv4 address in dotted-decimal notation.   The string returned by  inet_ntoa resides in memory that is allocated by Windows Sockets. The application should not make any assumptions about the way in which the memory is allocated. The string returned is guaranteed to be valid only until the next Windows Sockets function call is made within the same thread. Therefore, the data should be copied before another Windows Sockets call is made. The  WSAAddressToString function can be used to convert a sockaddr structure containing an IPv4 address to a string representation of an IPv4 address in Internet standard dotted-decimal notation. The advantage of the WSAAddressToString  function is that it supports both IPv4 and IPv6 addresses. Another advantage of the  WSAAddressToString  function is that there are both ASCII and Unicode versions of this function. On Windows Vista and later, the RtlIpv4AddressToString function can be used to convert an IPv4 address represented as an IN_ADDR structure to a string representation of an IPv4 address in Internet standard dotted-decimal notation. On Windows Vista and later, the RtlIpv6AddressToString function can be used to convert an IPv6 address represented as an IN6_ADDR structure to a string representation of an IPv6 address. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "char* FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "inet_ntoa",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "struct in_addr",
        "name": "in",
        "description": "An  in_addr structure that represents an Internet host address."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  InetNtop function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The ANSI version of this function is   inet_ntop.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "If no error occurs,  InetNtop function returns a pointer to a buffer containing the string representation of IP address in standard format. Otherwise, a value of NULL is returned, and a specific error code can be retrieved by calling the   WSAGetLastError for extended error information. If the function fails, the extended error code returned by WSAGetLastError can be one of the following values.  ",
    "remarks": "The  InetNtop function is supported on Windows Vista   and later. The  InetNtop function provides a protocol-independent address-to-string translation. The  InetNtop function takes an Internet address structure specified by the pAddr parameter and returns a NULL-terminated string that represents the IP address. While the inet_ntoa function works only with IPv4 addresses, the InetNtop function works with either IPv4 or IPv6 addresses. The ANSI version of this function is inet_ntop as defined in RFC 2553. For more information, see RFC 2553 available at the IETF website. The  InetNtop function does not require that the Windows Sockets DLL be loaded to perform IP address to string conversion. If the Family parameter specified is AF_INET, then the pAddr parameter must point to an IN_ADDR structure with the IPv4 address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is  in dotted-decimal notation as in \"192.168.16.0\", an example of an IPv4 address in dotted-decimal notation. If the Family parameter specified is AF_INET6, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6 address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address. If the length of the buffer pointed to by the pStringBuf parameter is not large enough to receive the string representation of the IP address, InetNtop returns ERROR_INVALID_PARAMETER. When UNICODE or _UNICODE is defined, InetNtop is defined to InetNtopW, the Unicode version of this function. The pStringBuf parameter is defined to the PSTR data type. When UNICODE or _UNICODE is not defined, InetNtop is defined to InetNtopA, the ANSI version of this function. The ANSI version of this function is always defined as inet_ntop. The pStringBuf parameter is defined to the PWSTR data type. The IN_ADDR structure is defined in the Inaddr.h header file.  The IN6_ADDR structure is defined in the In6addr.h header file. On Windows Vista and later, the RtlIpv4AddressToString and RtlIpv4AddressToStringEx functions can be used to convert an IPv4 address represented as an IN_ADDR structure to a string representation of an IPv4 address in Internet standard dotted-decimal notation. On Windows Vista and later, the RtlIpv6AddressToString and RtlIpv6AddressToStringEx functions can be used to convert an IPv6 address represented as an IN6_ADDR structure to a string representation of an IPv6 address. The RtlIpv6AddressToStringEx function is more flexible since it also converts an IPv6 address, scope ID, and port to a IPv6 string in standard format. Windows 8.1 and Windows Server 2012 R2: The  InetNtopW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "PCTSTR WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "InetNtop",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "Family",
        "description": "The address family. Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. The values currently supported are AF_INET and AF_INET6.  ValueMeaning  AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns an IPv4 address string.   AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns an IPv6 address string."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "pAddr",
        "description": "A pointer to the IP address in network byte to convert to a string. When the Family parameter is AF_INET, then the pAddr parameter must point to an IN_ADDR structure with the IPv4 address to convert. When the Family parameter is AF_INET6, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6 address to convert."
      },
      {
        "in_out": "_Out_",
        "type": "PTSTR",
        "name": "pStringBuf",
        "description": "A pointer to a buffer in which to store the NULL-terminated string representation of the IP address. For an IPv4 address, this buffer should be large enough to hold at least 16 characters. For an IPv6 address, this buffer should be large enough to hold at least 46 characters."
      },
      {
        "in_out": "_In_",
        "type": "size_t",
        "name": "StringBufSize",
        "description": "On input, the length, in characters, of the buffer pointed to by the pStringBuf parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  InetPton function converts an IPv4 or IPv6 Internet network address in its standard text   presentation form into its numeric binary form. The ANSI version of this function is   inet_pton.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "If no error occurs,  the InetPton function returns a value of 1 and the buffer pointed to by the pAddrBuf parameter contains the binary numeric IP address in network byte order. The InetPton function returns a value of 0 if the pAddrBuf parameter points to a string that is not a valid IPv4 dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error code can be retrieved by calling the   WSAGetLastError for extended error information. If the function has an error, the extended error code returned by WSAGetLastError can be one of the following values.  ",
    "remarks": "The  InetPton function is supported on Windows Vista   and later. The  InetPton function provides a protocol-independent conversion of an Internet network address in its standard text   presentation form into its numeric binary form. The  InetPton function takes a text representation of an Internet address pointed to  by the pszAddrString parameter and returns a pointer to the numeric binary IP address in the pAddrBuf parameter. While the inet_addr \t\t function works only with IPv4 address strings, the InetPton function works with either IPv4 or IPv6 address strings. The ANSI version of this function is inet_pton as defined in RFC 2553. For more information, see RFC 2553 available at the IETF website. The  InetPton function does not require that the Windows Sockets DLL be loaded to perform conversion of a text string that represents an IP address to a numeric binary IP address. If the Family parameter specified is AF_INET, then the pszAddrString parameter must point a text string of an IPv4 address  in dotted-decimal notation as in \"192.168.16.0\", an example of an IPv4 address in dotted-decimal notation. If the Family parameter specified is AF_INET6, then the pszAddrString parameter must point a text string of an IPv6 address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address. When UNICODE or _UNICODE is defined, InetPton is defined to InetPtonW, the Unicode version of this function. The pszAddrString parameter is defined to the PCWSTR data type. When UNICODE or _UNICODE is not defined, InetPton is defined to InetPtonA, the ANSI version of this function. The ANSI version of this function is always defined as inet_pton. The pszAddrString parameter is defined to the PCSTR data type. The IN_ADDR structure is defined in the Inaddr.h header file.  The IN6_ADDR structure is defined in the In6addr.h header file. On Windows Vista and later, the RtlIpv4StringToAddress and RtlIpv4StringToAddressEx functions can be used to convert a text representation of an IPv4 address in Internet standard dotted-decimal notation to a numeric binary address represented as an  IN_ADDR structure. On Windows Vista and later, the RtlIpv6StringToAddress and RtlIpv6StringToAddressEx functions can be used to convert a string representation of an IPv6 address to a numeric binary IPv6 address represented as an IN6_ADDR structure. The RtlIpv6StringToAddressEx function is more flexible since it also converts a string representation of an IPv6 address that can include a scope ID and port in standard notation to a numeric binary form. Windows 8.1 and Windows Server 2012 R2: The  InetPtonW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "InetPton",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "Family",
        "description": "The address family.  Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. The values currently supported are AF_INET and AF_INET6.  ValueMeaning  AF_INET 2   The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  the pszAddrString parameter must point to a text representation of an IPv4 address and the pAddrBuf parameter  returns a pointer to an IN_ADDR structure that represents the IPv4 address.    AF_INET6 23   The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  the pszAddrString parameter must point to a text representation of an IPv6 address and the pAddrBuf parameter  returns a pointer to an  IN6_ADDR structure that represents the IPv6 address."
      },
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pszAddrString",
        "description": "A pointer to the NULL-terminated string that contains the text representation of the IP address to convert to numeric binary form. When the Family parameter is AF_INET, then the pszAddrString parameter must point to a text representation of an IPv4 address in standard dotted-decimal notation. When the Family parameter is AF_INET6, then the pszAddrString parameter must point to a text representation of an IPv6 address in standard notation."
      },
      {
        "in_out": "_Out_",
        "type": "PVOID",
        "name": "pAddrBuf",
        "description": "A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in network byte order. When the Family parameter is AF_INET, this buffer should be large enough to hold an IN_ADDR structure. When the Family parameter is AF_INET6,  this buffer should be large enough to hold an IN6_ADDR structure."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  ioctlsocket function controls the I/O mode of a socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "Upon successful completion, the  ioctlsocket returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  ioctlsocket function can be used on any socket in any state. It is used to set or retrieve some operating parameters associated with the socket, independent of the protocol and communications subsystem. Here are the supported commands to use in the cmd parameter and their semantics:  The WSAIoctl  \t function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem.  The WSAIoctl  \t function is more powerful than the ioctlsocket function and supports a large number of possible values for the operating parameters to set or retrieve. The following example demonstrates the use of the ioctlsocket function. This  ioctlsocket function performs only a subset of functions on a socket when compared to the ioctl function found in Berkeley sockets. The  ioctlsocket function has no command parameter equivalent to the FIOASYNC of ioctl, and SIOCATMARK is the only socket-level command that is supported by  ioctlsocket. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "ioctlsocket",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "long",
        "name": "cmd",
        "description": "A command to perform on the socket s."
      },
      {
        "in_out": "_Inout_",
        "type": "u_long*",
        "name": "argp",
        "description": "A pointer to a parameter for cmd."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  listen function places a socket in a state in which it is listening for an incoming connection.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  listen returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "To accept connections, a socket is first created with the  socket function and bound to a local address with the  bind function. A backlog for incoming connections is specified with  listen, and then the connections are accepted with the  accept function. Sockets that are connection oriented, those of type SOCK_STREAM for example, are used with  listen. The socket s is put into passive mode where incoming connection requests are acknowledged and queued pending acceptance by the process. A value for the backlog of SOMAXCONN is a special constant that  instructs the underlying service provider responsible for socket s to set the length of the queue of pending connections to a maximum reasonable value. On Windows Sockets 2, this maximum value defaults to a large value (typically several hundred or more).    When calling the listen function in a Bluetooth application, it is strongly recommended that a much lower value be used for the backlog parameter (typically 2 to 4), since only a few client connections are accepted. This reduces the system resources that are allocated for use by the listening socket. This same recommendation applies to other network applications that expect only a few client connections. The  listen function is typically used by servers that can have more than one connection request at a time. If a connection request arrives and the queue is full, the client will receive an error with an indication of  WSAECONNREFUSED. If there are no available socket descriptors,  listen attempts to continue to function. If descriptors become available, a later call to  listen or  accept will refill the queue to the current or most recent value specified for the  backlog parameter, if possible, and resume listening for incoming connections. If the listen function is called on an already listening socket, it will return success without changing the value for the backlog parameter.  Setting the backlog parameter to 0 in a subsequent call to listen on a listening socket is not considered a proper reset, especially if there are connections on the socket. The following example demonstrates the use of the listen function. For another example that uses the listen function, see Getting Started With Winsock. The backlog parameter is limited (silently) to a reasonable value as determined by the underlying service provider. Illegal values are replaced by the nearest legal value. There is no standard provision to find out the actual backlog value. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "listen",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a bound, unconnected socket."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "backlog",
        "description": "The maximum length of the queue of pending connections. If set to SOMAXCONN, the underlying service provider responsible for socket s will set the backlog to a maximum reasonable value. If set to SOMAXCONN_HINT(N) (where N is a number), the backlog value will be N, adjusted to be within the range (200, 65535). Note that SOMAXCONN_HINT can be used to set the backlog to a larger value than possible with SOMAXCONN. SOMAXCONN_HINT is only supported by the Microsoft TCP/IP service provider. There is no standard provision to obtain the actual backlog value."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  ntohd inline function converts an unsigned __int64 from TCP/IP network order to host byte order (which is little-endian on Intel processors) and returns a  double.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  ntohd function returns the value supplied in the value parameter with the byte order reversed. If  value is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed. ",
    "remarks": "The  ntohd inline function takes an unsigned __int64 that contains number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a double  that contains a number in host byte order. The  ntohd function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the value parameter is a valid IPv4 address. The ntohd \t\t\tfunction does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "double __inline",
    "category": "Windows Sockets (Winsock)",
    "name": "ntohd",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "unsigned",
        "type": "__int64",
        "name": "value",
        "description": "An unsigned __int64 number in TCP/IP network byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  ntohf inline function converts an unsigned __int32 from TCP/IP network order to host byte order (which is little-endian on Intel processors) and returns a float.",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  ntohf function returns the value supplied in the value parameter with the byte order reversed. If  value is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed. ",
    "remarks": "The  ntohf inline function takes an unsigned __int32 in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a float that contains a number in host byte order. The  ntohf function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the value parameter is a valid IPv4 address. The ntohf \t\t\tfunction does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "float __inline",
    "category": "Windows Sockets (Winsock)",
    "name": "ntohf",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "unsigned",
        "type": "__int32",
        "name": "value",
        "description": "An  unsigned __int32 number in TCP/IP network byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  ntohl function converts a u_long from TCP/IP network order to host byte order (which is little-endian on Intel processors).",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  ntohl function returns the value supplied in the netlong parameter with the byte order reversed. If  netlong is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed. ",
    "remarks": "The  ntohl function takes a 32-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a 32-bit number in host byte order. The  ntohl function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the netlong parameter is a valid IPv4 address. The ntohl \t\t\tfunction does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "u_long WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "ntohl",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "u_long",
        "name": "netlong",
        "description": "A 32-bit number in TCP/IP network byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  ntohll inline function converts an  unsigned __int64 from TCP/IP network order to host byte order (which is little-endian on Intel processors).",
    "library": "",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  ntohll function returns the value supplied in the value parameter with the byte order reversed. If  value is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed. ",
    "remarks": "The  ntohll inline function takes an unsigned __int64 number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a 32-bit number in host byte order. The  ntohll function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the value parameter is a valid IPv4 address. The ntohll \t\t\tfunction does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "u_long __inline",
    "category": "Windows Sockets (Winsock)",
    "name": "ntohll",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "unsigned",
        "type": "__int64",
        "name": "value",
        "description": "An unsigned __int64 number in TCP/IP network byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  ntohs function converts a u_short from TCP/IP network byte order to host byte order (which is little-endian on Intel processors).",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  ntohs function returns the value in host byte order. If the netshort parameter is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed. ",
    "remarks": "The  ntohs function takes a 16-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a 16-bit number in host byte order. The  ntohs function can be used to convert an IP port number in network byte order to the IP port number in host byte order. The ntohs \t\t\tfunction does not require that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "u_short WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "ntohs",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "u_short",
        "name": "netshort",
        "description": "A 16-bit number in TCP/IP network byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  recv function receives data from a connected socket or a bound connectionless socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  recv returns the number of bytes received and the buffer pointed to by the buf parameter will contain this data received. If the connection has been gracefully closed, the return value is zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  recv function is used to read incoming data on connection-oriented sockets, or connectionless sockets. When using a connection-oriented protocol, the sockets must be connected before calling  recv. When using a connectionless protocol, the sockets must be bound before calling  recv. The local address of the socket must be known. For server applications, use an explicit  bind function or an implicit  accept or  WSAAccept function. Explicit binding is discouraged for client applications. For client applications, the socket can become bound implicitly to a local address using  connect,  WSAConnect,  sendto,  WSASendTo, or  WSAJoinLeaf. For connected or connectionless sockets, the  recv function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded. For connection-oriented sockets (type SOCK_STREAM for example), calling  recv will return as much data as is currently available\u00e2\u0080\u0094up to the size of the buffer specified. If the socket has been configured for in-line reception of OOB data (socket option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the  ioctlsocket or  WSAIoctlSIOCATMARK command to determine whether any more OOB data remains to be read. For connectionless sockets (type SOCK_DGRAM or other message-oriented sockets), data is extracted from the first enqueued datagram (message) from the destination address specified by the  connect function. If the datagram or message is larger than the buffer specified, the buffer is filled with the first part of the datagram, and  recv generates the error  WSAEMSGSIZE. For unreliable protocols (for example, UDP) the excess data is lost; for reliable protocols, the data is retained by the service provider until it is successfully read by calling  recv with a large enough buffer. If no incoming data is available at the socket, the  recv call blocks and waits for data to arrive according to the blocking rules defined for  WSARecv with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value of SOCKET_ERROR is returned with the error code set to  WSAEWOULDBLOCK. The  select,  WSAAsyncSelect, or  WSAEventSelect functions can be used to determine when more data arrives. If the socket is connection oriented and the remote side has shut down the connection gracefully, and all data has been received, a  recv will complete immediately with zero bytes received. If the connection has been reset, a  recv will fail with the error  WSAECONNRESET. The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the flags parameter. The possible value of flags parameter is constructed by using the bitwise OR operator with any of the following values.  The following code example shows the use of the recv function. For more information, and another example of the recv function, see Getting Started With Winsock. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "recv",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "The descriptor that identifies a connected socket."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "A pointer to the buffer to receive the incoming data."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "len",
        "description": "The length, in bytes, of the buffer pointed to by the buf parameter."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "flags",
        "description": "A set of flags that influences the behavior of this function. See remarks below. See the Remarks section for details on the possible value for this parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "The  recvfrom function receives a datagram and stores the source address.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  recvfrom returns the number of bytes received. If the connection has been gracefully closed, the return value is zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  recvfrom function reads incoming data on both connected and unconnected sockets and captures the address from which the data was sent. This function is typically used with connectionless sockets. The local address of the socket must be known. For server applications, this is usually done explicitly through  bind. Explicit binding is discouraged for client applications. For client applications using this function, the socket can become bound implicitly to a local address through  sendto,  WSASendTo, or  WSAJoinLeaf. For stream-oriented sockets such as those of type SOCK_STREAM, a call to  recvfrom returns as much information as is currently available\u00e2\u0080\u0094up to the size of the buffer specified. If the socket has been configured for inline reception of OOB data (socket option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the  ioctlsocket or  WSAIoctlSIOCATMARK command to determine whether any more OOB data remains to be read. The from and fromlen parameters are ignored for connection-oriented sockets. For message-oriented sockets, data is extracted from the first enqueued message, up to the size of the buffer specified. If the datagram or message is larger than the buffer specified, the buffer is filled with the first part of the datagram, and  recvfrom generates the error  WSAEMSGSIZE. For unreliable protocols (for example, UDP) the excess data is lost. For UDP if the packet received contains no data (empty), the return value from the recvfrom function function is zero. If the from parameter is nonzero and the socket is not connection oriented, (type SOCK_DGRAM for example), the network address of the peer that sent the data is copied to the corresponding  sockaddr structure. The value pointed to by fromlen is initialized to the size of this structure and is modified, on return, to indicate the actual size of the address stored in the sockaddr structure. If no incoming data is available at the socket, the  recvfrom function blocks and waits for data to arrive according to the blocking rules defined for  WSARecv with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value of SOCKET_ERROR is returned with the error code set to  WSAEWOULDBLOCK. The  select,  WSAAsyncSelect, or  WSAEventSelect can be used to determine when more data arrives. If the socket is connection oriented and the remote side has shut down the connection gracefully, the call to  recvfrom will complete immediately with zero bytes received. If the connection has been reset  recvfrom will fail with the error  WSAECONNRESET. The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the flags parameter. The latter is constructed by using the bitwise OR operator with any of the following values.  The following example demonstrates the use of the recvfrom function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "recvfrom",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a bound socket."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "A buffer for the incoming data."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "len",
        "description": "The length, in bytes, of the buffer pointed to by the buf parameter."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "flags",
        "description": "A set of options that modify the behavior of the function call beyond the options specified for the associated socket. See the Remarks below for more details."
      },
      {
        "in_out": "_Out_",
        "type": "struct sockaddr*",
        "name": "from",
        "description": "An optional pointer to a buffer in a  sockaddr structure that will hold the source address upon return."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "int*",
        "name": "fromlen",
        "description": "An optional pointer to the size, in bytes, of the buffer pointed to by the from parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The RIOCloseCompletionQueue function closes an existing completion queue used for I/O completion notification by send and receive requests with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The RIOCloseCompletionQueue function closes an existing completion queue used for I/O completion. The RIO_CQ passed in the CQ parameter is locked for writing by the kernel. The completion queue is marked as invalid, so that new completions cannot be added.   Any new completions to be added are silently dropped. The application is expected to tracking any pending send or receive operations. If an invalid completion queue is passed in the CQ parameter (RIO_INVALID_CQ, for example), this is ignored by the RIOCloseCompletionQueue function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "VOID",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOCloseCompletionQueue",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_CQ",
        "name": "CQ",
        "description": "A descriptor identifying an existing completion queue."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The RIOCreateCompletionQueue function creates an I/O completion queue of a specific size for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOCreateCompletionQueue function returns a descriptor referencing a new completion queue. Otherwise, a value of RIO_INVALID_CQ is returned, and a specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "The RIOCreateCompletionQueue function creates an I/O completion queue of a specific size. The size of the completion queue restricts the set of registered I/O sockets that can be associated with the completion queue.  For more information, see the RIOCreateRequestQueue function. When creating a RIO_CQ, the RIO_NOTIFICATION_COMPLETION structure pointed to by the NotificationCompletion parameter determines how the application will receive completion queue notifications.  If a RIO_NOTIFICATION_COMPLETION structure is provided when creating the completion queue, the application may call the RIONotify function to request a completion queue notification.  Normally this notification occurs when the completion queue is not empty.  This may happen immediately or when the next completion entry is inserted into the completion queue.  However, send and receive requests may be flagged as RIO_MSG_DONT_NOTIFY.  Completion queue notification and will never be triggered as a result of such requests.  If the completion queue contains only entries with the RIO_MSG_DONT_NOTIFY flag set, the completion queue notification will not be triggered.  Also, when a new entry enters the completion queue, the completion queue notification is only triggered if the RIO_MSG_DONT_NOTIFY flag was not set on the associated request.  Any completed requests can still be retrieved by polling using the RIODequeueCompletion function. Once a completion queue notification is issued, the application must call the RIONotify function in order to receive another completion queue notification. When a completion queue notification occurs, the application typically calls the RIODequeueCompletion function to dequeue the completed send or receive requests. Two options are available for completion queue notification. If the Type member of the RIO_NOTIFICATION_COMPLETION structure is set to RIO_EVENT_COMPLETION, an event handle is used to signal completion queue notifications. An event handle is provided as the EventNotify.EventHandle member in the RIO_NOTIFICATION_COMPLETION structure passed to the RIOCreateCompletionQueue function. The Event.EventHandle member should contain the handle for an event created by the WSACreateEvent or CreateEvent function.  To receive the RIONotify completion, the application should wait on the specified event handle using WSAWaitForMultipleEvents or a similar wait routine.  The completion of the RIONotify function for this RIO_CQ will signal the event.  The  Event.NotifyReset member in the RIO_NOTIFICATION_COMPLETION structure passed to the RIOCreateCompletionQueue function indicates whether or not the event should be reset as part of a call to the RIONotify function. If the application plans to reset and reuse the event, the application can reduce overhead by setting the Event.NotifyReset member to a non-zero value. This causes the event to be automatically reset by the RIONotify function when the notification occurs. This mitigates the need to call the WSAResetEvent function to reset the event between calls to the RIONotify function. If the Type member of the RIO_NOTIFICATION_COMPLETION structure is set to RIO_IOCP_COMPLETION,  an I/O completion port is used to signal completion queue notifications. An I/O completion port handle is provided as the Iocp.IocpHandle member in the RIO_NOTIFICATION_COMPLETION structure passed to the RIOCreateCompletionQueue function. The completion of the RIONotify function for this RIO_CQ will queue an entry to the I/O completion port which can be retrieved using the GetQueuedCompletionStatus or GetQueuedCompletionStatusEx function.  A queued entry will have the returned lpCompletionKey parameter value set to the value specified in Iocp.CompletionKey member of the RIO_NOTIFICATION_COMPLETION structure  and the Iocp.Overlapped member in the RIO_NOTIFICATION_COMPLETION structure will be a non-NULL value. In terms of its usage, completion queue notification is designed to wake up a waiting application thread so that the thread can examine the completion queue.  Waking and scheduling a thread comes at a cost, so if this happens too frequently it will have a negative impact on the application performance.  The RIO_MSG_DONT_NOTIFY flag is provided so that the application can control the frequency of these events and limit their over impact on performance. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "RIO_CQ",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOCreateCompletionQueue",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "QueueSize",
        "description": "The size, in number of entries, of the completion queue to create."
      },
      {
        "in_out": "_In_opt_",
        "type": "RIO_NOTIFICATION_COMPLETION",
        "name": "NotificationCompletion",
        "description": "The type of notification completion to use based on the Type member of the RIO_NOTIFICATION_COMPLETION structure (I/O completion or event notification). If the Type member is set to RIO_EVENT_COMPLETION, then the Event member of the RIO_NOTIFICATION_COMPLETION structure must be set. If the Type member is set to RIO_IOCP_COMPLETION, then the Iocp member of the RIO_NOTIFICATION_COMPLETION structure must be set and the Iocp.Overlapped member of the RIO_NOTIFICATION_COMPLETION structure must not be NULL. If the NotificationCompletion parameter is NULL, this specifies no notification completion is used and that polling must be used to determine completion."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "The RIOCreateRequestQueue function creates a registered I/O socket descriptor using a specified socket and I/O completion queues for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOCreateRequestQueue function returns a descriptor referencing a new request queue. Otherwise, a value of RIO_INVALID_RQ is returned, and a specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "The RIOCreateRequestQueue function creates a registered I/O socket descriptor using a specified socket and I/O completion queues. An application must call RIOCreateRequestQueue to obtain a RIO_RQ for a Winsock socket before the application can use the RIOSend, RIOSendEx, RIOReceive, or RIOReceiveEx functions.  In order to obtain a RIO_RQ, the Winsock socket must be associated with completion queues for send and receive, although the same completion queue can be used for both. Due to the finite size of completion queues, a socket may only be associated with a completion queue for send and receive operations if it guarantees not to exceed the capacity for total queued completions.  Therefore, socket specific limits are established by the call to the RIOCreateRequestQueue function.  These limits are used both during the RIOCreateRequestQueue call to verify sufficient space in the completion queues to accommodate the socket requests and during request initiation time to make sure that the request does not cause the socket to exceed its limits. The send and receive queues can be associated with multiple sockets. The sizes of the send and receive queues must be greater than or equal to the send and receive sizes of all attached sockets.  As request queues are closed by closing the sockets using the the closesocket function, those slots will be freed up for use by other sockets. When an application is finished using the RIO_RQ, the application should call the closesocket function to close the socket and free the associated resources. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "RIO_RQ",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOCreateRequestQueue",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor that identifies the socket."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaxOutstandingReceive",
        "description": "The maximum number of outstanding receives allowed on the socket.  This parameter is usually a small number for most applications."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaxReceiveDataBuffers",
        "description": "The maximum number of receive data buffers on the socket.  Note  For Windows 8 and Windows Server 2012 , this parameter must be 1."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaxOutstandingSend",
        "description": "The maximum number of outstanding sends allowed on the socket."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "MaxSendDataBuffers",
        "description": "The maximum number of send data buffers on the socket.  Note  For Windows 8 and Windows Server 2012 , this parameter must be 1."
      },
      {
        "in_out": "_In_",
        "type": "RIO_CQ",
        "name": "ReceiveCQ",
        "description": "A descriptor that identifies the I/O completion queue to use for receive request completions."
      },
      {
        "in_out": "_In_",
        "type": "RIO_CQ",
        "name": "SendCQ",
        "description": "A descriptor that identifies the I/O completion queue to use for send request completions. This parameter may have the same value as the ReceiveCQ parameter."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "SocketContext",
        "description": "The socket context to associate with this request queue."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The RIODequeueCompletion function removes entries from an  I/O completion queue for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIODequeueCompletion function returns the number of completion entries removed from the specified completion queue. Otherwise, a value of RIO_CORRUPT_CQ is returned to indicate that the state of the RIO_CQ passed in the  CQ parameter has become corrupt due to memory corruption or misuse of the RIO functions. ",
    "remarks": "The RIODequeueCompletion function removes entries from an I/O completion queue for send and receive requests with the Winsock registered I/O extensions. The RIODequeueCompletion function is the mechanism by which an application can find out about completed send and receive requests.  An application normally calls the RIODequeueCompletion function after receiving notification based on the method registered with the RIONotify function when the completion queue is not empty. The notification behavior for an I/O completion queue is set when the RIO_CQ is created. The RIO_NOTIFICATION_COMPLETION structure that determines the notification behavior is passed to the RIOCreateCompletionQueue function when a  RIO_CQ is created. When the RIODequeueCompletion function completes, the Array parameter contains an array of pointers to RIORESULT structures for the completed send and receive requests that were dequeued. The members of the    returned RIORESULT structures provide information on the completion status of the completed request and the number of bytes that were transferred. Each returned RIORESULT structure also includes a socket context and an application context that can be used to identify the specific completed request. If the I/O completion queue passed in the CQ parameter is not valid or damaged, the RIODequeueCompletion function returns a count of RIO_CORRUPT_CQ. The RIODequeueCompletion function returns a value of zero is returned if there are no completed send or receive requests to be dequeued. Only after a request's completion has been dequeued does the system release the association to its buffer and buffer registration, along with its quota charge. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. If multiple threads attempt to  access the same RIO_CQ using the RIODequeueCompletion function, access must be coordinated by a critical section, slim reader writer lock , or similar mutual exclusion mechanism. If the completion queues are not shared, mutual exclusion is not required. ",
    "return_type": "ULONG",
    "category": "Windows Sockets (Winsock)",
    "name": "RIODequeueCompletion",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_CQ",
        "name": "CQ",
        "description": "A descriptor that identifies an I/O completion queue."
      },
      {
        "in_out": "_Out_",
        "type": "PRIORESULT",
        "name": "Array",
        "description": "An array of  RIORESULT structures to receive the description of the completions dequeued."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "ArraySize",
        "description": "The maximum number of entries in the Array to write."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The RIODeregisterBuffer function deregisters a registered buffer used with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "This function does not return a value. ",
    "remarks": "The RIODeregisterBuffer function deregisters a registered buffer. When a buffer is deregistered, the application is indicating that it is done with the buffer identifier passed in the BufferId parameter. Any subsequent calls to other functions that try to use this buffer identifier will fail. If a buffer that is still in use is deregistered, the results are undefined. This is considered a serious error. In the RIORESULT structure returned by the RIODequeueCompletion function, the status will be unchanged from the normal status.  An application developer  can detect this error condition using the Application Verifier tool. If an invalid buffer identifier is passed in the BufferId parameter, this is ignored by the RIODeregisterBuffer function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "VOID",
    "category": "Windows Sockets (Winsock)",
    "name": "RIODeregisterBuffer",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_BUFFERID",
        "name": "BufferId",
        "description": "A descriptor identifying a registered buffer."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The RIONotify function registers the method to use for notification behavior with an I/O completion queue for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIONotify function returns ERROR_SUCCESS. Otherwise, the function failed and a specific error code is returned.  ",
    "remarks": "The RIONotify function registers the method to be used for notification behavior for sending or receiving network data with the Winsock registered I/O extensions. The RIONotify function is the mechanism by which an application finds out that requests are completed and are awaiting a call to the RIODequeueCompletion function.  The RIONotify function sets the method to be used for notification behavior when an I/O completion queue is not empty and contains the completion of  a result. The notification behavior for a completion queue is set when the RIO_CQ is created. The RIO_NOTIFICATION_COMPLETION structure is passed to the RIOCreateCompletionQueue function when a  RIO_CQ is created. For a completion queue that uses an event, the Type member of the RIO_NOTIFICATION_COMPLETION structure is set to RIO_EVENT_COMPLETION. The Event.EventHandle member should contain the handle for an event created by the WSACreateEvent or CreateEvent function.  To receive the RIONotify completion, the application should wait on the specified event handle using WSAWaitForMultipleEvents or a similar wait routine.  If the application plans to reset and reuse the event, the application can reduce overhead by setting the Event.NotifyReset member to a non-zero value. This causes the event to be automatically reset by the RIONotify function when the notification occurs. This mitigates the need to call the WSAResetEvent function to reset the event between calls to the RIONotify function. When the RIONotify function is called used event completion and the specified completion queue is already not empty, the event is set either synchronously or asynchronously.  In both cases, additional entries do not need to enter the completion queue before the event is set. Until the completion queue contains the completion of a request that did not have the RIO_MSG_DONT_NOTIFY flag set, the completion queue is considered empty for the purposes of the RIONotify function and the event is not set. Any completed requests can still be retrieved using the RIODequeueCompletion function. When the event is set, the application typically calls the RIODequeueCompletion function to dequeue the completed send and receive requests. For a completion queue that  uses an I/O completion port, the Type member of the RIO_NOTIFICATION_COMPLETION structure is set to RIO_IOCP_COMPLETION. The Iocp.IocpHandle member should contain the handle for an I/O completion port created by the CreateIoCompletionPort function.  To receive the RIONotify completion, the application should call the GetQueuedCompletionStatus or GetQueuedCompletionStatusEx function.  The application should provide a dedicated OVERLAPPED object for the completion queue, and it may also use the Iocp.CompletionKey member to distinguish RIONotify requests on the completion queue from other I/O completions including RIONotify completions for other completion queues. An application using thread pools can use thread pool wait objects to get RIONotify completions via its thread pool.  In that case, the call to the SetThreadpoolWait function should immediately follow the call to RIONotify.  If the SetThreadpoolWait function is called before RIONotify and the application relies on RIONotify to clear the event object, this may result in spurious executions of the wait object callback. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. If multiple threads attempt to  access the same RIO_CQ using the RIODequeueCompletion function, access must be coordinated by a critical section, slim reader writer lock , or similar mutual exclusion mechanism. If the completion queues are not shared, mutual exclusion is not required. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "RIONotify",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_CQ",
        "name": "CQ",
        "description": "A descriptor that identifies an I/O completion queue."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The RIOReceive function receives network data on a connected registered I/O TCP socket or a bound registered I/O UDP socket for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOReceive function returns TRUE. In this case,  the receive operation is successfully initiated and the completion will have already been queued or the operation has been successfully initiated and the completion will be queued at a later time. A value of FALSE indicates  the function failed, the operation was not successfully initiated and no completion indication will be queued. A specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "An application can use the RIOReceive  function to receive network data into any buffer completely contained within a single registered buffer.  The Offset and Length members of the RIO_BUF structure pointed to by the pData parameter determine where the network data is received in the buffer. Once the RIOReceive function is called, the buffer passed in the pData parameter including the RIO_BUFFERID in the  BufferId member of RIO_BUF structure must remain valid for the duration of the receive operation. In order to avoid race conditions, a buffer associated with a receive request should not be read or written before the request completes.  This includes using the buffer as the source for a send request or the destination for another receive request.  Portions of a registered buffer not associated with any receive request are not included in this restriction. The Flags parameter can be used to influence the behavior of the RIOReceive function invocation beyond the options specified for the associated socket.  The behavior of this function is determined by a combination of any socket options set on the socket associated with the SocketQueue parameter and the values specified in the Flags parameter. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOReceive",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_RQ",
        "name": "SocketQueue",
        "description": "A descriptor that identifies a connected registered I/O TCP socket or a bound registered I/O UDP socket."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pData",
        "description": "A description of the portion of the registered buffer in which to receive data. This parameter may be NULL for a bound registered I/O UDP socket if the application does not need to receive the data payload in  the UDP datagram."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DataBufferCount",
        "description": "A data buffer count parameter that indicates if data is to be received in the buffer pointed to by the pData parameter. This parameter should be set to zero if the pData is NULL. Otherwise, this parameter should be set to 1."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "A set of flags that modify the behavior of the RIOReceive function.  The Flags parameter can contain a combination of the following options defined in the Mswsockdef.h header file:     FlagMeaning  RIO_MSG_COMMIT_ONLY   Previous  requests added with RIO_MSG_DEFER flag will be committed.  When the RIO_MSG_COMMIT_ONLY flag is set, no other flags may be specified. When the RIO_MSG_COMMIT_ONLY flag is set, the pData and RequestContext parameters must be NULL and the DataBufferCount parameter must be zero.  This flag would normally be used occasionally after a number of requests were issued with the RIO_MSG_DEFER flag set. This eliminates the need when using the RIO_MSG_DEFER flag to make the  last request without the  RIO_MSG_DEFER flag, which causes the last request to complete much slower than other requests.  Unlike other calls to the RIOReceive function, when the RIO_MSG_COMMIT_ONLY flag is set calls to the RIOReceive function do not need to be serialized.  For a single RIO_RQ, the RIOReceive function can be called with  RIO_MSG_COMMIT_ONLY on one thread while calling the RIOReceive function on another thread.   RIO_MSG_DONT_NOTIFY   The request should not trigger the RIONotify function when request completion is inserted into its completion queue.   RIO_MSG_DEFER   The request does not need to be executed immediately.  This will insert the request into the request queue, but it may or may not trigger the execution of the request.   Data reception may be delayed until a receive request is made on the RIO_RQ passed in the SocketQueue parameter without the RIO_MSG_DEFER flag set. To trigger execution for all receives in a request queue, call the RIOReceive or RIOReceiveEx function without the RIO_MSG_DEFER flag set.   Note  The receive request is charged against the outstanding I/O capacity on the RIO_RQ passed in the SocketQueue parameter  regardless of whether RIO_MSG_DEFER is set.     RIO_MSG_WAITALL   The RIOReceive function will not complete until one of the following events occurs:   The buffer segment supplied by the caller in the pData parameter is completely full.  The connection has been closed.   The request has been canceled or an error occurred.   This flag is not supported on UDP sockets."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "RequestContext",
        "description": "The request context to associate with this receive operation."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 9,
    "description": "The RIOReceiveEx function receives network data on a connected registered I/O TCP socket or a bound registered I/O UDP socket with additional options for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOReceiveEx function returns TRUE. In this case,  the receive operation is successfully initiated and the completion will have already been queued or the operation has been successfully initiated and the completion will be queued at a later time. A value of FALSE indicates  the function failed, the operation was not successfully initiated and no completion indication will be queued. A specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "An application can use the RIOReceiveEx  function to receive network data into any buffer completely contained within a single registered buffer.  The Offset and Length members of the RIO_BUF structure pointed to by the pData parameter determine where the network data is received in the buffer. Once the RIOReceiveEx function is called, the buffer passed in the pData parameter including the RIO_BUFFERID in the  BufferId member of RIO_BUF structure must remain valid for the duration of the receive operation. In order to avoid race conditions, a buffer associated with a receive request should not be read or written before the request completes.  This includes using the buffer as the source for a send request or the destination for another receive request.  Portions of a registered buffer not associated with any receive request are not included in this restriction. The pLocalAddress parameter can be used to retrieve the local address where the data was received.  The pRemoteAddress parameter can be used to retrieve the remote address from which the data was received. The local and remote addresses are returned as SOCKADDR_INET structures. As a result, the Length member of the RIO_BUF pointed to by pLocalAddress or  pRemoteAddress parameters should be equal or greater than the size of a SOCKADDR_INET structure. The following table summarizes the various uses of control data available for use with the control information in the pControlContext member.   Control data is made up of one or more control data objects, each beginning with a WSACMSGHDR structure, defined as the following: The members of the WSACMSGHDR structure are as follows:   The Flags parameter can be used to influence the behavior of the RIOReceiveEx function invocation beyond the options specified for the associated socket.  The behavior of this function is determined by a combination of any socket options set on the socket associated with the SocketQueue parameter and the values specified in the Flags parameter. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOReceiveEx",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_RQ",
        "name": "SocketQueue",
        "description": "A descriptor that identifies a connected registered I/O UDP socket or a bound registered I/O UDP socket."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pData",
        "description": "A description of the portion of the registered buffer in which to receive data. This parameter may be NULL for a bound registered I/O UDP socket if the application does not need to receive a data payload in the UDP datagram."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DataBufferCount",
        "description": "A data buffer count parameter that indicates if data is to be received in the buffer pointed to by the pData parameter. This parameter should be set to zero if the pData is NULL. Otherwise, this parameter should be set to 1."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pLocalAddress",
        "description": "A buffer segment that on completion will hold the local address on which the network data was received. This parameter may be NULL if the application does not want to receive the local address. If this parameter is not NULL, then the buffer segment must be at least the size of a SOCKADDR_INET structure."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pRemoteAddress",
        "description": "A buffer segment that on completion will hold the remote address from which the network data was received. This parameter may be NULL if the application does not want to receive the remote address. If this parameter is not NULL, then the buffer segment must be at least the size of a SOCKADDR_INET structure."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pControlContext",
        "description": "A buffer slice that on completion will hold additional control information about the receive operation. This parameter may be NULL if the application does not want to receive the additional control information."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pFlags",
        "description": "A buffer slice that on completion will hold additional information about the set of flags for the receive operation. This parameter may be NULL if the application does not want to receive the additional flags information."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "A set of flags that modify the behavior of the RIOReceiveEx function.  The Flags parameter can contain a combination of the following options defined in the Mswsockdef.h header file:     FlagMeaning  RIO_MSG_COMMIT_ONLY   Previous  requests added with RIO_MSG_DEFER flag will be committed.  When the RIO_MSG_COMMIT_ONLY flag is set, no other flags may be specified. When the RIO_MSG_COMMIT_ONLY flag is set, the pData, pLocalAddress, pRemoteAddress, pControlContext, pFlags, and RequestContext parameters must be NULL and the DataBufferCount parameter must be zero.  This flag would normally be used occasionally after a number of requests were issued with the RIO_MSG_DEFER flag set. This eliminates the need when using the RIO_MSG_DEFER flag to make the  last request without the  RIO_MSG_DEFER flag, which causes the last request to complete much slower than other requests.  Unlike other calls to the RIOReceiveEx function, when the RIO_MSG_COMMIT_ONLY flag is set calls to the RIOReceiveEx function do not need to be serialized.  For a single RIO_RQ, the RIOReceiveEx function can be called with  RIO_MSG_COMMIT_ONLY on one thread while calling the RIOReceiveEx function on another thread.   RIO_MSG_DONT_NOTIFY   The request should not trigger the RIONotify function when request completion is inserted into its completion queue.   RIO_MSG_DEFER   The request does not need to be executed immediately.  This will insert the request into the request queue, but it may or may not trigger the execution of the request.   Data reception may be delayed until a receive request is made on the RIO_RQ passed in the SocketQueue parameter without the RIO_MSG_DEFER flag set. To trigger execution for all receives in a request queue, call the RIOReceive or RIOReceiveEx function without the RIO_MSG_DEFER flag set.   Note  The receive request is charged against the outstanding I/O capacity on the RIO_RQ passed in the SocketQueue parameter  regardless of whether RIO_MSG_DEFER is set.     RIO_MSG_WAITALL   The RIOReceiveEx function will not complete until one of the following events occurs:   The buffer slice supplied by the caller in the pData parameter is completely full.  The connection has been closed.   The request has been canceled or an error occurred.   This flag is not supported on datagram sockets or on message-oriented connectionless sockets."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "RequestContext",
        "description": "The request context to associate with this receive operation."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The RIORegisterBuffer function registers a RIO_BUFFERID, a registered buffer descriptor,    with a specified buffer for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIORegisterBuffer function returns a registered buffer descriptor. Otherwise, a value of RIO_INVALID_BUFFERID is returned, and a specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "The RIORegisterBuffer function creates a registered buffer identifier for a specified buffer. When a buffer is registered, the virtual memory pages containing the buffer will be locked into physical memory. If several small, non-contiguous buffers are registered, the physical memory footprint for the buffers may effectively be as large as an entire memory page per registration.  In these cases it may be beneficial to allocate multiple request buffers together. There is also a small amount of overhead in physical memory used for the buffer registration itself.  So if there are many allocations aggregated into single larger allocation, the physical memory footprint may be reduced further by aggregating the buffer registrations as well.  In this case the application may need to take extra care to ensure that the buffers are eventually deregistered, but not while any send or receive requests are outstanding. A portion of a registered buffer is passed to the RIOSend, RIOSendEx, RIOReceive, and RIOReceiveEx functions in the pData parameter for sending or receiving data. When the buffer identifier is no longer needed, call the RIODeregisterBuffer function to deregister the buffer identifier. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "RIO_BUFFERID",
    "category": "Windows Sockets (Winsock)",
    "name": "RIORegisterBuffer",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCHAR",
        "name": "DataBuffer",
        "description": "A pointer to the beginning of the memory buffer to register."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "DataLength",
        "description": "The length, in bytes, in the buffer to register."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The RIOResizeCompletionQueue function resizes an I/O completion queue to be either larger or smaller for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOResizeCompletionQueue function returns TRUE. Otherwise, a value of FALSE is returned, and a specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "The RIOResizeCompletionQueue function resizes an I/O completion queue to be either larger or smaller.  If the I/O completion queue already contains completions, those completions will be copied over to the new completion queue. I/O completion queues have a required minimum size that is dependent on the number of request queues associated with the completion queue and the number of sends and receives on the request queues. If an application calls the RIOResizeCompletionQueue function  and tries to set the queue too small for the number of existing completions in the I/O completion queue, the call will fail and the queue will not be resized. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. If multiple threads attempt to  access the same RIO_CQ using the RIODequeueCompletion or RIOResizeCompletionQueue function, access must be coordinated by a critical section, slim reader writer lock , or similar mutual exclusion mechanism. If the completion queues are not shared, mutual exclusion is not required. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOResizeCompletionQueue",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_CQ",
        "name": "CQ",
        "description": "A descriptor that identifies an existing I/O completion queue to resize."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "QueueSize",
        "description": "The new size, in number of entries, of the completion queue."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The RIOResizeRequestQueue function resizes a request queue to be either larger or smaller for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOResizeRequestQueue function returns TRUE. Otherwise, a value of FALSE is returned, and a specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "The RIOResizeRequestQueue function resizes a request queue to be either larger or smaller.  If the request queue already contains entries, those entries will be copied over to the new request queue. A request queue has a required minimum size that is dependent on the current number of entries (number of sends and receives on the request queue). If an application calls the RIOResizeRequestQueue function  and tries to set the queue too small for the number of existing entries, the call will fail and the queue will not be resized. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. If multiple threads attempt to  access the same RIO_RQ using the RIODequeueCompletion or RIOResizeRequestQueue function, access must be coordinated by a critical section, slim reader writer lock , or similar mutual exclusion mechanism. If the completion queues are not shared, mutual exclusion is not required. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOResizeRequestQueue",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_RQ",
        "name": "RQ",
        "description": "A descriptor that identifies an existing registered I/O socket descriptor (request queue) to resize."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "MaxOutstandingReceive",
        "description": "The maximum number of outstanding sends allowed on the socket. This value can be larger or smaller than the original number. This parameter is usually a small number for most applications."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "MaxOutstandingSend",
        "description": "The maximum number of outstanding receives allowed on the socket. This value can be larger or smaller than the original number."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The RIOSend function sends network data on a connected registered I/O TCP socket or  a bound registered I/O UDP socket for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOSend function returns TRUE. In this case,  the send operation is successfully initiated and the completion will have already been queued or the operation has been successfully initiated and the completion will be queued at a later time. A value of FALSE indicates  the function failed, the operation was not successfully initiated and no completion indication will be queued. A specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "An application can use the RIOSend  function to send network data from any buffer completely contained within a single registered buffer.  The Offset and Length members of the RIO_BUF structure pointed to by the pData parameter determine the network data to be sent from the buffer. The buffer associated with a send operation may be used concurrently with other send operations.  In this case the buffer and buffer registration must remain valid for the duration of all such send operations. The Flags parameter can be used to influence the behavior of the RIOSend function beyond the options specified for the associated socket.  The behavior of this function is determined by a combination of any socket options set on the socket associated with the SocketQueue parameter and the values specified in the Flags parameter. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOSend",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_RQ",
        "name": "SocketQueue",
        "description": "A descriptor that identifies a connected registered I/O TCP socket or a bound registered I/O UDP socket."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pData",
        "description": "A description of the portion of the registered buffer from which to send data. This parameter may be NULL for a bound registered I/O UDP socket if the application does not need to send a data payload in the UDP datagram."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DataBufferCount",
        "description": "A data buffer count parameter that indicates if data is to be sent in the buffer pointed to by the pData parameter. This parameter should be set to zero if the pData is NULL. Otherwise, this parameter should be set to 1."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "A set of flags that modify the behavior of the RIOSend function.  The Flags parameter can contain a combination of the following options defined in the Mswsockdef.h header file:     FlagMeaning  RIO_MSG_COMMIT_ONLY   Previous  requests added with RIO_MSG_DEFER flag will be committed.  When the RIO_MSG_COMMIT_ONLY flag is set, no other flags may be specified. When the RIO_MSG_COMMIT_ONLY flag is set, the pData and RequestContext parameters must be NULL and the DataBufferCount parameter must be zero.  This flag would normally be used occasionally after a number of requests were issued with the RIO_MSG_DEFER flag set. This eliminates the need when using the RIO_MSG_DEFER flag to make the  last request without the  RIO_MSG_DEFER flag, which causes the last request to complete much slower than other requests.  Unlike other calls to the RIOSend function, when the RIO_MSG_COMMIT_ONLY flag is set calls to the RIOSend function do not need to be serialized.  For a single RIO_RQ, the RIOSend function can be called with  RIO_MSG_COMMIT_ONLY on one thread while calling the RIOSend function on another thread.   RIO_MSG_DONT_NOTIFY   The request should not trigger the RIONotify function when request completion is inserted into its completion queue.   RIO_MSG_DEFER   The request does not need to be executed immediately.  This will insert the request into the request queue, but it may or may not trigger the execution of the request.   Sending data may be delayed until a send request is made on the RIO_RQ passed in the SocketQueue parameter without the RIO_MSG_DEFER flag set. To trigger execution for all sends in a send queue, call the RIOSend or RIOSendEx function without the RIO_MSG_DEFER flag set.   Note  The send request is charged against the outstanding I/O capacity on the RIO_RQ passed in the SocketQueue parameter  regardless of whether RIO_MSG_DEFER is set."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "RequestContext",
        "description": "The request context to associate with this send operation."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 9,
    "description": "The RIOSendEx function sends network data on a connected registered I/O TCP socket or  a bound registered I/O UDP socket with additional options for use with the Winsock registered I/O extensions.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs, the RIOSendEx function returns TRUE. In this case,  the send operation is successfully initiated and the completion will have already been queued or the operation has been successfully initiated and the completion will be queued at a later time. A value of FALSE indicates  the function failed, the operation was not successfully initiated and no completion indication will be queued. A specific error code can be retrieved by calling the WSAGetLastError function.  ",
    "remarks": "An application can use the RIOSendEx  function to send network data from any buffer completely contained within a single registered buffer.  The Offset and Length members of the RIO_BUF structure pointed to by the pData parameter determine the network data to be sent from the buffer. The buffer associated with a send operation may be used concurrently with other send operations.  In this case the buffer and buffer registration must remain valid for the duration of all such send operations. The pLocalAddress parameter can be used to retrieve the local address from which the data was sent.  The pRemoteAddress parameter can be used to retrieve the remote address to which the data was sent. The local and remote addresses are returned as SOCKADDR_INET structures. As a result, the Length member of the RIO_BUF pointed to by pLocalAddress or  pRemoteAddress parameters should be equal or greater than the size of a SOCKADDR_INET structure. The following table summarizes the various uses of control data available for use with the control information in the pControlContext member.   Control data is made up of one or more control data objects, each beginning with a WSACMSGHDR structure, defined as the following: The members of the WSACMSGHDR structure are as follows:   The Flags parameter can be used to influence the behavior of the RIOSendEx function beyond the options specified for the associated socket.  The behavior of this function is determined by a combination of any socket options set on the socket associated with the SocketQueue parameter and the values specified in the Flags parameter. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "RIOSendEx",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "RIO_RQ",
        "name": "SocketQueue",
        "description": "A descriptor that identifies a connected registered I/O TCP socket or a bound registered I/O UDP socket."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pData",
        "description": "A buffer segment from a registered buffer from which to send data. The RIO_BUF structure pointed to by this parameter can represent a portion of a registered buffer or a complete registered buffer. This parameter may be NULL for a bound registered I/O UDP socket if the application does not need to send a data payload in the UDP datagram."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "DataBufferCount",
        "description": "A data buffer count parameter that indicates if data is to be sent in the buffer pointed to by the pData parameter. This parameter should be set to zero if the pData is NULL. Otherwise, this parameter should be set to 1."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pLocalAddress",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pRemoteAddress",
        "description": "A buffer segment from a registered buffer that on input holds the remote address to which the network data is to be sent. This parameter may be NULL if the socket is connected."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pControlContext",
        "description": "A buffer slice that on completion will hold additional control information about the send operation. This parameter may be NULL if the application does not want to receive the additional control information."
      },
      {
        "in_out": "_In_",
        "type": "PRIO_BUF",
        "name": "pFlags",
        "description": "A buffer slice that on completion will hold additional information about the set of flags for the send operation. This parameter may be NULL if the application does not want to receive the additional flags information."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "A set of flags that modify the behavior of the RIOSendEx function.  The Flags parameter can contain a combination of the following options defined in the Mswsockdef.h header file:     FlagMeaning  RIO_MSG_COMMIT_ONLY   Previous  requests added with RIO_MSG_DEFER flag will be committed.  When the RIO_MSG_COMMIT_ONLY flag is set, no other flags may be specified. When the RIO_MSG_COMMIT_ONLY flag is set, the pData, pLocalAddress, pRemoteAddress, pControlContext, pFlags, and RequestContext parameters must be NULL and the DataBufferCount parameter must be zero.  This flag would normally be used occasionally after a number of requests were issued with the RIO_MSG_DEFER flag set. This eliminates the need when using the RIO_MSG_DEFER flag to make the  last request without the  RIO_MSG_DEFER flag, which causes the last request to complete much slower than other requests.  Unlike other calls to the RIOSendEx function, when the RIO_MSG_COMMIT_ONLY flag is set calls to the RIOSendEx function do not need to be serialized.  For a single RIO_RQ, the RIOSendEx function can be called with  RIO_MSG_COMMIT_ONLY on one thread while calling the RIOSendEx function on another thread.   RIO_MSG_DONT_NOTIFY   The request should not trigger the RIONotify function when request completion is inserted into its completion queue.   RIO_MSG_DEFER   The request does not need to be executed immediately.  This will insert the request into the request queue, but it may or may not trigger the execution of the request.   Sending data may be delayed until a send request is made on the RIO_RQ passed in the SocketQueue parameter without the RIO_MSG_DEFER flag set. To trigger execution for all sends in a send queue, call the RIOSend or RIOSendEx function without the RIO_MSG_DEFER flag set.   Note  The send request is charged against the outstanding I/O capacity on the RIO_RQ passed in the SocketQueue parameter  regardless of whether RIO_MSG_DEFER is set."
      },
      {
        "in_out": "_In_",
        "type": "PVOID",
        "name": "RequestContext",
        "description": "The request context to associate with this send operation."
      }
    ],
    "min_client": "Windows 8.1, Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  select function determines the status of one or more sockets, waiting if necessary, to perform synchronous I/O.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  select function returns the total number of socket handles that are ready and contained in the  fd_set structures, zero if the time limit expired, or SOCKET_ERROR if an error occurred. If the return value is SOCKET_ERROR,  WSAGetLastError can be used to retrieve a specific error code.  ",
    "remarks": "The  select function is used to determine the status of one or more sockets. For each socket, the caller can request information on read, write, or error status. The set of sockets for which a given status is requested is indicated by an  fd_set structure. The sockets contained within the  fd_set structures must be associated with a single service provider. For the purpose of this restriction, sockets are considered to be from the same service provider if the  WSAPROTOCOL_INFO structures describing their protocols have the same providerId value. Upon return, the structures are updated to reflect the subset of these sockets that meet the specified condition. The  select function returns the number of sockets meeting the conditions. A set of macros is provided for manipulating an  fd_set structure. These macros are compatible with those used in the Berkeley software, but the underlying representation is completely different. The parameter readfds identifies the sockets that are to be checked for readability. If the socket is currently in the  listen state, it will be marked as readable if an incoming connection request has been received such that an  accept is guaranteed to complete without blocking. For other sockets, readability means that queued data is available for reading such that a call to  recv,  WSARecv,  WSARecvFrom, or  recvfrom is guaranteed not to block. For connection-oriented sockets, readability can also indicate that a request to close the socket has been received from the peer. If the virtual circuit was closed gracefully, and all data was received, then a  recv will return immediately with zero bytes read. If the virtual circuit was reset, then a  recv will complete immediately with an error code such as  WSAECONNRESET. The presence of OOB data will be checked if the socket option SO_OOBINLINE has been enabled (see  setsockopt). The parameter writefds identifies the sockets that are to be checked for writability. If a socket is processing a  connect call (nonblocking), a socket is writeable if the connection establishment successfully completes. If the socket is not processing a  connect call, writability means a  send,  sendto, or  WSASendto are guaranteed to succeed. However, they can block on a blocking socket if the len parameter exceeds the amount of outgoing system buffer space available. It is not specified how long these guarantees can be assumed to be valid, particularly in a multithreaded environment. The parameter exceptfds identifies the sockets that are to be checked for the presence of OOB data or any exceptional error conditions. Any two of the parameters, readfds, writefds, or exceptfds, can be given as null. At least one must be non-null, and any non-null descriptor set must contain at least one handle to a socket. In summary, a socket will be identified in a particular set when  select returns if: readfds: writefds: exceptfds: Four macros are defined in the header file Winsock2.h for manipulating and checking the descriptor sets. The variable FD_SETSIZE determines the maximum number of descriptors in a set. (The default value of FD_SETSIZE is 64, which can be modified by defining FD_SETSIZE to another value before including Winsock2.h.) Internally, socket handles in an  fd_set structure are not represented as bit flags as in Berkeley Unix. Their data representation is opaque. Use of these macros will maintain software portability between different socket environments. The macros to manipulate and check  fd_set contents are:  The parameter time-out controls how long the  select can take to complete. If time-out is a null pointer,  select will block indefinitely until at least one descriptor meets the specified criteria. Otherwise, time-out points to a  TIMEVAL structure that specifies the maximum time that  select should wait before returning. When  select returns, the contents of the TIMEVAL structure are not altered. If TIMEVAL is initialized to {0, 0},  select will return immediately; this is used to poll the state of the selected sockets. If  select returns immediately, then the  select call is considered nonblocking and the standard assumptions for nonblocking calls apply. For example, the blocking hook will not be called, and Windows Sockets will not yield. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "select",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nfds",
        "description": "Ignored. The nfds parameter is included only for compatibility with Berkeley sockets."
      },
      {
        "in_out": "_Inout_",
        "type": "fd_set*",
        "name": "readfds",
        "description": "An optional pointer to a set of sockets to be checked for readability."
      },
      {
        "in_out": "_Inout_",
        "type": "fd_set*",
        "name": "writefds",
        "description": "An optional pointer to a set of sockets to be checked for writability."
      },
      {
        "in_out": "_Inout_",
        "type": "fd_set*",
        "name": "exceptfds",
        "description": "An optional pointer to a set of sockets to be checked for errors."
      },
      {
        "in_out": "_In_",
        "type": "const struct timeval*",
        "name": "timeout",
        "description": "The maximum time for  select to wait, provided in the form of a  TIMEVAL structure. Set the timeout parameter to null for blocking operations."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  send function sends data on a connected socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  send returns the total number of bytes sent, which can be less than the number requested to be sent in the len parameter. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  send function is used to write outgoing data on a connected socket. For message-oriented sockets (address family of AF_INET or AF_INET6, type of SOCK_DGRAM, and protocol of IPPROTO_UDP, for example), care must be taken not to exceed the maximum packet size of the underlying provider. The maximum message packet size for a provider can be obtained by calling getsockopt with the optname parameter set to SO_MAX_MSG_SIZE to retrieve the value of socket option. If the data is too long to pass atomically through the underlying protocol, the error  WSAEMSGSIZE is returned, and no data is transmitted. The successful completion of a  send function does not indicate that the data was successfully delivered and received to the recipient. This function only indicates the data was successfully sent. If no buffer space is available within the transport system to hold the data to be transmitted,  send will block unless the socket has been placed in nonblocking mode. On nonblocking stream oriented sockets, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the client and server computers. The  select,  WSAAsyncSelect or  WSAEventSelect functions can be used to determine when it is possible to send more data. Calling  send with a len parameter of zero is permissible and will be treated by implementations as successful. In such cases,  send will return zero as a valid value. For message-oriented sockets, a zero-length transport datagram is sent. The flags parameter can be used to influence the behavior of the function beyond the options specified for the associated socket. The semantics of the send function are determined by any options previously set on the socket specified in the s parameter and the flags parameter passed to the send function. The order of calls made to send is also the order in which the buffers are transmitted to the transport layer. send should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from multiple concurrent send requests on the same stream-oriented socket. The following example demonstrates the use of the send function. For a another example that uses the send function, see Getting Started With Winsock. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "send",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a connected socket."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "buf",
        "description": "A pointer to a buffer containing the data to be transmitted."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "len",
        "description": "The length, in bytes, of the data in buffer pointed to by the buf parameter."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "flags",
        "description": "A set of flags that specify the way in which the call is made. This parameter is constructed by using the bitwise OR operator with any of the following values.  ValueMeaning  MSG_DONTROUTE   Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.   MSG_OOB   Sends OOB data (stream-style socket such as SOCK_STREAM only."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "The  sendto function sends data to a specific destination.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  sendto returns the total number of bytes sent, which can be less than the number indicated by len. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  sendto function is used to write outgoing data on a socket. For message-oriented sockets, care must be taken not to exceed the maximum packet size of the underlying subnets, which can be obtained by using  getsockopt to retrieve the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol, the error  WSAEMSGSIZE is returned and no data is transmitted. The to parameter can be any valid address in the socket's address family, including a broadcast or any multicast address. To send to a broadcast address, an application must have used  setsockopt with SO_BROADCAST enabled. Otherwise,  sendto will fail with the error code  WSAEACCES. For TCP/IP, an application can send to any multicast address (without becoming a group member). If the socket is unbound, unique values are assigned to the local association by the system, and the socket is then marked as bound. If the socket is connected, the getsockname function can be used to determine the local IP address and port associated with the socket. If the socket is not connected, the   getsockname   function can be used to determine the local port number associated with the socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY  or \"0.0.0.0\" for IPv4 and IN6ADDR_ANY_INIT or \"::\" for IPv6). The successful completion of a  sendto does not indicate that the data was successfully delivered. The  sendto function is normally used on a connectionless socket to send a datagram to a specific peer socket identified by the to parameter. Even if the connectionless socket has been previously connected to a specific address, the to parameter overrides the destination address for that particular datagram only. On a connection-oriented socket, the to and tolen parameters are ignored, making  sendto equivalent to  send. The following example demonstrates the use of the sendto function. To send a broadcast (on a SOCK_DGRAM only), the address pointed to by the to parameter can be constructed to contain the special IPv4 address INADDR_BROADCAST (defined in Winsock2.h), together with the intended port number. If the address pointed to by the to parameter contains the INADDR_BROADCAST address and intended port, then the broadcast will be sent out on all interfaces to that port. If the broadcast should be sent out only on a specific interface, then the address pointed to by the to parameter should contain the subnet broadcast address for the interface and the intended port. For example, an IPv4 network address of 192.168.1.0 with a subnet mask of 255.255.255.0 would use a subnet broadcast address of 192.168.1.255. It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes. If no buffer space is available within the transport system to hold the data to be transmitted,  sendto will block unless the socket has been placed in a nonblocking mode. On nonblocking, stream oriented sockets, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the client and server systems. The  select,  WSAAsyncSelect or  WSAEventSelect function can be used to determine when it is possible to send more data. Calling  sendto with a len of zero is permissible and will return zero as a valid value. For message-oriented sockets, a zero-length transport datagram is sent. The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the flags parameter. The latter is constructed by using the bitwise OR operator with any of the following values.  Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "sendto",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a (possibly connected) socket."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "buf",
        "description": "A pointer to a buffer containing the data to be transmitted."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "len",
        "description": "The length, in bytes, of the data pointed to by the buf parameter."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "flags",
        "description": "A set of flags that specify the way in which the call is made."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "to",
        "description": "An optional pointer to a  sockaddr structure that contains the address of the target socket."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "tolen",
        "description": "The size, in bytes, of the address pointed to by the to parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 12,
    "description": "The  SetAddrInfoEx function registers or deregisters a name, a service name, and associated addresses with      a specific namespace provider.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  SetAddrInfoEx returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as found in the  Windows Sockets Error Codes.  ",
    "remarks": "The SetAddrInfoEx  function provides a protocol-independent method to register or deregister a name and one or more addresses with a namespace provider. The NS_EMAIL namespace provider in Windows Vista and later supports registration and deregistration of addresses. The default NS_DNS, NS_PNRPNAME, and NS_PNRPNAME namespace providers do not currently support name registration. If the SetAddrInfoEx  function is called with NS_ALL set as the dwNameSpace parameter and the lpNspId parameter unspecified, then SetAddrInfoEx will attempt to register or deregister the name and associated addresses with all installed and active namespaces. The SetAddrInfoEx function will return success if any of the namespace providers successfully registered or deregistered the name, but there will not be any indication of which namespace provider succeeded or which ones failed the request. When UNICODE or _UNICODE is defined, SetAddrInfoEx is defined to SetAddrInfoExW, the Unicode version of this function. The string parameters are defined to the PWSTR data type. When UNICODE or _UNICODE is not defined, SetAddrInfoEx is defined to SetAddrInfoExA, the ANSI version of this function. The string parameters are of the PCSTR data type. Information  that is registered with a namespace provider can be returned by calling the GetAddrInfoEx,   getaddrinfo, or GetAddrInfoWfunctions.  The GetAddrInfoEx function is an enhanced version of the getaddrinfo and GetAddrInfoW functions. On Windows Vista and later, when SetAddrInfoEx is called from a service, if the operation is the result of a user process calling the service, then the service should impersonate the user.  This is to allow security and routing compartments to be properly enforced. Windows 8.1 and Windows Server 2012 R2: The  SetAddrInfoExW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "SetAddrInfoEx",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pName",
        "description": "A pointer to a NULL-terminated string containing a name under which addresses are to be registered or deregistered. The interpretation of this parameter specific to the namespace provider."
      },
      {
        "in_out": "_In_",
        "type": "PCTSTR",
        "name": "pServiceName",
        "description": "A pointer to an optional NULL-terminated string that contains the service name  associated with the name being registered. The interpretation of this parameter is specific to the namespace provider."
      },
      {
        "in_out": "_Inout_",
        "type": "SOCKET_ADDRESS*",
        "name": "pAddresses",
        "description": "A pointer to an optional list of addresses to register with the namespace provider."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAddressCount",
        "description": "The number of addresses passed in pAddresses parameter. If this parameter is zero, the pName parameter is deregistered from the namespace provider."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPBLOB",
        "name": "lpBlob",
        "description": "An optional pointer to data that is used to set provider-specific namespace information that is associated with the pName parameter beyond a list of addresses. Any information that cannot be passed in the pAddresses parameter can be passed in the lpBlob parameter. The format of this information is specific to the namespace provider."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of flags controlling how the pName and pServiceName parameters are to be  registered with the namespace provider. The interpretation of this information is specific to the namespace provider."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNameSpace",
        "description": "A namespace identifier that determines which namespace provider to register this information with.  Passing a specific namespace identifier will result in registering this information only with the namespace providers that support the specified namespace. Specifying NS_ALL will result in registering the information with all installed and active namespace providers.   Options for the dwNameSpace parameter are listed in the Winsock2.h include file. Several namespace providers are included with Windows Vista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many others are possible.  ValueMeaning  NS_ALL   All installed and active namespaces.   NS_BTH   The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.   NS_DNS   The domain name system (DNS) namespace.   NS_EMAIL   The email namespace. This namespace identifier is supported on Windows Vista and later.   NS_NLA   The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.   NS_PNRPNAME   The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and later.   NS_PNRPCLOUD   The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on Windows Vista and later."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPGUID",
        "name": "lpNspId",
        "description": "A pointer to an optional GUID of a specific namespace provider to register this information with in the case where  multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a specific namespace provider will result in the information being registered with only the specified namespace provider. The WSAEnumNameSpaceProviders function can be called to retrieve the GUID for a namespace provider."
      },
      {
        "in_out": "_In_opt_",
        "type": "struct timeval*",
        "name": "timeout",
        "description": "An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. This parameter is currently reserved and must be set to NULL since a timeout option is not supported."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently reserved and must be set to NULL since asynchronous operations are not supported."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPLOOKUPSERVICE_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This parameter is currently reserved and must be set to NULL since asynchronous operations are not supported."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPHANDLE",
        "name": "lpNameHandle",
        "description": "An optional pointer used only for asynchronous operations.  This parameter is currently reserved and must be set to NULL since asynchronous operations are not supported."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "The  setipv4sourcefilter inline function  sets the multicast filter state for an IPv4  socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  setipv4sourcefilter returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  setipv4sourcefilter inline function is used to set the multicast filter state for an IPv4  socket. This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can  use these functions to retrieve and set the multicast source address filters associated with a socket. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "setipv4sourcefilter",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor that identifies a multicast socket."
      },
      {
        "in_out": "_In_",
        "type": "IN_ADDR",
        "name": "Interface",
        "description": "The local IPv4 address of the interface or the interface index on which the multicast group should be joined or dropped.  This value is in network byte order. If this member specifies an IPv4 address of 0.0.0.0, the default IPv4 multicast interface is used. Any IP address in the 0.x.x.x block (first octet of 0) except IPv4 address 0.0.0.0 is treated as an interface index. An interface index is a 24-bit number, and the 0.0.0.0/8 IPv4 address block is not used (this range is reserved).  To use an interface index of 1 would be the same as an IP address of 0.0.0.1."
      },
      {
        "in_out": "_In_",
        "type": "IN_ADDR",
        "name": "Group",
        "description": "The IPv4 address of the multicast group."
      },
      {
        "in_out": "_In_",
        "type": "MULTICAST_MODE_TYPE",
        "name": "FilterMode",
        "description": "The multicast filter mode for multicast group address."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SourceCount",
        "description": "The number of source addresses in the buffer pointed to by the SourceList parameter."
      },
      {
        "in_out": "_In_",
        "type": "const IN_ADDR*",
        "name": "SourceList",
        "description": "A pointer to a buffer with the  IP addresses to associate with the multicast filter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "The  SetService function registers or removes from the registry a network service within one or more namespaces. The function can also add or remove a network service type within one or more namespaces.",
    "library": "Mswsock.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Nspapi.h",
    "return_value": "If the function fails, the return value is SOCKET_ERROR. To get extended error information, call  GetLastError. GetLastError can return the following extended error value.  ",
    "remarks": "",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "SetService",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNameSpace",
        "description": "The namespace, or a set of default namespaces, within which the function will operate.     Use one of the following constants to specify a namespace.  ValueMeaning  NS_DEFAULT   A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for dwNameSpace.   NS_DNS   The Domain Name System used in the Internet to resolve the name of the host.   NS_NDS   The NetWare 4 provider.   NS_NETBT   The NetBIOS over TCP/IP layer. All Windows systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration.   NS_SAP   The NetWare Service Advertising Protocol. This can access the NetWare bindery, if appropriate. NS_SAP is a dynamic namespace that enables the registration of services.   NS_TCPIP_HOSTS   Lookup value in the <systemroot>\\system32\\drivers\\etc\\posts file.   NS_TCPIP_LOCAL   Local TCP/IP name resolution mechanisms, including comparisons against the local host name and lookup value in the cache of host to IP address mappings."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOperation",
        "description": "The operation that the function will perform. Use one of the following values to specify an operation:     ValueMeaning  SERVICE_REGISTER   Register the network service with the namespace. This operation can be used with the SERVICE_FLAG_DEFER and SERVICE_FLAG_HARD bit flags.   SERVICE_DEREGISTER   Remove from the registry the network service from the namespace. This operation can be used with the SERVICE_FLAG_DEFER and SERVICE_FLAG_HARD bit flags.   SERVICE_FLUSH   Perform any operation that was called with the SERVICE_FLAG_DEFER bit flag set to one.   SERVICE_ADD_TYPE   Add a service type to the namespace.     For this operation, use the ServiceSpecificInfo member of the  SERVICE_INFO structure pointed to by lpServiceInfo to pass a  SERVICE_TYPE_INFO_ABS structure. You must also set the ServiceType member of the  SERVICE_INFO structure. Other  SERVICE_INFO members are ignored.   SERVICE_DELETE_TYPE   Remove a service type, added by a previous call specifying the SERVICE_ADD_TYPE operation, from the namespace."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of bit flags that modify the function's operation. You can set one or more of the following bit flags:     ValueMeaning  SERVICE_FLAG_DEFER   This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER.     If this bit flag is one, and it is valid, the namespace provider should defer the registration or deregistration operation until a SERVICE_FLUSH operation is requested.   SERVICE_FLAG_HARD   This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER.     If this bit flag is one, and it is valid, the namespace provider updates any relevant persistent store information when the operation is performed. For example: If the operation involves deregistration in a namespace that uses a persistent store, the namespace provider would remove the relevant persistent store information."
      },
      {
        "in_out": "_In_",
        "type": "LPSERVICE_INFO",
        "name": "lpServiceInfo",
        "description": "A pointer to a  SERVICE_INFO structure that contains information about the network service or service type."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSERVICE_ASYNC_INFO",
        "name": "lpServiceAsyncInfo",
        "description": "Reserved for future use. Must be set to NULL."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwStatusFlags",
        "description": "A set of bit flags that receive function status information. The following bit flag is defined:     ValueMeaning  SET_SERVICE_ PARTIAL_SUCCESS   One or more namespace providers were unable to successfully perform the requested operation."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  SetSocketMediaStreamingMode function indicates whether the network is to be used for transferring streaming media that requires quality of service.",
    "library": "Windows.Networking.lib",
    "min_server": "Windows Server 2012 [desktop apps | Windows Store apps]",
    "header": "Socketapi.h",
    "return_value": "If no error occurs,  SetSocketMediaStreamingMode returns S_OK. Otherwise, an error code is returned as an HRESULT. ",
    "remarks": "The  SetSocketMediaStreamingMode function is used to indicate whether the network is to be used for transferring streaming media that requires quality of service. This function is normally used by Voice over IP (VoIP) or similar apps that require a consistent quality of service.  The SetSocketMediaStreamingMode function can be used by Windows Store apps or desktop apps. There can be quality of service issues for media streaming when used over an 802.11 wireless network. The 802.11 network driver will periodically scan for other nearby infrastructure networks (ESS) or ad-hoc networks (IBSS). This allows the wireless network adapter to find other networks and possibly connected to a network with a stronger signal. Most current 802.11 network drivers scan all of the available channels as a series at once. When the 802.11 network driver is scanning for other networks and listening on other channels, it cannot receive packets for the app. The time spent scanning for other networks can introduce a noticeable gap (100 milliseconds or more)  when a VoIP app would be unable to receive the audio stream. This scanning process is longer for 802.11 network adapters that are dual band (2.4GHz and 5GHz) since even more channels are scanned. This can result in the audio to be perceived as stuttering. When the SetSocketMediaStreamingMode function is called with the value parameter set to TRUE and the socket will be transferring over an 802.11 wireless network adapter, the system will notify the wireless network driver to stop scanning for other networks. This eliminates stuttering by VoIP and similar audio apps when used over 802.11 wireless networks, but also affects any apps running on the local computer or device. There are cases where turning off scans may cause problems. When scans are disabled, the local computer  stays connected to the same network even if the signal becomes weaker and weaker as the user moves away from the network. A VoIP or similar app should close all low latency sockets to restore the media streaming mode of the 802.11 wireless network driver. This will re-enable scanning for other wireless networks. The SetSocketMediaStreamingMode function has no effect if the socket will not be sending or receiving packets over an 802.11 wireless adapter. ",
    "return_type": "HRESULT WINAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "SetSocketMediaStreamingMode",
    "is_callback": 0,
    "dll": "Windows.Networking.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "BOOL",
        "name": "value",
        "description": "Indicates whether the network is to be used for transferring streaming media that requires quality of service. This ensures that sockets opened as low latency will get the right quality of service over 802.11 wireless networks."
      }
    ],
    "min_client": "Windows 8 [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  setsockopt function sets a socket option.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  setsockopt returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  setsockopt function sets the current value for a socket option associated with a socket of any type, in any state. Although options can exist at multiple protocol levels, they are always present at the uppermost socket level. Options affect socket operations, such as whether expedited data (OOB data for example) is received in the normal data stream, and whether broadcast messages can be sent on the socket. There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options that require an integer value or structure. To enable a Boolean option, the optval parameter points to a nonzero integer. To disable the option optval points to an integer equal to zero. The optlen parameter should be equal to sizeof(int) for Boolean options. For other options, optval points to an integer or structure that contains the desired value for the option, and optlen is the length of the integer or structure. The following tables list some of the common options supported by the setsockopt function. The Type column identifies the type of data addressed by optval parameter. The  Description column provides some basic information about the socket option. For more complete lists of socket options and more detailed information (default values, for example), see the detailed topics under Socket Options. level = SOL_SOCKET  For more complete and detailed information about socket options for level = SOL_SOCKET, see SOL_SOCKET Socket Options. level = IPPROTO_TCP  For more complete and detailed information about socket options for level = IPPROTO_TCP, see IPPROTO_TCP Socket Options. level = NSPROTO_IPX  For more complete and detailed information about socket options for level = NSPROTO_IPX, see NSPROTO_IPX Socket Options. BSD options not supported for  setsockopt are shown in the following table.   The following example demonstrates the setsockopt function.  When developing applications using Windows sockets for IrDA, note the following: The IRLMP_IAS_SET socket option enables the application to set a single attribute of a single class in the local IAS. The application specifies the class to set, the attribute, and attribute type. The application is expected to allocate a buffer of the necessary size for the passed parameters. IrDA provides an IAS database that stores IrDA-based information. Limited access to the IAS database is available through the Windows Sockets 2 interface, but such access is not normally used by applications, and exists primarily to support connections to non-Windows devices that are not compliant with the Windows Sockets 2 IrDA conventions. The following structure, IAS_SET, is used with the IRLMP_IAS_SET setsockopt option to manage the local IAS database: The following structure, IAS_QUERY, is used with the IRLMP_IAS_QUERY setsockopt option to query a peer's IAS database: Many SO_ level socket options are not meaningful to IrDA. Only SO_LINGER is specifically supported. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "setsockopt",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies a socket."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "level",
        "description": "The level at which the option is defined (for example, SOL_SOCKET)."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "optname",
        "description": "The socket option for which the value is to be set (for example, SO_BROADCAST). The optname parameter must be a socket option defined within the specified level, or behavior is undefined."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "optval",
        "description": "A pointer to the buffer in which the value for the requested option is specified."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "optlen",
        "description": "The size, in bytes, of the buffer pointed to by the optval parameter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  setsourcefilter inline function  sets the multicast filter state for an IPv4 or IPv6   socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Ws2tcpip.h",
    "return_value": "On success,  setsourcefilter returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  setsourcefilter inline function is used to set the multicast filter state for an IPv4  or IPv6 socket. This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can  use these functions to retrieve and set the multicast source address filters associated with a socket. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "setsourcefilter",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor that identifies a multicast socket."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "Interface",
        "description": "The interface index of the multicast interface."
      },
      {
        "in_out": "_In_",
        "type": "const SOCKADDR*",
        "name": "Group",
        "description": "A pointer to the socket address of the multicast group."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "GroupLength",
        "description": "The length, in bytes, of the socket address pointed to by the Group parameter."
      },
      {
        "in_out": "_In_",
        "type": "MULTICAST_MODE_TYPE",
        "name": "FilterMode",
        "description": "The multicast filter mode for the multicast group address."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SourceCount",
        "description": "The number of source addresses in the buffer pointed to by the SourceList parameter."
      },
      {
        "in_out": "_In_",
        "type": "const SOCKADDR_STORAGE*",
        "name": "SourceList",
        "description": "A pointer to a buffer with the  IP addresses to associate with the multicast filter."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  shutdown function disables sends or receives on a socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  shutdown returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  shutdown function is used on all types of sockets to disable reception, transmission, or both. If the how parameter is SD_RECEIVE, subsequent calls to the  recv function on the socket will be disallowed. This has no effect on the lower protocol layers. For TCP sockets, if there is still data queued on the socket waiting to be received, or data arrives subsequently, the connection is reset, since the data cannot be delivered to the user. For UDP sockets, incoming datagrams are accepted and queued. In no case will an ICMP error packet be generated. If the how parameter is SD_SEND, subsequent calls to the  send function are disallowed. For TCP sockets, a FIN will be sent after all data is sent and acknowledged by the receiver. Setting how to SD_BOTH disables both sends and receives as described above. The  shutdown function does not close the socket. Any resources attached to the socket will not be freed until  closesocket is invoked. To assure that all data is sent and received on a connected socket before it is closed, an application should use  shutdown to close connection before calling  closesocket. One method to wait for notification that the remote end has sent all its data and initiated a graceful disconnect uses the WSAEventSelect function as follows : Another method to wait for notification that the remote end has sent all its data and initiated a graceful disconnect uses overlapped receive calls follows :  For more information, see the section on Graceful Shutdown, Linger Options, and Socket Closure. Once the shutdown function is called to disable send, receive, or both, there is no method to re-enable send or receive for the existing socket connection. An application should not rely on being able to reuse a socket after it has been shut down. In particular, a Windows Sockets provider is not required to support the use of  connect on a socket that has been shut down. If an application wants to reuse a socket, then the DisconnectEx function should be called with the dwFlags parameter set to TF_REUSE_SOCKET to close a connection on a socket and prepare the socket handle to be reused.  When the  DisconnectEx request completes, the socket handle can be passed to the  AcceptEx or  ConnectEx function. If an application wants to reuse a socket, the TransmitFile or TransmitPackets functions can be called with the dwFlags parameter set with TF_DISCONNECT and TF_REUSE_SOCKET to disconnect after all the data has been queued for transmission and prepare the socket handle to be reused. When the TransmitFile request completes, the socket handle can be passed to the  function call previously used to establish the connection, such as AcceptEx  or ConnectEx. When the  TransmitPackets function completes, the socket handle can be passed to the  AcceptEx function.  There are important issues associated with connection teardown when using Asynchronous Transfer Mode (ATM) and Windows Sockets 2. For more information about these important considerations, see the section titled Notes for ATM in the Remarks section of the  closesocket function reference. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "shutdown",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "how",
        "description": "A flag that describes what types of operation will no longer be allowed. Possible values for this flag are listed in the Winsock2.h header file.  ValueMeaning  SD_RECEIVE 0   Shutdown receive operations.   SD_SEND 1   Shutdown send operations.   SD_BOTH 2   Shutdown both send and receive operations."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  socket function creates a socket that is bound to a specific transport service provider.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  socket returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  socket function causes a socket descriptor and any related resources to be allocated and bound to a specific transport-service provider. Winsock will utilize the first available service provider that supports the requested combination of address family, socket type and protocol parameters. The socket that is created will have the overlapped attribute as a default. For Windows, the Microsoft-specific socket option, SO_OPENTYPE, defined in Mswsock.h can affect this default. See Microsoft-specific documentation for a detailed description of SO_OPENTYPE. Sockets without the overlapped attribute can be created by using  WSASocket. All functions that allow overlapped operation (WSASend,  WSARecv, WSASendTo,  WSARecvFrom, and  WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operation are NULL. When selecting a protocol and its supporting service provider this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on type or af either. That is, they do not lead to an error code of  WSAEAFNOSUPPORT or  WSAEPROTONOSUPPORT if no suitable protocol is found. Applications are encouraged to use AF_INET6 for the af parameter and create a dual-mode socket that can be used with both IPv4 and IPv6. Connection-oriented sockets such as SOCK_STREAM provide full-duplex connections, and must be in a connected state before any data can be sent or received on it. A connection to another socket is created with a  connect call. Once connected, data can be transferred using  send and  recv calls. When a session has been completed, a  closesocket must be performed. The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to  WSAETIMEDOUT. Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using  sendto and  recvfrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer using  send and can be received only from this peer using  recv. IPv6 and IPv4 operate differently when receiving a socket with a type of SOCK_RAW. The IPv4 receive packet includes the packet payload, the next upper-level header (for example, the IP header for a TCP or UDP packet), and the IPv4 packet header. The IPv6 receive packet includes the packet payload and the next upper-level header. The IPv6 receive packet never includes the IPv6 packet header. A socket with a type parameter of SOCK_SEQPACKET is based on datagrams, but functions as a pseudo-stream protocol. For both send and receive packets, separate datagrams are used. However, Windows Sockets can coalesce multiple receive packets into a single packet. So an application  can issue a receive call (for example, recv or WSARecvEx) and retrieve the data from several coalesced multiple packets in single call. The AF_NETBIOS address family supports a type parameter of SOCK_SEQPACKET. When the af parameter is AF_NETBIOS for NetBIOS over TCP/IP, the type parameter can be  SOCK_DGRAM or SOCK_SEQPACKET. For the AF_NETBIOS address family, the protocol parameter is the LAN adapter number represented as a negative number. On Windows XP and later, the following command can be used to list the Windows Sockets catalog to determine the service providers installed and the address family, socket type, and protocols that are supported. netsh winsock show catalog Support for sockets with type SOCK_RAW is not required, but service providers are encouraged to support raw sockets as practicable. Keep the following in mind: A socket for use with the AF_IRDA address family can only be created if the local computer has an infrared port and driver installed. Otherwise, a call to the socket function with af parameter set to AF_IRDA will fail and WSAGetLastError returns WSAEPROTONOSUPPORT. The following example demonstrates the use of the socket function to create a socket that is bound to a specific transport service provider.. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "SOCKET WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "socket",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "af",
        "description": "The address family specification. Possible values for the address family are defined in the Winsock2.h header file.  On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET or AF_INET6, which are the Internet                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. The table below lists common values for address family although many other values are possible.   AfMeaning  AF_UNSPEC 0   The address family is unspecified.   AF_INET 2   The Internet Protocol version 4 (IPv4) address family.   AF_IPX 6   The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed.  This address family is not supported on Windows Vista and later.   AF_APPLETALK 16   The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed.  This address family is not supported on Windows Vista and later.   AF_NETBIOS 17   The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed.  The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows.  The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows 7,  Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP.   The Windows Sockets provider for NetBIOS  only supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS  is not directly related to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008, and later.   AF_INET6 23   The Internet Protocol version 6 (IPv6) address family.   AF_IRDA 26   The Infrared Data Association (IrDA) address family.  This address family is only supported if the computer has an infrared port and driver installed.   AF_BTH 32   The Bluetooth address family.  This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "type",
        "description": "The type specification for the new socket.    Possible values for the socket type are defined in the Winsock2.h header file. The following table lists the possible values for the type parameter supported for Windows Sockets 2:  TypeMeaning  SOCK_STREAM 1   A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).   SOCK_DGRAM 2   A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).   SOCK_RAW 3   A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket.  To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the socket.     SOCK_RDM 4   A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as reliable multicast programming.  This type value is only supported if the Reliable Multicast Protocol is installed.   SOCK_SEQPACKET 5   A socket type that provides a pseudo-stream packet based on datagrams.      In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the  WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are SOCK_DGRAM and SOCK_STREAM."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "protocol",
        "description": "The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. Possible values for the protocol are defined in the  Winsock2.h and Wsrm.h header files. On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this parameter can be one of the values from the IPPROTO enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. If a value of  0 is specified, the caller does not               wish to specify a protocol and the service provider will choose the protocol to use.  When the af parameter is AF_INET or AF_INET6 and the type is SOCK_RAW, the value specified for the protocol is set in the protocol field of the IPv6 or IPv4 packet header.  The table below lists common values for the protocol although many other values are possible.   protocolMeaning  IPPROTO_ICMP 1   The Internet Control Message Protocol (ICMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.   IPPROTO_IGMP 2   The Internet Group Management Protocol (IGMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.   BTHPROTO_RFCOMM 3   The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the af parameter is AF_BTH and the type parameter is SOCK_STREAM.  This protocol value is supported on Windows XP with SP2 or later.   IPPROTO_TCP 6   The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter is SOCK_STREAM.   IPPROTO_UDP 17   The User Datagram Protocol (UDP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter is SOCK_DGRAM.   IPPROTO_ICMPV6 58   The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6  and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.   IPPROTO_RM 113   The PGM protocol for reliable multicast. This is a possible value when the af parameter is AF_INET and the type parameter is SOCK_RDM. On the Windows SDK released for Windows Vista and later,  this protocol is also called IPPROTO_PGM.  This protocol value is only supported if the Reliable Multicast Protocol is installed."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  TransmitFile function transmits file data over a connected socket handle. This function uses the operating system's cache manager to retrieve the file data, and provides high-performance file data transfer over sockets.",
    "library": "Mswsock.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If the  TransmitFile function succeeds, the return value is TRUE. Otherwise, the return value is FALSE. To get extended error information, call  WSAGetLastError. An error code  of WSA_IO_PENDING or ERROR_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur. Applications should handle either ERROR_IO_PENDING or WSA_IO_PENDING in this case.  ",
    "remarks": "The TransmitFile function uses the operating system's cache manager to retrieve the file data, and provide high-performance file data transfer over sockets. The TransmitFile function only supports connection-oriented sockets of type SOCK_STREAM, SOCK_SEQPACKET, and SOCK_RDM. Sockets of type SOCK_DGRAM and SOCK_RAW are not supported. The TransmitPackets function can be used with sockets of type SOCK_DGRAM. The maximum number of bytes that can be transmitted using a single call to the TransmitFile function is 2,147,483,646, the maximum value for a 32-bit integer minus 1. The maximum number of bytes to send in a single call includes any  data sent before or after the file data pointed to by the lpTransmitBuffers parameter plus the value specified in the nNumberOfBytesToWrite parameter for the length of file data to send. If an application needs to transmit a file larger than 2,147,483,646 bytes, then multiple calls to the TransmitFile function can be used with each call transferring no more than 2,147,483,646 bytes. Setting the nNumberOfBytesToWrite parameter to zero for a file larger than 2,147,483,646 bytes will also fail since in this case the TransmitFile function will use the size of the file as the value for the number of bytes to transmit.  The TransmitFile function was primarily added to Winsock for use by high-performance server applications (web and ftp servers, for example). Workstation and client versions of Windows optimize the TransmitFile function for minimum memory and resource utilization by limiting the number of concurrent TransmitFile operations allowed on the system to a maximum of two. On Windows Vista,  Windows XP,   Windows 2000 Professional, and    Windows NT Workstation 3.51 and later only two outstanding TransmitFile requests are handled simultaneously; the third request will wait until one of the previous requests is completed. Server versions of Windows optimize the  TransmitFile function for high performance.  On server versions, there are no default limits placed on the number of concurrent TransmitFile operations allowed on the system. Expect better performance results when using  TransmitFile on server versions of Windows. On server versions of Windows, it is possible to set a limit on the maximum number of concurrent TransmitFile operations by creating a registry entry and setting a value for the following REG_DWORD:  HKEY_LOCAL_MACHINE\\CurrentControlSet\\Services\\AFD\\Parameters\\MaxActiveTransmitFileCount If the TransmitFile function is called with TCP socket (protocol of IPPROTO_TCP) with both the TF_DISCONNECT     and TF_REUSE_SOCKET flags specified, the call will not complete until the two following conditions are met. If the TransmitFile function is called with the lpOverlapped parameter set to NULL, the operation is executed as synchronous I/O. The function will not complete until the file has been sent. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. The  TransmitFile function allows the setting of two flags, TF_DISCONNECT or TF_REUSE_SOCKET, that return the socket to a \"disconnected, reusable\" state after the file has been transmitted. These flags should not be used on a socket where quality of service has been requested, since the service provider may immediately delete any quality of service associated with the socket before the file transfer has completed. The best approach for a QoS-enabled socket is to simply call the  closesocket function when the file transfer has completed, rather than relying on these flags. ",
    "return_type": "BOOL PASCAL",
    "category": "Windows Sockets (Winsock)",
    "name": "TransmitFile",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "SOCKET",
        "name": "hSocket",
        "description": "A handle to a connected socket. The  TransmitFile function will transmit the file data over this socket. The socket specified by the hSocket parameter must be a connection-oriented socket of type SOCK_STREAM, SOCK_SEQPACKET, or SOCK_RDM."
      },
      {
        "in_out": "",
        "type": "HANDLE",
        "name": "hFile",
        "description": "A handle to the open file that the  TransmitFile function transmits. Since the operating system reads the file data sequentially, you can improve caching performance by opening the handle with FILE_FLAG_SEQUENTIAL_SCAN.  The hFile parameter is optional. If the hFile parameter is NULL, only data in the header and/or the tail buffer is transmitted. Any additional action, such as socket disconnect or reuse, is performed as specified by the dwFlags parameter."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "nNumberOfBytesToWrite",
        "description": "The number of bytes in the file to transmit. The  TransmitFile function completes when it has sent the specified number of bytes, or when an error occurs, whichever occurs first.     Set this parameter to zero in order to transmit the entire file."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "nNumberOfBytesPerSend",
        "description": "The size, in bytes, of each block of data sent in each send operation. This parameter is used by Windows' sockets layer to determine the block size for send operations. To select the default send size, set this parameter to zero. The nNumberOfBytesPerSend parameter is useful for protocols that have limitations on the size of individual send requests."
      },
      {
        "in_out": "",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure. If the socket handle has been opened as overlapped, specify this parameter in order to achieve an overlapped (asynchronous) I/O operation. By default, socket handles are opened as overlapped.     You can use the lpOverlapped parameter to specify a 64-bit offset within the file at which to start the file data transfer by setting the Offset and OffsetHigh member of the OVERLAPPED structure. If lpOverlapped is a NULL pointer, the transmission of data always starts at the current byte offset in the file. When the lpOverlapped is not NULL, the overlapped I/O might not finish before  TransmitFile returns. In that case, the  TransmitFile function returns FALSE, and WSAGetLastError returns ERROR_IO_PENDING or WSA_IO_PENDING. This enables the caller to continue processing while the file transmission operation completes. Windows will set the event specified by the hEvent member of the OVERLAPPED structure, or the socket specified by hSocket, to the signaled state upon completion of the data transmission request."
      },
      {
        "in_out": "",
        "type": "LPTRANSMIT_FILE_BUFFERS",
        "name": "lpTransmitBuffers",
        "description": "A pointer to a  TRANSMIT_FILE_BUFFERS data structure that contains pointers to data to send before and after the file data is sent. This parameter should be set to a NULL pointer if you want to transmit only the file data."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of flags used to modify the behavior of the TransmitFile function call. The dwFlags parameter can contain a combination of the following options defined in the Mswsock.h header file:     FlagMeaning  TF_DISCONNECT   Start a transport-level disconnect after all the file data has been queued for transmission.   TF_REUSE_SOCKET   Prepare the socket handle to be reused. This flag is valid only if TF_DISCONNECT is also specified. When the TransmitFile request completes, the socket handle can be passed to the  function call previously used to establish the connection, such as AcceptEx  or ConnectEx. Such reuse is mutually exclusive; for example, if the AcceptEx function was called for the socket, reuse is allowed only for subsequent calls to the AcceptEx  function, and not allowed for a subsequent call to ConnectEx.  Note  The socket level file transmit is subject to the behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing  the TransmitFile call to be delayed.     TF_USE_DEFAULT_WORKER   Directs the Windows Sockets service provider to use the system's default thread to process long TransmitFile requests. The system default thread can be adjusted using the following registry parameter as a REG_DWORD:  HKEY_LOCAL_MACHINE\\CurrentControlSet\\Services\\AFD\\Parameters\\TransmitWorker   TF_USE_SYSTEM_THREAD   Directs the Windows Sockets service provider to use system threads to process long  TransmitFile requests.   TF_USE_KERNEL_APC   Directs the driver to use kernel asynchronous procedure calls (APCs) instead of worker threads to process long  TransmitFile requests. Long TransmitFile requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet. Use of TF_USE_KERNEL_APC can deliver significant performance benefits. It is possible (though unlikely), however, that the thread in which context  TransmitFile is initiated is being used for heavy computations; this situation may prevent APCs from launching. Note that the Winsock kernel mode driver uses normal kernel APCs, which launch whenever a thread is in a wait state, which differs from user-mode APCs, which launch whenever a thread is in an alertable wait state initiated in user mode).   TF_WRITE_BEHIND   Complete the  TransmitFile request immediately, without pending. If this flag is specified and  TransmitFile succeeds, then the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this setting with the TF_DISCONNECT and TF_REUSE_SOCKET flags. Note  If the file being sent is not in the file system cache, the request  pends."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 6,
    "description": "The  TransmitPackets function transmits in-memory data or file data over a connected socket. The  TransmitPackets function uses the operating system cache manager to retrieve file data, locking memory for the minimum time required to transmit and resulting in efficient, high-performance transmission.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If the  TransmitPackets function succeeds, the return value is TRUE. Otherwise, the return value is FALSE. To get extended error information, call  WSAGetLastError. An error code  of WSA_IO_PENDING or ERROR_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur. Applications should handle either ERROR_IO_PENDING or WSA_IO_PENDING in this case.  ",
    "remarks": "The  TransmitPackets function is optimized according to the operating system on which it is used:  The maximum number of bytes that can be transmitted using a single call to the TransmitPackets function is 2,147,483,646, the maximum value for a 32-bit integer minus 1. If an application needs to transmit data larger than 2,147,483,646 bytes, then multiple calls to the TransmitPackets function can be used with each call transferring no more than 2,147,483,646 bytes.  Expect better performance results when using the  TransmitPackets function on Windows Server 2003. When lpOverlapped is not NULL, overlapped I/O might not finish before the  TransmitPackets function returns. When this occurs, the  TransmitPackets function returns fails, and a call to the  WSAGetLastError function returns ERROR_IO_PENDING, allowing the caller to continue processing while the transmission completes. When the  TransmitPackets function returns TRUE or returns FALSE and  WSAGetLastError returns ERROR_IO_PENDING, Windows sets the event specified by the hEvent member of the  OVERLAPPED structure or the socket specified by hSocket to the signaled state, and upon completion, delivers notification to any completion port associated with the socket. Use  GetOverlappedResult, or  WSAGetOverlappedResult, or  GetQueuedCompletionStatus to retrieve final status and number of bytes transmitted. TransmitPackets and Asynchronous Procedure Calls (APCs) Use of the TF_USE_KERNEL_APC flag can deliver significant performance benefits. If the thread initiating the  TransmitPackets function call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL PASCAL",
    "category": "Windows Sockets (Winsock)",
    "name": "TransmitPackets",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "",
        "type": "SOCKET",
        "name": "hSocket",
        "description": "A handle to the connected socket to be used in the transmission. Although the socket does not need to be a connection-oriented circuit, the default destination/peer should have been established using the  connect,  WSAConnect,  accept,  WSAAccept,  AcceptEx, or  WSAJoinLeaf function."
      },
      {
        "in_out": "",
        "type": "LPTRANSMIT_PACKETS_ELEMENT",
        "name": "lpPacketArray",
        "description": "An array of type TRANSMIT_PACKETS_ELEMENT, describing the data to be transmitted."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "nElementCount",
        "description": "The number of elements in lpPacketArray."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "nSendSize",
        "description": "The size, in bytes, of the data block used in the  send operation. Set nSendSize to zero to let the sockets layer select a default  send size.     Setting nSendSize to 0xFFFFFFF enables the caller to control the size and content of each  send request, achieved by using the TP_ELEMENT_EOP flag in the  TRANSMIT_PACKETS_ELEMENT array pointed to in the lpPacketArray parameter. This capability is useful for message protocols that place limitations on the size of individual  send requests."
      },
      {
        "in_out": "",
        "type": "LPOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to an  OVERLAPPED structure. If the socket handle specified in the hSocket parameter has been opened as overlapped, use this parameter to achieve asynchronous (overlapped) I/O operation. Socket handles are opened as overlapped by default."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of flags used to customize processing of the  TransmitPackets function. The following table outlines the use of the dwFlags parameter.  ValueMeaning  TF_DISCONNECT   Starts a transport-level disconnect after all the file data has been queued for transmission. Applies only to connection-oriented sockets. Specifying this flag for sockets that do not support disconnect semantics (such as datagram sockets) results in an error.   TF_REUSE_SOCKET   Prepares the socket handle to be reused. When the  TransmitPackets function completes, the socket handle can be passed to the  AcceptEx function. Valid only when a connection-oriented socket and TF_DISCONNECT are specified. Note  The socket level packet transmit is subject to the behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing  the TransmitPackets call to be delayed.     TF_USE_DEFAULT_WORKER   Directs Winsock to use the system's default thread to process long  TransmitPackets requests. Long  TransmitPackets requests are defined as requests that require more than a single read from the file or a cache; the long request definition therefore depends on the size of the file and the specified length of the send packet.     The system default thread can be adjusted using the following registry parameter as a REG_DWORD:HKEY_LOCAL_MACHINE\\CurrentControlSet\\Services\\AFD\\Parameters\\TransmitWorker   TF_USE_SYSTEM_THREAD   Directs Winsock to use system threads to process long  TransmitPackets requests. Long  TransmitPackets requests are defined as requests that require more than a single read from the file or a cache; the long request definition therefore depends on the size of the file and the specified length of the send packet.   TF_USE_KERNEL_APC   Directs Winsock to use kernel  Asynchronous Procedure Calls (APCs) instead of worker threads to process long  TransmitPackets requests. Long  TransmitPackets requests are defined as requests that require more than a single read from the file or a cache; the long request definition therefore depends on the size of the file and the specified length of the send packet. See Remarks for more information."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAAccept function conditionally accepts a connection based on the return value of a condition function, provides quality of service flow specifications, and allows the transfer of connection data.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSAAccept returns a value of type SOCKET that is a descriptor for the accepted socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling  WSAGetLastError. The integer referred to by addrlen initially contains the amount of space pointed to by addr. On return it will contain the actual length in bytes of the address returned.  ",
    "remarks": "The  WSAAccept function extracts the first connection on the queue of pending connections on socket s, and checks it against the condition function, provided the condition function is specified (that is, not NULL). If the condition function returns CF_ACCEPT,  WSAAccept creates a new socket. The newly created socket has the same properties as socket s including asynchronous events registered with  WSAAsyncSelect or with  WSAEventSelect. If the condition function returns CF_REJECT,  WSAAccept rejects the connection request. The condition function runs in the same thread as this function does, and should return as soon as possible. If the decision cannot be made immediately, the condition function should return CF_DEFER to indicate that no decision has been made, and no action about this connection request should be taken by the service provider. When the application is ready to take action on the connection request, it will invoke  WSAAccept again and return either CF_ACCEPT or CF_REJECT as a return value from the condition function. A socket in default mode (blocking) will block until a connection is present when an application calls  WSAAccept and no connections are pending on the queue. A socket in nonblocking mode (blocking) fails with the error  WSAEWOULDBLOCK when an application calls  WSAAccept and no connections are pending on the queue. After  WSAAccept succeeds and returns a new socket handle, the accepted socket cannot be used to accept any more connections. The original socket remains open and listens for new connection requests. The addr parameter is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer. The exact format of the addr parameter is determined by the address family in which the communication is occurring. The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr. On return, it will contain the actual length (in bytes) of the address returned. This call is used with connection-oriented socket types such as SOCK_STREAM. If addr and/or addrlen are equal to NULL, then no information about the remote address of the accepted socket is returned. Otherwise, these two parameters will be filled in if the connection is successfully accepted. A prototype of the condition function is defined in the Winsock2.h header file as the LPCONDITIONPROC as follows: The ConditionFunc is a placeholder for the application-specified callback function. The actual condition function must reside in a DLL or application module. It is exported in the module definition file. The lpCallerId parameter points to a WSABUF structure that contains the address of the connecting entity, where its len parameter is the length of the buffer in bytes, and its buf parameter is a pointer to the buffer. The lpCallerData is a value parameter that contains any user data. The information in these parameters is sent along with the connection request. If no caller identification or caller data is available, the corresponding parameters will be NULL. Many network protocols do not support connect-time caller data. Most conventional network protocols can be expected to support caller identifier information at connection-request time. The buf portion of the  WSABUF pointed to by lpCallerId points to a  sockaddr. The sockaddr structure is interpreted according to its address family (typically by casting the sockaddr to some type specific to the address family). The lpSQOS parameter references the  FLOWSPEC structures for socket s specified by the caller, one for each direction, followed by any additional provider-specific parameters. The sending or receiving flow specification values will be ignored as appropriate for any unidirectional sockets. A NULL value indicates that there is no caller-supplied quality of service and that no negotiation is possible. A non-NULL lpSQOS pointer indicates that a quality of service negotiation is to occur or that the provider is prepared to accept the quality of service request without negotiation. The lpGQOS parameter is reserved, and should be NULL. (reserved for future use with socket groups) references the  FLOWSPEC structure for the socket group the caller is to create, one for each direction, followed by any additional provider-specific parameters. A NULL value for lpGQOS indicates no caller-specified group quality of service. Quality of service information can be returned if negotiation is to occur. The lpCalleeId is a parameter that contains the local address of the connected entity. The buf portion of the WSABUF pointed to by lpCalleeId points to a  sockaddr structure. The sockaddr structure is interpreted according to its address family (typically by casting the sockaddr to some type specific to the address family such as struct sockaddr_in). The lpCalleeData is a result parameter used by the condition function to supply user data back to the connecting entity. The lpCalleeData->len initially contains the length of the buffer allocated by the service provider and pointed to by lpCalleeData->buf. A value of zero means passing user data back to the caller is not supported. The condition function should copy up to lpCalleeData->len bytes of data into lpCalleeData->buf, and then update lpCalleeData->len to indicate the actual number of bytes transferred. If no user data is to be passed back to the caller, the condition function should set lpCalleeData->len to zero. The format of all address and user data is specific to the address family to which the socket belongs. The g parameter is assigned within the condition function to indicate any of the following actions: For unconstrained groups, any set of sockets can be grouped together as long as they are supported by a single service provider. A constrained socket group can consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host. For newly created socket groups, the new group identifier can be retrieved by using  getsockopt function with level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_ID.  A socket group     and its associated socket group ID remain valid until the last socket belonging to this     socket group is closed. Socket group IDs are unique across all processes     for a given service provider. A socket group and its associated identifier remain valid until the last socket belonging to this socket group is closed. Socket group identifiers are unique across all processes for a given service provider. For more information on socket groups, see the Remarks for the WSASocket functions. The dwCallbackData parameter value passed to the condition function is the value passed as the dwCallbackData parameter in the original  WSAAccept call. This value is interpreted only by the Windows Socket version 2 client. This allows a client to pass some context information from the  WSAAccept call site through to the condition function. This also provides the condition function with any additional information required to determine whether to accept the connection or not. A typical usage is to pass a (suitably cast) pointer to a data structure containing references to application-defined objects with which this socket is associated. The following example demonstrates the use of the WSAAccept function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "SOCKET",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAccept",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies a socket that is listening for connections after a call to the  listen function."
      },
      {
        "in_out": "_Out_",
        "type": "struct sockaddr*",
        "name": "addr",
        "description": "An optional pointer to an sockaddr structure that receives the address of the connecting entity, as known to the communications layer. The exact format of the addr parameter is determined by the address family established when the socket was created."
      },
      {
        "in_out": "_Inout_",
        "type": "LPINT",
        "name": "addrlen",
        "description": "An optional pointer to an integer that contains the length of the sockaddr structure pointed to by the addr parameter, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "LPCONDITIONPROC",
        "name": "lpfnCondition",
        "description": "The  address of an optional, application-specified condition function that will make an accept/reject decision based on the caller information passed in as parameters, and optionally create or join a socket group by assigning an appropriate value to the result parameter g of this function. If this parameter is NULL, then no condition function is called."
      },
      {
        "in_out": "_In_",
        "type": "DWORD_PTR",
        "name": "dwCallbackData",
        "description": "Callback data passed back to the application-specified condition function as the value of the dwCallbackData parameter passed to the condition function. This parameter is only applicable if the lpfnCondition parameter is not NULL. This parameter is not interpreted by Windows Sockets."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAAddressToString function converts all components of a  sockaddr structure into a human-readable string representation of the address.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSAAddressToString returns a value of zero. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAAddressToString function provides a protocol-independent address-to-string translation. The  WSAAddressToString function takes a socket address structure pointed to by the lpsaAddress parameter and returns a pointer to NULL-terminated string that represents the socket address in the lpszAddressString parameter. While the inet_ntoa function works only with IPv4 addresses, the WSAAddressToString function works with any socket address supported by a Winsock provider on the local computer including IPv6 addresses. If the lpsaAddress parameter points to an IPv4 socket address (the address family is  AF_INET), then the address string returned in the buffer pointed to by the lpszAddressString parameter is  in dotted-decimal notation as in \"192.168.16.0\", an example of an IPv4 address in dotted-decimal notation. If the lpsaAddress parameter points to an IPv6 socket address (the address family is  AF_INET6), then the address string returned in the buffer pointed to by the lpszAddressString parameter is  in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. If the length of the buffer pointed to by the lpszAddressString parameter is not large enough to receive the string representation of the socket address, WSAAddressToString returns  \t\t\t\t\t\t\t\tWSAEFAULT. Support for IPv6 addresses using the WSAAddressToString function was added on Windows XP with Service Pack 1 (SP1)   and later. IPv6 must also be installed on the local computer for the WSAAddressToString function to support IPv6 addresses. Windows Phone 8: The WSAAddressToStringW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSAAddressToStringW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAddressToString",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPSOCKADDR",
        "name": "lpsaAddress",
        "description": "A pointer to the  sockaddr structure to translate into a string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwAddressLength",
        "description": "The length, in bytes, of the address in the sockaddr structure pointed to by the lpsaAddress parameter. The dwAddressLength parameter may vary in size with different protocols."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAPROTOCOL_INFO",
        "name": "lpProtocolInfo",
        "description": "A pointer to the  WSAPROTOCOL_INFO structure for a particular provider. If this is parameter is NULL, the call is routed to the provider of the first protocol supporting the address family indicated in the lpsaAddress parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "LPTSTR",
        "name": "lpszAddressString",
        "description": "A pointer to the buffer that receives the human-readable address string."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwAddressStringLength",
        "description": "On input, this parameter specifies the length of the buffer pointed to by the lpszAddressString parameter. The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the string including the NULL terminator actually copied into the buffer pointed to by the lpszAddressString parameter. If the specified buffer is not large enough, the function fails with a specific error of  WSAEFAULT and this parameter is updated with the required size."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  WSAAsyncGetHostByAddr function asynchronously retrieves host information that corresponds to an address.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself. If no error occurs,  WSAAsyncGetHostByAddr returns a nonzero value of type HANDLE that is the asynchronous task handle (not to be confused with a Windows HTASK) for the request. This value can be used in two ways. It can be used to cancel the operation using  WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages by examining the wParam message parameter. If the asynchronous operation could not be initiated,  WSAAsyncGetHostByAddr returns a zero value, and a specific error number can be retrieved by calling  WSAGetLastError. The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.   The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.  ",
    "remarks": "The  WSAAsyncGetHostByAddr function is an asynchronous version of  gethostbyaddr. It is used to retrieve the host name and address information that corresponds to a network address. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window. When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation. On successful completion, the buffer specified to the original function call contains a  hostent structure. To access the members of this structure, the original buffer address is cast to a  hostent structure pointer and accessed as appropriate. If the error code is  WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the  WSAAsyncGetHostByAddr function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam). The buffer specified to this function is used by Windows Sockets to construct a structure together with the contents of data areas referenced by members of the same  hostent structure. To avoid the  WSAENOBUFS error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h). The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as: The use of these macros will maximize the portability of the source code for the application. ",
    "return_type": "HANDLE",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAsyncGetHostByAddr",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle of the window that will receive a message when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "unsigned int",
        "name": "wMsg",
        "description": "Message to be received when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "addr",
        "description": "Pointer to the network address for the host. Host addresses are stored in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "len",
        "description": "Length of the address, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "type",
        "description": "Type of the address."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "Pointer to the data area to receive the  hostent data. The data area must be larger than the size of a  hostent structure because the data area is used by Windows Sockets to contain a  hostent structure and all of the data referenced by members of the  hostent structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "buflen",
        "description": "Size of data area for the buf parameter, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAAsyncGetHostByName function asynchronously retrieves host information that corresponds to a host name.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself. If no error occurs,  WSAAsyncGetHostByName returns a nonzero value of type HANDLE that is the asynchronous task handle (not to be confused with a Windows HTASK) for the request. This value can be used in two ways. It can be used to cancel the operation using  WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages by examining the wParam message parameter. If the asynchronous operation could not be initiated,  WSAAsyncGetHostByName returns a zero value, and a specific error number can be retrieved by calling  WSAGetLastError. The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.  The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.  ",
    "remarks": "The  WSAAsyncGetHostByName function is an asynchronous version of  gethostbyname, and is used to retrieve host name and address information corresponding to a host name. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque asynchronous task handle that which the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window. When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation. On successful completion, the buffer specified to the original function call contains a  hostent structure. To access the elements of this structure, the original buffer address should be cast to a  hostent structure pointer and accessed as appropriate. If the error code is  WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the  WSAAsyncGetHostByName function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam). The buffer specified to this function is used by Windows Sockets to construct a  hostent structure together with the contents of data areas referenced by members of the same  hostent structure. To avoid the  WSAENOBUFS error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h). The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as: The use of these macros will maximize the portability of the source code for the application. WSAAsyncGetHostByName is guaranteed to resolve the string returned by a successful call to  gethostname. ",
    "return_type": "HANDLE",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAsyncGetHostByName",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle of the window that will receive a message when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "unsigned int",
        "name": "wMsg",
        "description": "Message to be received when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "name",
        "description": "Pointer to the null-terminated name of the host."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "Pointer to the data area to receive the  hostent data. The data area must be larger than the size of a  hostent structure because the specified data area is used by Windows Sockets to contain a  hostent structure and all of the data referenced by members of the  hostent structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "buflen",
        "description": "Size of data area for the buf parameter, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAAsyncGetProtoByName function asynchronously retrieves protocol information that corresponds to a protocol name.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself. If no error occurs,  WSAAsyncGetProtoByName returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using  WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by examining the wParam message parameter. If the asynchronous operation could not be initiated,  WSAAsyncGetProtoByName returns a zero value, and a specific error number can be retrieved by calling  WSAGetLastError. The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.  The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.  ",
    "remarks": "The  WSAAsyncGetProtoByName function is an asynchronous version of  getprotobyname. It is used to retrieve the protocol name and number from the Windows Sockets database corresponding to a given protocol name. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window. When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation. On successful completion, the buffer specified to the original function call contains a  protoent structure. To access the members of this structure, the original buffer address should be cast to a  protoent structure pointer and accessed as appropriate. If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the  WSAAsyncGetProtoByName function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam). The buffer specified to this function is used by Windows Sockets to construct a  protoent structure together with the contents of data areas referenced by members of the same  protoent structure. To avoid the  WSAENOBUFS error noted above, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h). The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as: The use of these macros will maximize the portability of the source code for the application. ",
    "return_type": "HANDLE",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAsyncGetProtoByName",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle of the window that will receive a message when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "unsigned int",
        "name": "wMsg",
        "description": "Message to be received when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "name",
        "description": "Pointer to the null-terminated protocol name to be resolved."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "Pointer to the data area to receive the  protoent data. The data area must be larger than the size of a  protoent structure because the data area is used by Windows Sockets to contain a  protoent structure and all of the data that is referenced by members of the  protoent structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended."
      },
      {
        "in_out": "_Out_",
        "type": "int",
        "name": "buflen",
        "description": "Size of data area for the buf parameter, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAAsyncGetProtoByNumber function asynchronously retrieves protocol information that corresponds to a protocol number.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself. If no error occurs,  WSAAsyncGetProtoByNumber returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using  WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by examining the wParam message parameter. If the asynchronous operation could not be initiated,  WSAAsyncGetProtoByNumber returns a zero value, and a specific error number can be retrieved by calling  WSAGetLastError. The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.  The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.  ",
    "remarks": "The  WSAAsyncGetProtoByNumber function is an asynchronous version of  getprotobynumber, and is used to retrieve the protocol name and number corresponding to a protocol number. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window. When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation. On successful completion, the buffer specified to the original function call contains a  protoent structure. To access the members of this structure, the original buffer address is cast to a  protoent structure pointer and accessed as appropriate. If the error code is  WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the  WSAAsyncGetProtoByNumber function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam). The buffer specified to this function is used by Windows Sockets to construct a  protoent structure together with the contents of data areas referenced by members of the same  protoent structure. To avoid the WSAENOBUFS error noted above, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h). The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as: The use of these macros will maximize the portability of the source code for the application. ",
    "return_type": "HANDLE",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAsyncGetProtoByNumber",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle of the window that will receive a message when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "unsigned int",
        "name": "wMsg",
        "description": "Message to be received when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "number",
        "description": "Protocol number to be resolved, in host byte order."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "Pointer to the data area to receive the  protoent data. The data area must be larger than the size of a  protoent structure because the data area is used by Windows Sockets to contain a  protoent structure and all of the data that is referenced by members of the  protoent structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "buflen",
        "description": "Size of data area for the buf parameter, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The  WSAAsyncGetServByName function asynchronously retrieves service information that corresponds to a service name and port.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself. If no error occurs,  WSAAsyncGetServByName returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using  WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by examining the wParam message parameter. If the asynchronous operation could not be initiated, WSAAsyncServByName returns a zero value, and a specific error number can be retrieved by calling  WSAGetLastError. The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.  The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.  ",
    "remarks": "The  WSAAsyncGetServByName function is an asynchronous version of  getservbyname and is used to retrieve service information corresponding to a service name. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window. When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation. On successful completion, the buffer specified to the original function call contains a  servent structure. To access the members of this structure, the original buffer address should be cast to a  servent structure pointer and accessed as appropriate. If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the  WSAAsyncGetServByName function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam). The buffer specified to this function is used by Windows Sockets to construct a  servent structure together with the contents of data areas referenced by members of the same  servent structure. To avoid the WSAENOBUFS error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h). The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as: The use of these macros will maximize the portability of the source code for the application. ",
    "return_type": "HANDLE",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAsyncGetServByName",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle of the window that should receive a message when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "unsigned int",
        "name": "wMsg",
        "description": "Message to be received when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "name",
        "description": "Pointer to a null-terminated service name."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "proto",
        "description": "Pointer to a protocol name. This can be NULL, in which case  WSAAsyncGetServByName will search for the first service entry for which s_name or one of the s_aliases matches the given name. Otherwise,  WSAAsyncGetServByName matches both name and proto."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "Pointer to the data area to receive the  servent data. The data area must be larger than the size of a  servent structure because the data area is used by Windows Sockets to contain a  servent structure and all of the data that is referenced by members of the  servent structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "buflen",
        "description": "Size of data area for the buf parameter, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The  WSAAsyncGetServByPort function asynchronously retrieves service information that corresponds to a port and protocol.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself. If no error occurs,  WSAAsyncGetServByPort returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using  WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by examining the wParam message parameter. If the asynchronous operation could not be initiated,  WSAAsyncGetServByPort returns a zero value, and a specific error number can be retrieved by calling  WSAGetLastError. The following error codes can be set when an application window receives a message. As described above, they can be extracted from the lParam in the reply message using the WSAGETASYNCERROR macro.  The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.  ",
    "remarks": "The  WSAAsyncGetServByPort function is an asynchronous version of  getservbyport, and is used to retrieve service information corresponding to a port number. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window. When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation. On successful completion, the buffer specified to the original function call contains a  servent structure. To access the members of this structure, the original buffer address should be cast to a  servent structure pointer and accessed as appropriate. If the error code is  WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the  WSAAsyncGetServByPort function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of lParam). The buffer specified to this function is used by Windows Sockets to construct a  servent structure together with the contents of data areas referenced by members of the same  servent structure. To avoid the  WSAENOBUFS error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h). The error code and buffer length should be extracted from the lParam using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in Winsock2.h as: The use of these macros will maximize the portability of the source code for the application. ",
    "return_type": "HANDLE",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAsyncGetServByPort",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "Handle of the window that should receive a message when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "unsigned int",
        "name": "wMsg",
        "description": "Message to be received when the asynchronous request completes."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "port",
        "description": "Port for the service, in network byte order."
      },
      {
        "in_out": "_In_",
        "type": "const char*",
        "name": "proto",
        "description": "Pointer to a protocol name. This can be NULL, in which case  WSAAsyncGetServByPort will search for the first service entry for which s_port match the given port. Otherwise,  WSAAsyncGetServByPort matches both port and proto."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "Pointer to the data area to receive the  servent data. The data area must be larger than the size of a  servent structure because the data area is used by Windows Sockets to contain a  servent structure and all of the data that is referenced by members of the  servent structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "buflen",
        "description": "Size of data area for the buf parameter, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "[The WSAAsyncSelect function is available for use in the operating systems specified in the Requirements section. It may be altered or unavailable in subsequent versions. Rather than use Select-style I/O, use Overlapped I/O and Event Objects with WinSock2.]",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "If the  WSAAsyncSelect function succeeds, the return value is zero, provided that the application's declaration of interest in the network event set was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  Additional error codes can be set when an application window receives a message. This error code is extracted from the lParam in the reply message using the WSAGETSELECTERROR macro. Possible error codes for each network event are listed in the following table. Event: FD_CONNECT  Event: FD_CLOSE   Event: FD_ROUTING_INTERFACE_CHANGE  ",
    "remarks": "The  WSAAsyncSelect function is used to request that WS2_32.DLL should send a message to the window hWnd when it detects any network event specified by the lEvent parameter. The message that should be sent is specified by the wMsg parameter. The socket for which notification is required is identified by the s parameter. The WSAAsyncSelect function automatically sets socket s to nonblocking mode, regardless of the value of lEvent. To set socket s back to blocking mode, it is first necessary to clear the event record associated with socket s via a call to WSAAsyncSelect with lEvent set to zero. You can then call ioctlsocket or WSAIoctl to set the socket back to blocking mode.  For more information about how to set the nonblocking socket back to blocking mode, see the ioctlsocket and WSAIoctl functions. The lEvent parameter is constructed by using the bitwise OR operator with any value listed in the following table.  Issuing a  WSAAsyncSelect for a socket cancels any previous  WSAAsyncSelect or  WSAEventSelect for the same socket. For example, to receive notification for both reading and writing, the application must call  WSAAsyncSelect with both FD_READ and FD_WRITE, as follows: It is not possible to specify different messages for different events. The following code will not work; the second call will cancel the effects of the first, and only FD_WRITE events will be reported with message wMsg2: To cancel all notification indicating that Windows Sockets should send no further messages related to network events on the socket, lEvent is set to zero. Although  WSAAsyncSelect immediately disables event message posting for the socket in this instance, it is possible that messages could be waiting in the application message queue. Therefore, the application must be prepared to receive network event messages even after cancellation. Closing a socket with  closesocket also cancels  WSAAsyncSelect message sending, but the same caveat about messages in the queue still applies. The socket created by the  accept function has the same properties as the listening socket used to accept it. Consequently,  WSAAsyncSelect events set for the listening socket also apply to the accepted socket. For example, if a listening socket has  WSAAsyncSelect events FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE events with the same wMsg value used for messages. If a different wMsg or events are desired, the application should call  WSAAsyncSelect, passing the accepted socket and the desired new data. When one of the nominated network events occurs on the specified socket s, the application window hWnd receives message wMsg. The wParam parameter identifies the socket on which a network event has occurred. The low word of lParam specifies the network event that has occurred. The high word of lParam contains any error code. The error code be any error as defined in Winsock2.h. The error and event codes can be extracted from the lParam using the macros WSAGETSELECTERROR and WSAGETSELECTEVENT, defined in Winsock2.h as: The use of these macros will maximize the portability of the source code for the application. The possible network event codes that can be returned are listed in the following table.  Although  WSAAsyncSelect can be called with interest in multiple events, the application window will receive a single message for each network event. As in the case of the  select function,  WSAAsyncSelect will frequently be used to determine when a data transfer operation (send or  recv) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for the possibility that it can receive a message and issue a Windows Sockets 2 call that returns  WSAEWOULDBLOCK immediately. For example, the following sequence of events is possible: Other sequences are also possible. The WS2_32.DLL will not continually flood an application with messages for a particular network event. Having successfully posted notification of a particular event to an application window, no further message(s) for that network event will be posted to the application window until the application makes the function call that implicitly reenables notification of that network event.  Any call to the reenabling routine, even one that fails, results in reenabling of message posting for the relevant event. For FD_READ, FD_OOB, and FD_ACCEPT events, message posting is level-triggered. This means that if the reenabling routine is called and the relevant condition is still met after the call, a  WSAAsyncSelect message is posted to the application. This allows an application to be event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following sequence: With these semantics, an application need not read all available data in response to an FD_READ message\u00e2\u0080\u0094a single  recv in response to each FD_READ message is appropriate. If an application issues multiple  recv calls in response to a single FD_READ, it can receive multiple FD_READ messages. Such an application can require disabling FD_READ messages before starting the  recv calls by calling  WSAAsyncSelect with the FD_READ event not set. The FD_QOS and FD_GROUP_QOS events are considered edge triggered. A message will be posted exactly once when a quality of service change occurs. Further messages will not be forthcoming until either the provider detects a further change in quality of service or the application renegotiates the quality of service for the socket. The FD_ROUTING_INTERFACE_CHANGE message is posted when the local interface that should be used to reach the destination specified in  WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE changes after such IOCTL has been issued. The FD_ADDRESS_LIST_CHANGE message is posted when the list of addresses to which the application can bind changes after  WSAIoctl with SIO_ADDRESS_LIST_CHANGE has been issued. If any event has occurred when the application calls  WSAAsyncSelect or when the reenabling function is called, then a message is posted as appropriate. For example, consider the following sequence: The FD_WRITE event is handled slightly differently. An FD_WRITE message is posted when a socket is first connected with  connect or  WSAConnect (after FD_CONNECT, if also registered) or accepted with  accept or  WSAAccept, and then after a send operation fails with WSAEWOULDBLOCK and buffer space becomes available. Therefore, an application can assume that sends are possible starting from the first FD_WRITE message and lasting until a send returns WSAEWOULDBLOCK. After such a failure the application will be notified that sends are again possible with an FD_WRITE message. The FD_OOB event is used only when a socket is configured to receive OOB data separately. If the socket is configured to receive OOB data inline, the OOB (expedited) data is treated as normal data and the application should register an interest in, and will receive, FD_READ events, not FD_OOB events. An application can set or inspect the way in which OOB data is to be handled by using  setsockopt or  getsockopt for the SO_OOBINLINE option. The error code in an FD_CLOSE message indicates whether the socket close was graceful or abortive. If the error code is zero, then the close was graceful; if the error code is  WSAECONNRESET, then the socket's virtual circuit was reset. This only applies to connection-oriented sockets such as SOCK_STREAM. The FD_CLOSE message is posted when a close indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the FD_CLOSE is posted when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the remote end performing a  shutdown on the send side or a  closesocket. FD_CLOSE should only be posted after all data is read from a socket, but an application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing data. Be aware that the application will only receive an FD_CLOSE message to indicate closure of a virtual circuit, and only when all the received data has been read if this is a graceful close. It will not receive an FD_READ message to indicate this condition. The FD_QOS or FD_GROUP_QOS message is posted when any parameter in the flow specification associated with socket s or the socket group that s belongs to has changed, respectively. Applications should use  WSAIoctl with command SIO_GET_QOS or SIO_GET_GROUP_QOS to get the current quality of service for socket s or for the socket group s belongs to, respectively. The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered edge triggered as well. A message will be posted exactly once when a change occurs after the application has requested the notification by issuing  WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE correspondingly. Further messages will not be forthcoming until the application reissues the IOCTL and another change is detected because the IOCTL has been issued. Here is a summary of events and conditions for each asynchronous notification message. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAAsyncSelect",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies the socket for which event notification is required."
      },
      {
        "in_out": "_In_",
        "type": "HWND",
        "name": "hWnd",
        "description": "A handle that identifies the window that will receive a message when a network event occurs."
      },
      {
        "in_out": "_In_",
        "type": "unsigned int",
        "name": "wMsg",
        "description": "A message to be received when a network event occurs."
      },
      {
        "in_out": "_In_",
        "type": "long",
        "name": "lEvent",
        "description": "A bitmask that specifies a combination of network events in which the application is interested."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSACancelAsyncRequest function cancels an incomplete asynchronous operation.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The value returned by  WSACancelAsyncRequest is zero if the operation was successfully canceled. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSACancelAsyncRequest function is used to cancel an asynchronous operation that was initiated by one of the WSAAsyncGetXByY functions such as  WSAAsyncGetHostByName. The operation to be canceled is identified by the hAsyncTaskHandle parameter, which should be set to the asynchronous task handle as returned by the initiating WSAAsyncGetXByY function. An attempt to cancel an existing asynchronous WSAAsyncGetXByY operation can fail with an error code of  WSAEALREADY for two reasons. First, the original operation has already completed and the application has dealt with the resultant message. Second, the original operation has already completed but the resultant message is still waiting in the application window queue. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSACancelAsyncRequest",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hAsyncTaskHandle",
        "description": "Handle that specifies the asynchronous operation to be canceled."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "The  WSACleanup function terminates use of the Winsock 2 DLL (Ws2_32.dll).",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError. In a multithreaded environment,  WSACleanup terminates Windows Sockets operations for all threads.  ",
    "remarks": "An application or DLL is required to perform a successful  WSAStartup call before it can use Windows Sockets services. When it has completed the use of Windows Sockets, the application or DLL must call  WSACleanup to deregister itself from a Windows Sockets implementation and allow the implementation to free any resources allocated on behalf of the application or DLL. When WSACleanup is called, any pending blocking or asynchronous Windows Sockets calls issued by any thread in this process are canceled without posting any notification messages or without signaling any event objects. Any pending overlapped send or receive operations (WSASend, WSASendTo, WSARecv, or WSARecvFrom with an overlapped socket, for example) issued by any thread in this process are also canceled without setting the event object or invoking the completion routine, if one was specified. In this case, the pending overlapped operations fail with the error status WSA_OPERATION_ABORTED. Sockets that were open when  WSACleanup was called are reset and automatically deallocated as if  closesocket were called. Sockets that have been closed with  closesocket but that still have pending data to be sent can be affected when  WSACleanup is called. In this case, the pending data can be lost if the WS2_32.DLL is unloaded from memory as the application exits. To ensure that all pending data is sent, an application should use  shutdown to close the connection, then wait until the close completes before calling  closesocket and  WSACleanup. All resources and internal state, such as queued unposted or posted messages, must be deallocated so as to be available to the next user. There must be a call to  WSACleanup for each successful call to  WSAStartup. Only the final  WSACleanup function call performs the actual cleanup. The preceding calls simply decrement an internal reference count in the WS2_32.DLL. In  Windows Sockets 1.1, attempting to call  WSACleanup from within a blocking hook and then failing to check the return code was a common programming error. If a Winsock 1.1 application needs to quit while a blocking call is outstanding, the application has to first cancel the blocking call with  WSACancelBlockingCall then issue the  WSACleanup call once control has been returned to the application. In Windows Sockets 2, this issue does not exist and the WSACancelBlockingCall function has been removed. The  WSACleanup function typically leads to protocol-specific helper DLLs being unloaded. As a result, the  WSACleanup function should not be called from the DllMain function in a application DLL. This can potentially cause deadlocks. For more information, please see the DLL Main Function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSACleanup",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSACloseEvent function closes an open event object handle.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. To get extended error information, call  WSAGetLastError.  ",
    "remarks": "The  WSACloseEvent function closes the handle to an event object and frees resources associated with the event object. This function is used to close a handle created by the WSACreateEvent \t\t\tfunction. Once the handle to the  event object is closed, further references to this handle will fail with the error  WSA_INVALID_HANDLE. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "WSACloseEvent",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WSAEVENT",
        "name": "hEvent",
        "description": "Object handle identifying the open event."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The  WSAConnect function establishes a connection to another socket application, exchanges connect data, and specifies required quality of service based on the specified  FLOWSPEC structure.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSAConnect returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling  WSAGetLastError. On a blocking socket, the return value indicates success or failure of the connection attempt. With a nonblocking socket, the connection attempt cannot be completed immediately. In this case,  WSAConnect will return SOCKET_ERROR, and  WSAGetLastError will return  WSAEWOULDBLOCK; the application could therefore: For a nonblocking socket, until the connection attempt completes all subsequent calls to  WSAConnect on the same socket will fail with the error code  WSAEALREADY. If the return error code indicates the connection attempt failed (that is,  WSAECONNREFUSED,  WSAENETUNREACH,  WSAETIMEDOUT) the application can call  WSAConnect again for the same socket.  ",
    "remarks": "The  WSAConnect function is used to create a connection to the specified destination, and to perform a number of other ancillary operations that occur at connect time. If the socket, s, is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound. For applications targeted to Windows Vista and later, consider using the WSAConnectByList or WSAConnectByName function which greatly simplify client application design. For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using name (an address in the namespace of the socket; for a detailed description, please see  bind). When this call completes successfully, the socket is ready to send/receive data. If the address parameter of the name structure is all zeroes,  WSAConnect will return the error  WSAEADDRNOTAVAIL. Any attempt to reconnect an active connection will fail with the error code  WSAEISCONN. For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such cases, this function returns the error  WSAEWOULDBLOCK. However, the operation proceeds. When the success or failure outcome becomes known, it may be reported in one of several ways depending on how the client registers for notification. If the client uses  select, success is reported in the writefds set and failure is reported in the exceptfds set. If the client uses  WSAAsyncSelect or  WSAEventSelect, the notification is announced with FD_CONNECT and the error code associated with the FD_CONNECT indicates either success or a specific reason for failure. For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by  WSAConnect is merely to establish a default destination address so that the socket can be used on subsequent connection-oriented send and receive operations (send,  WSASend,  recv, and  WSARecv). Any datagrams received from an address other than the destination address specified will be discarded. If the entire name structure is all zeros (not just the address parameter of the name structure), then the socket will be disconnected. Then, the default remote address will be indeterminate, so send, WSASend, recv, and WSARecv calls will return the error code  WSAENOTCONN. However,  sendto, \t\t\t\tWSASendTo, recvfrom, and  \t\t\t\tWSARecvFrom can still be used. The default destination can be changed by simply calling  WSAConnect again, even if the socket is already connected. Any datagrams queued for receipt are discarded if name is different from the previous  WSAConnect. For connectionless sockets, name can indicate any valid address, including a broadcast address. However, to connect to a broadcast address, a socket must have  setsockopt SO_BROADCAST enabled. Otherwise,  WSAConnect will fail with the error code  WSAEACCES. On connectionless sockets, exchange of user-to-user data is not possible and the corresponding parameters will be silently ignored. The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies. The lpCallerData parameter contains a pointer to any user data that is to be sent along with the connection request (called connect data). This is additional data, not in the normal network data stream, that is sent with network requests to establish a connection. This option is used by legacy protocols such as DECNet, OSI TP4, and others. If lpCallerData is NULL, no user data will be passed to the peer. The lpCalleeData is a result parameter that will contain any user data passed back from the other socket as part of the connection establishment in a  WSABUF structure. The len member of the WSABUF structure pointed to by the lpCalleeData parameter initially contains the length of the buffer allocated by the application for the buf member of the WSABUF structure. The len member of the WSABUF structure pointed to by the lpCalleeData parameter will be set to zero if no user data has been passed back. The lpCalleeData information will be valid when the connection operation is complete. For blocking sockets, the connection operation completes when the  WSAConnect function returns. For nonblocking sockets, completion will be after the FD_CONNECT notification has occurred. If lpCalleeData is NULL, no user data will be passed back. The exact format of the user data is specific to the address family to which the socket belongs. At connect time, an application can use the lpSQOS and lpGQOS parameter to override any previous quality of service specification made for the socket through  WSAIoctl with either the SIO_SET_QOS or SIO_SET_GROUP_QOS opcode. The lpSQOS parameter specifies the  FLOWSPEC structures for socket s, one for each direction, followed by any additional provider-specific parameters. If either the associated transport provider in general or the specific type of socket in particular cannot honor the quality of service request, an error will be returned as indicated in the following. The sending or receiving flow specification values will be ignored, respectively, for any unidirectional sockets. If no provider-specific parameters are specified, the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter  should be set to NULL and zero, respectively. A NULL value for lpSQOS parameter indicates no application-supplied quality of service. Reserved for future use with socket groups lpGQOS specifies the FLOWSPEC structures for the socket group (if applicable), one for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are specified, the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter   should be set to NULL and zero, respectively. A NULL value for lpGQOS indicates no application-supplied group quality of service. This parameter will be ignored if s is not the creator of the socket group. When connected sockets become closed for whatever reason, they should be discarded and recreated. It is safest to assume that when things go awry for any reason on a connected socket, the application must discard and recreate the needed sockets in order to return to a stable point. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAConnect",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying an unconnected socket."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "name",
        "description": "A pointer to a sockaddr structure  that specifies the address to which to connect. For  IPv4, the sockaddr contains AF_INET for the address family, the destination IPv4 address, and the destination port. For  IPv6, the sockaddr structure contains AF_INET6 for the address family, the destination IPv6 address, the destination port, and may contain additional flow and scope-id information."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "namelen",
        "description": "The length, in bytes, of the sockaddr structure pointed to by the name parameter."
      },
      {
        "in_out": "_In_",
        "type": "LPWSABUF",
        "name": "lpCallerData",
        "description": "A pointer to the user data that is to be transferred to the other socket during connection establishment. See Remarks."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSABUF",
        "name": "lpCalleeData",
        "description": "A pointer to the user data that is to be transferred back from the other socket during connection establishment. See Remarks."
      },
      {
        "in_out": "_In_",
        "type": "LPQOS",
        "name": "lpSQOS",
        "description": "A pointer to the FLOWSPEC structures for socket s, one for each direction."
      },
      {
        "in_out": "_In_",
        "type": "LPQOS",
        "name": "lpGQOS",
        "description": "Reserved for future use with socket groups. A pointer to the  FLOWSPEC structures for the socket group (if applicable). This parameter should be NULL."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "The WSAConnectByList function     establishes a connection to one out of a collection of possible endpoints represented by a set of     destination addresses (host names and ports). This function takes all the destination addresses passed     to it and all of the local computer's source addresses, and tries connecting using all possible address     combinations before giving up.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If a connection is established,         WSAConnectByList returns TRUE and         LocalAddress and RemoteAddress parameters are filled in if         these buffers were supplied by the caller. If the call fails, FALSE is returned.         WSAGetLastError can then be called to get         extended error information.  ",
    "remarks": "WSAConnectByList is similar to the       WSAConnectByName function.  Instead of taking a       single host name and service name (port),       WSAConnectByList takes a list of addresses (host       addresses and ports) and connects to one of the addresses. The       WSAConnectByList function is designed to support       peer-to-peer collaboration scenarios where an application needs to connect to any available node out of a list of       potential nodes. WSAConnectByList is compatible       with both IPv6 and IPv4 versions. The set of possible destinations, represented by a list of addresses, is       provided by the caller. WSAConnectByList does       more than simply attempt to connect to one of possibly many destination addresses.  Specifically, the function       takes all remote addresses passed in by the caller, all local addresses, and then attempts a connection first       using address pairs with the highest chance of success. As such,       WSAConnectByList not only ensures that connection       will be established if a connection is at all possible, but also minimizes the time to establish the       connection. The caller can specify the LocalAddress and RemoteAddress       buffers and lengths to determine the local and remote addresses for which the connection was successfully       established. The timeout parameter allows the caller to limit the time spent by the function in       establishing a connection. Internally,       WSAConnectByList performs multiple operations       (connection attempts).  In between each operation, the timeout parameter is checked to       see if the timeout has been exceeded and, if so, the call is aborted. Note that an       individual operation (connect) will not be interrupted once the timeout is exceeded,       so the WSAConnectByList call can take longer to       time out than the value specified in the timeout parameter. WSAConnectByList has limitations: It works only       for connection-oriented sockets, such as those of type SOCK_STREAM. The function does not support overlapped I/O       or non-blocking behavior. WSAConnectByList will       block even if the socket is in non-blocking mode.       WSAConnectByList will try connecting (one-by-one)       to the various addresses provided by the caller. Potentially, each of these connection attempts may fail with a       different error code. Since only a single error code can be returned, the value returned is the error code from       the last connection attempt. To enable both IPv6 and IPv4 addresses to be passed in the single address list accepted by the function, the       following steps must be performed prior to calling the function: The arrays of pointers passed in the SocketAddressList parameter point to an array of       SOCKET_ADDRESS  structures, which are a generic       data type. The RemoteAddress and the LocalAddress       parameters also point to SOCKADDR  structures. When       WSAConnectByList is called, it is expected that       a socket address type specific to the network protocol or address family being used will actually be passed in       these parameters. So for IPv4 addresses, a pointer to a sockaddr_in structure       would be cast to a pointer to SOCKADDR when passed as a parameter. For IPv6       addresses, a pointer to a sockaddr_in6 structure would be cast to a pointer to       SOCKADDR when passed as a parameter. The       SocketAddressList parameter can contain pointers to a mixture of IPv4 and IPv6       addresses. So some SOCKET_ADDRESS pointers can be       to sockaddr_in structures and others can be to       sockaddr_in6 structures. If it is expected that IPv6 addresses can be used, then       the RemoteAddress and LocalAddress parameters should point       to sockaddr_in6 structures and be cast to SOCKADDR       structures. The RemoteAddressLength and the       LocalAddressLength parameters must represent the length of these larger       structures. When the  WSAConnectByList function returns TRUE, the socket s is in the default state for a connected socket. The socket s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the  setsockopt function to set the SO_UPDATE_CONNECT_CONTEXT option. For example: Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. Establish a connection using WSAConnectByList. ",
    "return_type": "BOOL PASCAL",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAConnectByList",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies an unbound and unconnected socket. Note that unlike other Winsock calls to        establish a connection (for example, WSAConnect),        the WSAConnectByList function requires an        unbound socket."
      },
      {
        "in_out": "_In_",
        "type": "PSOCKET_ADDRESS_LIST",
        "name": "SocketAddressList",
        "description": "A pointer to a SOCKET_ADDRESS_LIST        structure that represents the possible destination address and port pairs to connect to a peer. It is the        application's responsibility to fill in the port number in the each        SOCKET_ADDRESS structure in the        SOCKET_ADDRESS_LIST."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "LocalAddressLength",
        "description": "On input, a pointer to the size, in bytes, of the LocalAddress buffer provided by        the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the        local address stored in the LocalAddress buffer filled in by the system upon        successful completion of the call."
      },
      {
        "in_out": "_Out_",
        "type": "LPSOCKADDR",
        "name": "LocalAddress",
        "description": "A pointer to the SOCKADDR structure that receives the local address of the        connection. The size of the parameter is exactly the size returned in        LocalAddressLength. This is the same information that would be returned by the        getsockname function. This parameter can be        NULL, in which case, the LocalAddressLength parameter is        ignored."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "RemoteAddressLength",
        "description": "On input, a pointer to the size, in bytes, of the RemoteAddress buffer provided        by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the        remote address stored in RemoteAddress buffer filled-in by the system upon successful        completion of the call."
      },
      {
        "in_out": "_Out_",
        "type": "LPSOCKADDR",
        "name": "RemoteAddress",
        "description": "A pointer to the SOCKADDR structure that receives the remote address of the        connection. This is the same information that would be returned by the        getpeername function. This parameter can be NULL, in        which case, the RemoteAddressLength is ignored."
      },
      {
        "in_out": "_In_",
        "type": "const struct timeval*",
        "name": "timeout",
        "description": "The time, in milliseconds, to wait for a response from the remote application before aborting the call.        This parameter can be NULL in which case        WSAConnectByList will complete after either the        connection is successfully established or after a connection was attempted and failed on all possible        local-remote address pairs."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "Reserved",
        "description": "Reserved for future implementation. This parameter must be set to NULL."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 9,
    "description": "The WSAConnectByName function establishes a connection to a specified host and port. This function is provided to allow a quick connection to a network endpoint given a host name and port.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If a connection is established, WSAConnectByName returns TRUE and LocalAddress and RemoteAddress parameters are filled in if these buffers were supplied by the caller. If the call fails, FALSE is returned. WSAGetLastError can then be called to get extended error information.  ",
    "remarks": "WSAConnectByName is provided to enable quick and transparent connections to remote hosts on specific ports. It is compatible with both IPv6 and IPv4 versions. To enable both IPv6 and IPv4 communications, use the following method: WSAConnectByName has limitations: It works only for connection-oriented sockets, such as those of type SOCK_STREAM. The function does not support overlapped I/O or non-blocking behavior. WSAConnectByName will block even if the socket is in non-blocking mode. WSAConnectByName does not support user-provided data during the establishment of a connection. This call does not support FLOWSPEC structures, either. In cases where these features are required, WSAConnect must be used instead. In versions before Windows 10, if an application needs to bind to a specific local address or port, then WSAConnectByName cannot be used since the socket parameter to WSAConnectByName must be an unbound socket.    This restriction was removed Windows 10. The RemoteAddress and the LocalAddress parameters point to a SOCKADDR  structure, which is a generic data type. When WSAConnectByName is called, it is expected that a socket address type specific to the network protocol or address family being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a sockaddr_in structure would be cast to a pointer to SOCKADDR as the RemoteAddress and LocalAddressparameters. For IPv6 addresses, a pointer to a sockaddr_in6 structure would be cast to a pointer to SOCKADDR as the RemoteAddress and LocalAddressparameters. When the  WSAConnectByName function returns TRUE, the socket s is in the default state for a connected socket. The socket s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the  setsockopt function to set the SO_UPDATE_CONNECT_CONTEXT option. For example: Windows Phone 8: The WSAConnectByNameW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSAConnectByNameW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. Establish a connection using WSAConnectByName. ",
    "return_type": "BOOL PASCAL",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAConnectByName",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies an unconnected socket. Note  On Windows 7,  Windows Server 2008 R2, and earlier, the WSAConnectByName function requires an unbound and unconnected socket. This differs from other Winsock calls to establish a connection (for example, WSAConnect)."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "nodename",
        "description": "A NULL-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6."
      },
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "servicename",
        "description": "A NULL-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6. ..."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "LocalAddressLength",
        "description": "On input, a pointer to the size, in bytes, of the LocalAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the local address stored in the LocalAddress buffer filled in by the system upon successful completion of the call."
      },
      {
        "in_out": "_Out_",
        "type": "LPSOCKADDR",
        "name": "LocalAddress",
        "description": "A pointer to the SOCKADDR structure that receives the local address of the connection. The size of the parameter is exactly the size returned in LocalAddressLength. This is the same information that would be returned by the getsockname function. This parameter can be NULL, in which case, the LocalAddressLength parameter is ignored."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "RemoteAddressLength",
        "description": "On input, a pointer to the size, in bytes, of the RemoteAddress buffer provided by the caller. On output, a pointer to the size, in bytes, of the SOCKADDR for the remote address stored in RemoteAddress buffer filled-in by the system upon successful completion of the call."
      },
      {
        "in_out": "_Out_",
        "type": "LPSOCKADDR",
        "name": "RemoteAddress",
        "description": "A pointer to the SOCKADDR structure that receives the remote address of the connection. This is the same information that would be returned by the getpeername function. This parameter can be NULL, in which case, the RemoteAddressLength is ignored."
      },
      {
        "in_out": "_In_",
        "type": "const struct timeval*",
        "name": "timeout",
        "description": "The time, in milliseconds, to wait for a response from the remote application before aborting the call."
      },
      {
        "in_out": "",
        "type": "LPWSAOVERLAPPED",
        "name": "Reserved",
        "description": "Reserved for future implementation. This parameter must be set to NULL."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "The  WSACreateEvent function creates a new event object.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSACreateEvent returns the handle of the event object. Otherwise, the return value is WSA_INVALID_EVENT. To get extended error information, call  WSAGetLastError.  ",
    "remarks": "The  WSACreateEvent function creates a manual-reset event object with an initial state of nonsignaled. The handle of the event object returned cannot be inherited by child processes.  The event object is unnamed. The WSASetEvent function can be called to set the state of the event object to signaled. The WSAResetEvent function can be called to set the state of the event object to nonsignaled. When an event object is no longer needed, the WSACloseEvent function should be called to free the resources associated with the event object. Windows Sockets 2 event objects are system objects in Windows environments. Therefore, if a Windows application wants to use an auto-reset event rather than a manual-reset event, the application can call the CreateEvent function directly. The scope of an event object is limited to the process in which it is created. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "WSAEVENT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSACreateEvent",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The WSADeleteSocketPeerTargetName function removes the association between a peer target name and an IP address for a socket.  After a successful return, there will be no future association between the IP address and the target name.",
    "library": "Fwpuclnt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Ws2tcpip.h",
    "return_value": "If the function succeeds, the return value is 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. Some possible error codes are listed below.  ",
    "remarks": "The WSADeleteSocketPeerTargetName function provides a method to remove the association between a peer target name and an IP address for a socket. This function is used to delete a peer target name that was previously set with the WSASetSocketPeerTargetName function.  After the WSADeleteSocketPeerTargetName function returns, no future authentication to the IP address will use the previously specified target name. This function is primarily designed to be used by connectionless clients (for example, a socket created with the type set to SOCK_DGRAM or the protocol set to IPPROTO_UDP) after they have terminated the connection with the IP\taddress associated with the peer target name. For connection oriented clients (for example, a socket created with the type set to SOCK_STREAM or protocol set to IPPROTO_TCP), this function should not be called. The WSADeleteSocketPeerTargetName function  simplifies having to call the WSAIoctl function with a dwIoControlCode parameter set to SIO_DELETE_PEER_TARGET_NAME. An error will be returned if the following conditions are not met. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSADeleteSocketPeerTargetName",
    "is_callback": 0,
    "dll": "Fwpuclnt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor identifying a socket on which the peer target name is being deleted."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "PeerAddr",
        "description": "The IP address of the peer for which the target name is being deleted."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PeerAddrLen",
        "description": "The size, in bytes, of the PeerAddr parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED",
        "name": "Overlapped",
        "description": "A pointer to a WSAOVERLAPPED structure.  This parameter is ignored for non-overlapped sockets."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "CompletionRoutine",
        "description": "A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSADuplicateSocket function returns a  WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor for a shared socket. The  WSADuplicateSocket function cannot be used on a QOS-enabled socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSADuplicateSocket returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSADuplicateSocket function is used to enable socket sharing between processes. A source process calls  WSADuplicateSocket to obtain a special  WSAPROTOCOL_INFO structure. It uses some interprocess communications (IPC) mechanism to pass the contents of this structure to a target process, which in turn uses it in a call to  WSASocket to obtain a descriptor for the duplicated socket. The special  WSAPROTOCOL_INFO structure can only be used once by the target process. Sockets can be shared among threads in a given process without using the  WSADuplicateSocket function because a socket descriptor is valid in all threads of a process. One possible scenario for establishing and handing off a shared socket is illustrated in the following table.  The descriptors that reference a shared socket can be used independently for I/O. However, the Windows Sockets interface does not implement any type of access control, so it is up to the processes involved to coordinate their operations on a shared socket. Shared sockets are typically used to having one process that is responsible for creating sockets and establishing connections, and other processes that are responsible for information exchange. All of the state information associated with a socket is held in common across all the descriptors because the socket descriptors are duplicated and not the actual socket. For example, a  setsockopt operation performed using one descriptor is subsequently visible using a  getsockopt from any or all descriptors. Both the source process and the destination process should pass the same flags to their respective WSASocket function calls. If the source process uses the socket function to create the socket, the destination process must pass the WSA_FLAG_OVERLAPPED flag to its WSASocket function call. A process can call  closesocket on a duplicated socket and the descriptor will become deallocated. The underlying socket, however, will remain open until  closesocket is called by the last remaining descriptor. Notification on shared sockets is subject to the usual constraints of  WSAAsyncSelect and  WSAEventSelect. Issuing either of these calls using any of the shared descriptors cancels any previous event registration for the socket, regardless of which descriptor was used to make that registration. Thus, a shared socket cannot deliver FD_READ events to process A and FD_WRITE events to process B. For situations when such tight coordination is required, developers would be advised to use threads instead of separate processes. Windows 8.1 and Windows Server 2012 R2: The  WSADuplicateSocketW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSADuplicateSocket",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "Descriptor identifying the local socket."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwProcessId",
        "description": "Process identifier of the target process in which the duplicated socket will be used."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSAPROTOCOL_INFO",
        "name": "lpProtocolInfo",
        "description": "Pointer to a buffer, allocated by the client, that is large enough to contain a  WSAPROTOCOL_INFO structure. The service provider copies the protocol information structure contents to this buffer."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  WSAEnumNameSpaceProviders function retrieves information on available namespace providers.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  WSAEnumNameSpaceProviders function returns the number of  WSANAMESPACE_INFO structures copied into lpnspBuffer. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The WSAEnumNameSpaceProviders \t\tfunction returns information on available namespace providers in the buffer pointed to by the lpnspBuffer parameter. The returned buffer contains an array of WSANAMESPACE_INFO structures located consecutively at the head of the buffer. Variable sized information referenced by pointers in the WSANAMESPACE_INFO structures point to locations within the buffer located between the end of the fixed WSANAMESPACE_INFO structures and the end of the buffer. The number of WSANAMESPACE_INFO structures filled in is returned by the   WSAEnumNameSpaceProviders function. Each WSANAMESPACE_INFO  structure entry contains the provider-specific information on the namespace entry                      passed to the WSCInstallNameSpace and WSCInstallNameSpace32 functions when the namespace provider was installed. The WSAEnumNameSpaceProvidersEx  function is an enhanced version of the WSAEnumNameSpaceProviders function. The  WSCEnumNameSpaceProvidersEx32 function is an enhanced version of the WSAEnumNameSpaceProviders function that returns information on available 32-bit namespace providers for use on 64-bit platforms. The following example demonstrates the use of the WSAEnumNameSpaceProviders function to retrieve information on available namespace providers. Windows Phone 8: The WSAEnumNameSpaceProvidersW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSAEnumNameSpaceProvidersW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAEnumNameSpaceProviders",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error is  WSAEFAULT), the minimum number of bytes to pass for the lpnspBuffer to retrieve all the requested information. The buffer passed to WSAEnumNameSpaceProviders must be sufficient to hold all of the namespace information."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSANAMESPACE_INFO",
        "name": "lpnspBuffer",
        "description": "A buffer that is filled with  WSANAMESPACE_INFO structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of  WSAEnumNameSpaceProviders."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  WSAEnumNameSpaceProvidersEx function retrieves information on available namespace providers.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  WSAEnumNameSpaceProvidersEx function returns the number of  WSANAMESPACE_INFOEX structures copied into lpnspBuffer. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The WSAEnumNameSpaceProvidersEx  function is an enhanced version of the WSAEnumNameSpaceProviders function. The provider-specific data blob associated with the namespace entry                      passed in the lpProviderInfo parameter to the WSCInstallNameSpaceEx function can be queried using WSAEnumNameSpaceProvidersEx function. Currently, the only namespace provider included with Windows that sets information in the ProviderSpecific member of the  WSANAMESPACE_INFOEX structure is the NS_EMAIL provider. The format of the ProviderSpecific member for an NS_EMAIL namespace provider is a NAPI_PROVIDER_INSTALLATION_BLOB structure. When UNICODE or _UNICODE is defined, WSAEnumNameSpaceProvidersEx is defined to WSAEnumNameSpaceProvidersExW, the Unicode version of this function. The lpnspBuffer parameter is defined to the LPSAWSANAMESPACE_INFOEXW data type and WSANAMESPACE_INFOEXW structures are returned on success. When UNICODE or _UNICODE is not defined, WSAEnumNameSpaceProvidersEx is defined to WSAEnumNameSpaceProvidersExA, the ANSI version of this function. The lpnspBuffer parameter is defined to the LPSAWSANAMESPACE_INFOEXA data type and WSANAMESPACE_INFOEXA structures are returned on success. Windows 8.1 and Windows Server 2012 R2: The  WSAEnumNameSpaceProvidersExW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT WSPAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAEnumNameSpaceProvidersEx",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error is  WSAEFAULT), the minimum number of bytes to allocate for the lpnspBuffer buffer to allow it to retrieve all the requested information. The buffer passed to WSAEnumNameSpaceProvidersEx must be sufficient to hold all of the namespace information."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSANAMESPACE_INFOEX",
        "name": "lpnspBuffer",
        "description": "A buffer that is filled with  WSANAMESPACE_INFOEX structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of  WSAEnumNameSpaceProvidersEx."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSAEnumNetworkEvents function discovers occurrences of network events for the indicated socket, clear internal network event records, and reset event objects (optional).",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAEnumNetworkEvents function is used to discover which network events have occurred for the indicated socket since the last invocation of this function. It is intended for use in conjunction with  WSAEventSelect, which associates an event object with one or more network events. The recording of network events commences when  WSAEventSelect is called with a nonzero lNetworkEvents parameter and remains in effect until another call is made to  WSAEventSelect with the lNetworkEvents parameter set to zero, or until a call is made to  WSAAsyncSelect. WSAEnumNetworkEvents only reports network activity and errors nominated through  WSAEventSelect. See the descriptions of  select and  WSAAsyncSelect to find out how those functions report network activity and errors. The socket's internal record of network events is copied to the structure referenced by lpNetworkEvents, after which the internal network events record is cleared. If the hEventObject parameter is not NULL, the indicated event object is also reset. The Windows Sockets provider guarantees that the operations of copying the network event record, clearing it and resetting any associated event object are atomic, such that the next occurrence of a nominated network event will cause the event object to become set. In the case of this function returning SOCKET_ERROR, the associated event object is not reset and the record of network events is not cleared. The lNetworkEvents member of the  WSANETWORKEVENTS structure indicates which of the FD_XXX network events have occurred. The iErrorCode array is used to contain any associated error codes with the array index corresponding to the position of event bits in lNetworkEvents. Identifiers such as FD_READ_BIT and FD_WRITE_BIT can be used to index the iErrorCode array. Note that only those elements of the iErrorCode array are set that correspond to the bits set in lNetworkEvents parameter. Other parameters are not modified (this is important for backward compatibility with the applications that are not aware of new FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events). The following error codes can be returned along with the corresponding network event. Event: FD_CONNECT   Event: FD_CLOSE   Event: FD_ACCEPT Event: FD_ADDRESS_LIST_CHANGE Event: FD_GROUP_QOS Event: FD_QOS Event: FD_OOB Event: FD_READ Event: FD_WRITE   Event: FD_ROUTING_INTERFACE_CHANGE   The following example demonstrates the use of the WSAEnumNetworkEvents function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAEnumNetworkEvents",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying the socket."
      },
      {
        "in_out": "_In_",
        "type": "WSAEVENT",
        "name": "hEventObject",
        "description": "An optional handle identifying an associated event object to be reset."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSANETWORKEVENTS",
        "name": "lpNetworkEvents",
        "description": "A pointer to a  WSANETWORKEVENTS structure that is filled with a record of network events that occurred and any associated error codes."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSAEnumProtocols function retrieves information about available transport protocols.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSAEnumProtocols returns the number of protocols to be reported. Otherwise, a value of SOCKET_ERROR is returned and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAEnumProtocols function is used to discover information about the collection of transport protocols installed on the local computer. Layered protocols are only usable by applications when installed in protocol chains. Information on layered protocols is not returned except for any dummy layered service providers (LSPs) installed with a chain length of zero in the  lpProtocolBuffer. The lpiProtocols parameter can be used as a filter to constrain the amount of information provided. Often, lpiProtocols will be specified as a NULL pointer that will cause the function to return information on all available transport protocols and protocol chains. The  WSAEnumProtocols function differs from the WSCEnumProtocols and WSCEnumProtocols32 functions in that  the WSAEnumProtocols function doesn't return WSAPROTOCOL_INFO structures for all installed protocols. The WSAEnumProtocols function excludes protocols that the service provider has set with the PFL_HIDDEN flag in the dwProviderFlags member of the WSAPROTOCOL_INFO structure to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by WSAEnumProtocols function.  In addition, the WSAEnumProtocols function does not return data for WSAPROTOCOL_INFO structures that have a chain length of one or greater (an LSP provider).   The WSAEnumProtocols only returns information on base protocols and protocol chains that lack the PFL_HIDDEN flag  and don't have a protocol chain length of zero. A  WSAPROTOCOL_INFO structure is provided in the buffer pointed to by lpProtocolBuffer for each requested protocol. If the specified buffer is not large enough (as indicated by the input value of lpdwBufferLength ), the value pointed to by lpdwBufferLength will be updated to indicate the required buffer size. The application should then obtain a large enough buffer and call  WSAEnumProtocols again. The order in which the  WSAPROTOCOL_INFO structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider using the WS2_32.DLL, or with any subsequent reordering that occurred through the Windows Sockets application or DLL supplied for establishing default TCP/IP providers. Windows Phone 8: The WSAEnumProtocolsW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSAEnumProtocolsW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. The following example demonstrates the use of the WSAEnumProtocols function to retrieve an array of WSAPROTOCOL_INFO structures for available transport protocols. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAEnumProtocols",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPINT",
        "name": "lpiProtocols",
        "description": "A NULLl-terminated array of iProtocol values. This parameter is optional; if lpiProtocols is NULL, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSAPROTOCOL_INFO",
        "name": "lpProtocolBuffer",
        "description": "A pointer to a buffer that is filled with  WSAPROTOCOL_INFO structures."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "On input, number of bytes in the lpProtocolBuffer buffer passed to  WSAEnumProtocols. On output, the minimum buffer size that can be passed to  WSAEnumProtocols to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a computer is typically small."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSAEventSelect function specifies an event object to be associated with the specified set of FD_XXX network events.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the application's specification of the network events and the associated event object was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError. As in the case of the  select and  WSAAsyncSelect functions,  WSAEventSelect will frequently be used to determine when a data transfer operation (send or  recv) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for the possibility that the event object is set and it issues a Windows Sockets call that returns  WSAEWOULDBLOCK immediately. For example, the following sequence of operations is possible: Having successfully recorded the occurrence of the network event (by setting the corresponding bit in the internal network event record) and signaled the associated event object, no further actions are taken for that network event until the application makes the function call that implicitly reenables the setting of that network event and signaling of the associated event object.  Any call to the reenabling routine, even one that fails, results in reenabling of recording and signaling for the relevant network event and event object. For FD_READ, FD_OOB, and FD_ACCEPT network events, network event recording and event object signaling are level-triggered. This means that if the reenabling routine is called and the relevant network condition is still valid after the call, the network event is recorded and the associated event object is set. This allows an application to be event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following sequence: With these semantics, an application need not read all available data in response to an FD_READ network event\u00e2\u0080\u0094a single  recv in response to each FD_READ network event is appropriate. The FD_QOS event is considered edge triggered. A message will be posted exactly once when a quality of service change occurs. Further messages will not be forthcoming until either the provider detects a further change in quality of service or the application renegotiates the quality of service for the socket. The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered edge triggered as well. A message will be posted exactly once when a change occurs after the application has requested the notification by issuing  WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE correspondingly. Other messages will not be forthcoming until the application reissues the IOCTL and another change is detected since the IOCTL has been issued. If a network event has already happened when the application calls  WSAEventSelect or when the reenabling function is called, then a network event is recorded and the associated event object is set as appropriate. For example, consider the following sequence: The FD_WRITE network event is handled slightly differently. An FD_WRITE network event is recorded when a socket is first connected with a call to the   connect, ConnectEx, WSAConnect, WSAConnectByList, or  WSAConnectByName function or when a socket is accepted with  accept, AcceptEx, \t\t\t\t\t\t\tor WSAAccept function and then after a send fails with WSAEWOULDBLOCK and buffer space becomes available. Therefore, an application can assume that sends are possible starting from the first FD_WRITE network event setting and lasting until a send returns  WSAEWOULDBLOCK. After such a failure the application will find out that sends are again possible when an FD_WRITE network event is recorded and the associated event object is set. The FD_OOB network event is used only when a socket is configured to receive OOB data separately. If the socket is configured to receive OOB data inline, the OOB (expedited) data is treated as normal data and the application should register an interest in, and will get FD_READ network event, not FD_OOB network event. An application can set or inspect the way in which OOB data is to be handled by using  setsockopt or  getsockopt for the SO_OOBINLINE option. The error code in an FD_CLOSE network event indicates whether the socket close was graceful or abortive. If the error code is zero, then the close was graceful; if the error code is  WSAECONNRESET, then the socket's virtual circuit was reset. This only applies to connection-oriented sockets such as SOCK_STREAM. The FD_CLOSE network event is recorded when a close indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the FD_CLOSE is recorded when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the remote end performing a  shutdown on the send side or a  closesocket. FD_CLOSE being posted after all data is read from a socket. An application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing data. For more information, see the section on Graceful Shutdown, Linger Options, and Socket Closure and the shutdown function. Note that Windows Sockets will record only an FD_CLOSE network event to indicate closure of a virtual circuit. It will not record an FD_READ network event to indicate this condition. The FD_QOS or FD_GROUP_QOS network event is recorded when any parameter in the flow specification associated with socket s. Applications should use  WSAIoctl with command SIO_GET_QOS to get the current quality of service for socket s. The FD_ROUTING_INTERFACE_CHANGE network event is recorded when the local interface that should be used to reach the destination specified in  WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE changes after such IOCTL has been issued. The FD_ADDRESS_LIST_CHANGE network event is recorded when the list of addresses of protocol family for the socket to which the application can bind changes after  WSAIoctl with SIO_ADDRESS_LIST_CHANGE has been issued.  ",
    "remarks": "The  WSAEventSelect function is used to specify an event object, hEventObject, to be associated with the selected FD_XXX network events, lNetworkEvents. The socket for which an event object is specified is identified by the s parameter. The event object is set when any of the nominated network events occur. The  WSAEventSelect function operates very similarly to  WSAAsyncSelect, the difference being the actions taken when a nominated network event occurs. The  WSAAsyncSelect function causes an application-specified Windows message to be posted. The  WSAEventSelect sets the associated event object and records the occurrence of this event in an internal network event record. An application can use  WSAWaitForMultipleEvents to wait or poll on the event object, and use  WSAEnumNetworkEvents to retrieve the contents of the internal network event record and thus determine which of the nominated network events have occurred. The proper way to reset the state of an event object used with the WSAEventSelect function is to pass the handle of the event object to the WSAEnumNetworkEvents function in the hEventObject parameter. This will reset the event object and adjust the status of active FD events on the socket in an atomic fashion. WSAEventSelect is the only function that causes network activity and errors to be recorded and retrievable through  WSAEnumNetworkEvents. See the descriptions of  select and  WSAAsyncSelect to find out how those functions report network activity and errors. The WSAEventSelect function automatically sets socket s to nonblocking mode, regardless of the value of lNetworkEvents. To set socket s back to blocking mode, it is first necessary to clear the event record associated with socket s via a call to WSAEventSelect with lNetworkEvents set to zero and the hEventObject parameter set to NULL. You can then call ioctlsocket or WSAIoctl to set the socket back to blocking mode. The lNetworkEvents parameter is constructed by using the bitwise OR operator with any of the values specified in the following list.   Issuing a  WSAEventSelect for a socket cancels any previous  WSAAsyncSelect or  WSAEventSelect for the same socket and clears the internal network event record. For example, to associate an event object with both reading and writing network events, the application must call  WSAEventSelect with both FD_READ and FD_WRITE, as follows: It is not possible to specify different event objects for different network events. The following code will not work; the second call will cancel the effects of the first, and only the FD_WRITE network event will be associated with hEventObject2: To cancel the association and selection of network events on a socket, lNetworkEvents should be set to zero, in which case the hEventObject parameter will be ignored. Closing a socket with  closesocket also cancels the association and selection of network events specified in  WSAEventSelect for the socket. The application, however, still must call  WSACloseEvent to explicitly close the event object and free any resources. The socket created when the  accept function is called has the same properties as the listening socket used to accept it. Any  WSAEventSelect association and network events selection set for the listening socket apply to the accepted socket. For example, if a listening socket has  WSAEventSelect association of hEventObject with FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE network events associated with the same hEventObject. If a different hEventObject or network events are desired, the application should call  WSAEventSelect, passing the accepted socket and the desired new information. The following example demonstrates the use of the WSAEventSelect function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAEventSelect",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying the socket."
      },
      {
        "in_out": "_In_",
        "type": "WSAEVENT",
        "name": "hEventObject",
        "description": "A handle identifying the event object to be associated with the specified set of FD_XXX network events."
      },
      {
        "in_out": "_In_",
        "type": "long",
        "name": "lNetworkEvents",
        "description": "A bitmask that specifies the combination of FD_XXX network events in which the application has interest."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The __WSAFDIsSet function specifies whether a socket is included in a set of socket descriptors.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "",
    "remarks": "Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "__WSAFDIsSet",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "",
        "type": "SOCKET",
        "name": "fd",
        "description": "Descriptor identifying a socket."
      },
      {
        "in_out": "",
        "type": "fd_set*",
        "name": "set",
        "description": "Pointer to an fd_set structure containing the set of socket descriptors. The __WSAFDIsSet function determines whether the socket specified in the fd parameter is a member of that set."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "The  WSAGetLastError function returns the error status for the last Windows Sockets operation that failed.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value indicates the error code for this thread's last Windows Sockets operation that failed. ",
    "remarks": "The  WSAGetLastError function returns the last error that occurred for the calling thread. When a particular Windows Sockets function indicates an error has occurred, this function should be called immediately to retrieve the extended error code for the failing function call. This extended error code can be different from the error code obtained from  getsockopt when called with an optname parameter of SO_ERROR, which is socket-specific since  WSAGetLastError is for all thread-specific sockets. If a function call's return value indicates that error or other relevant data was returned in the error code, WSAGetLastError should be called immediately. This is necessary because some functions may  reset the last extended error code to 0 if they succeed, overwriting the extended error code returned by a previously failed function. To specifically reset the extended error code, use the  WSASetLastError function call with the iError parameter set to zero. A  getsockopt function when called with an optname parameter of SO_ERROR also resets the extended error code to zero. The  WSAGetLastError function should not be used to check for an extended error value on receipt of an asynchronous message. In this case, the extended error value is passed in the lParam parameter of the message, and this can differ from the value returned by  WSAGetLastError.  The Windows Sockets extended error codes returned by this function and the text description of the error are listed under Windows Sockets Error Codes. These error codes and a short text description associated with an error code are defined in the Winerror.h header file. The FormatMessage function can be used to obtain the message string for the returned error. For information on how to handle error codes when porting socket applications to Winsock, see Error Codes - errno, h_errno and WSAGetLastError. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAGetLastError",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAGetOverlappedResult function retrieves the results of an overlapped operation on the specified socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If  WSAGetOverlappedResult succeeds, the return value is TRUE. This means that the overlapped operation has completed successfully and that the value pointed to by lpcbTransfer has been updated. If  WSAGetOverlappedResult returns FALSE, this means that either the overlapped operation has not completed, the overlapped operation completed but with errors, or the overlapped operation's completion status could not be determined due to errors in one or more parameters to  WSAGetOverlappedResult. On failure, the value pointed to by lpcbTransfer will not be updated. Use  WSAGetLastError to determine the cause of the failure (either by the WSAGetOverlappedResult function or by the associated overlapped operation).  ",
    "remarks": "The  WSAGetOverlappedResult function reports the results of the overlapped operation specified in the lpOverlapped parameter for the socket specified in the s parameter. The  WSAGetOverlappedResult function is passed the socket descriptor and the  WSAOVERLAPPED structure that was specified when the overlapped function was called. A pending operation is indicated when the function that started the operation returns FALSE and the  WSAGetLastError function returns WSA_IO_PENDING. When an I/O operation such as  WSARecv is pending, the function that started the operation resets the hEvent member of the  WSAOVERLAPPED structure to the nonsignaled state. Then, when the pending operation has completed, the system sets the event object to the signaled state. If the fWait parameter is TRUE,  WSAGetOverlappedResult determines whether the pending operation has been completed by waiting for the event object to be in the signaled state. A client may set the fWait parameter to TRUE, but only if it selected event-based completion notification when the I/O operation was requested. If another form of notification was selected, the usage of the hEvent parameter of the  WSAOVERLAPPED structure is different, and setting fWait to TRUE causes unpredictable results. If the WSAGetOverlappedResult function is called with the lpOverlapped, lpcbTransfer, or lpdwFlags parameter  set to a NULL pointer on Windows Vista, this will result in an access violation. If the WSAGetOverlappedResult function is called with the lpOverlapped, lpcbTransfer, or lpdwFlags parameter  set to a NULL pointer on Windows Server 2003 and earlier, this will result in the WSAEFAULT error code being returned. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAGetOverlappedResult",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying the socket.  This is the same socket that was specified when the overlapped operation was started by a call to  any of the Winsock functions that supports overlappped operations. These functions include AcceptEx, ConnectEx, DisconnectEx, TransmitFile, TransmitPackets, WSARecv,  WSARecvFrom,  WSARecvMsg, WSASend,  WSASendMsg, WSASendTo, and  WSAIoctl."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure that was specified when the overlapped operation was started. This parameter must not be a NULL pointer."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpcbTransfer",
        "description": "A pointer to a 32-bit variable that receives the number of bytes that were actually transferred by a send or receive operation, or by  the WSAIoctl function. This parameter must not be a NULL pointer."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fWait",
        "description": "A flag that specifies whether the function should wait for the pending overlapped operation to complete. If TRUE, the function does not return until the operation has been completed. If FALSE and the operation is still pending, the function returns FALSE and the  WSAGetLastError function returns WSA_IO_INCOMPLETE. The fWait parameter may be set to TRUE only if the overlapped operation selected the event-based completion notification."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwFlags",
        "description": "A pointer to a 32-bit variable that will receive one or more flags that supplement the completion status. If the overlapped operation was initiated through  WSARecv or  WSARecvFrom, this parameter will contain the results value for lpFlags parameter. This parameter must not be a NULL pointer."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  WSAGetServiceClassInfo function retrieves the class information (schema) pertaining to a specified service class from a specified namespace provider.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the  WSAGetServiceClassInfo was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAGetServiceClassInfo function retrieves service class information from a namespace provider. The service class information retrieved from a particular namespace provider might not be the complete set of class information that was specified when the service class was installed. Individual namespace providers are only required to retain service class information that is applicable to the namespaces that they support. See the section  Service Class Data Structures for more information. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAGetServiceClassInfo",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "lpProviderId",
        "description": "A pointer to a GUID that identifies a specific namespace provider."
      },
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "lpServiceClassId",
        "description": "A pointer to a GUID identifying the service class."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "On input, the number of bytes contained in the buffer pointed to by the lpServiceClassInfo parameter.  On output, if the function fails and the error is  WSAEFAULT, this parameter specifies the minimum size, in bytes, of the buffer pointed to lpServiceClassInfo needed to retrieve the record."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSASERVICECLASSINFO",
        "name": "lpServiceClassInfo",
        "description": "A pointer to a WSASERVICECLASSINFO structure that contains the service class information from the indicated namespace provider for the specified service class."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSAGetServiceClassNameByClassId function retrieves the name of the service associated with the specified type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The  WSAGetServiceClassNameByClassId function returns a value of zero if successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAGetServiceClassNameByClassId",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "lpServiceClassId",
        "description": "A pointer to the GUID for the service class."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszServiceClassName",
        "description": "A pointer to the service name."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "On input, the length of the buffer returned by lpszServiceClassName, in characters. On output, the length of the service name copied into lpszServiceClassName, in characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSAHtonl function converts a u_long from host byte order to network byte order.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSAHtonl returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAHtonl function takes a 32-bit number in host byte order and returns a 32-bit number in network byte order in the 32-bit number pointed to by the lpnetlong parameter. The socket passed in the s parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders. If the socket is for the AF_INET or AF_INET6 address family, the  WSAHtonl function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the hostlong parameter is a valid IPv4 address. The  WSAHtonl function requires that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. For use with the AF_INET or AF_INET6 family, the htonl \t\t\tfunction does not require that the Winsock DLL be loaded. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAHtonl",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "u_long",
        "name": "hostlong",
        "description": "A 32-bit number in host byte order."
      },
      {
        "in_out": "_Out_",
        "type": "u_long*",
        "name": "lpnetlong",
        "description": "A pointer to a 32-bit number to receive the number in network byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSAHtons function converts a u_short from host byte order to network byte order.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSAHtons returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAHtons function takes a 16-bit number in host byte order and returns a 16-bit number  in network byte order in the 16-bit number pointed to by the lpnetshort parameter. The socket passed in the s parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders. If the socket is for the AF_INET or AF_INET6 address family, the  WSAHtons function can be used to convert an IP port number  in host byte order to the IP port number in network byte order. The  WSAHtons function requires that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. For use with the AF_INET OR AF_INET6 address family, the htons \t\t\tfunction does not require that the Winsock DLL be loaded. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAHtons",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "u_short",
        "name": "hostshort",
        "description": "A 16-bit number in host byte order."
      },
      {
        "in_out": "_Out_",
        "type": "u_short*",
        "name": "lpnetshort",
        "description": "A pointer to a 16-bit buffer to receive the number in network byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The WSAImpersonateSocketPeer function is used to impersonate the security principal corresponding to a socket peer in order to perform application-level authorization.",
    "library": "Fwpuclnt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Ws2tcpip.h",
    "return_value": "If the function succeeds, the return value is 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. Some possible error codes are listed below.  ",
    "remarks": "The WSAImpersonateSocketPeer function provides an application the ability to impersonate the security principal corresponding to a socket peer in order to perform application-level authorization. If peer user (impersonation) token is available then it will be used for impersonation, otherwise the peer computer token will be used. The WSAImpersonateSocketPeer function can be called only for blocking, non-overlapped sockets. After performing any authorization checks, an application must call the WSARevertImpersonation function to terminate the impersonation. For connection-oriented sockets, the WSAImpersonateSocketPeer function should be called after a connection is established. For a server application using connection-oriented sockets, the WSAImpersonateSocketPeer should be called after the accept, AcceptEx, or WSAAccept function returns. For connectionless sockets, the application should call the WSAImpersonateSocketPeer function immediately after the recv, recvfrom, WSARecv, WSARecvEx, WSARecvFrom, or WSARecvMsg function returns for a new peer address. The WSAImpersonateSocketPeer function can be called multiple times for a single socket. An error will be returned if the following conditions are not met. The WSARevertImpersonation function must be called to end the impersonation. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAImpersonateSocketPeer",
    "is_callback": 0,
    "dll": "Fwpuclnt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "Identifies the application socket."
      },
      {
        "in_out": "_In_opt_",
        "type": "const sockaddr",
        "name": "PeerAddress",
        "description": "The IP address of the peer to be impersonated.  For connection-oriented sockets, the connected socket uniquely identifies a peer.  In this case, this parameter is ignored."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "peerAddressLen",
        "description": "The size, in bytes, of the PeerAddress parameter."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSAInstallServiceClass function registers a service class schema within a namespace. This schema includes the class name, class identifier, and any namespace-specific information that is common to all instances of the service, such as the SAP identifier or object identifier.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAInstallServiceClass",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSASERVICECLASSINFO",
        "name": "lpServiceClassInfo",
        "description": "Service class to namespace specific\u2013type mapping information. ..."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The  WSAIoctl function controls the mode of a socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h;  Mstcpip.h",
    "return_value": "Upon successful completion, the  WSAIoctl returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAIoctl function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem. If both lpOverlapped and lpCompletionRoutine are NULL, the socket in this function will be treated as a non-overlapped socket. For a non-overlapped socket, lpOverlapped and lpCompletionRoutine parameters are ignored, which causes the function to behave like the standard  ioctlsocket function except that  the function can block if socket s is in blocking mode. If socket s is in non-blocking mode, this function can return WSAEWOULDBLOCK when the specified operation cannot be finished immediately. In this case, the application may change the socket to blocking mode and reissue the request or wait for the corresponding network event (such as FD_ROUTING_INTERFACE_CHANGE or FD_ADDRESS_LIST_CHANGE in the case of SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE) using a Windows message (using  WSAAsyncSelect)-based or event (using  WSAEventSelect)-based notification mechanism. For overlapped sockets, operations that cannot be completed immediately will be initiated, and completion will be indicated at a later time. The DWORD value pointed to by the lpcbBytesReturned parameter that is returned may be ignored. The final completion status and bytes returned can be retrieved when the appropriate completion method is signaled when the operation         has completed. Any IOCTL may block indefinitely, depending on the service provider's implementation. If the application cannot tolerate blocking in a  WSAIoctl call, overlapped I/O would be advised for IOCTLs that are especially likely to block including: SIO_ADDRESS_LIST_CHANGE SIO_FINDROUTE SIO_FLUSH SIO_GET_QOS SIO_GET_GROUP_QOS SIO_ROUTING_INTERFACE_CHANGE SIO_SET_QOS SIO_SET_GROUP_QOS Some protocol-specific IOCTLs may also be especially likely to block. Check the relevant protocol-specific annex for any available information. The prototype for the completion routine pointed to by the lpCompletionRoutine parameter is as follows: The CompletionRoutine is a placeholder for an application-supplied function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped parameter. The  cbTransferred parameter specifies the number of bytes received. The dwFlags parameter is not used  for this IOCTL. The completion routine does not return a value. It is possible to adopt an encoding scheme that preserves the currently defined  ioctlsocket opcodes while providing a convenient way to partition the opcode identifier space in as much as the dwIoControlCode parameter is now a 32-bit entity. The dwIoControlCode parameter is built to allow for protocol and vendor independence when adding new control codes while retaining backward compatibility with the Windows Sockets 1.1 and Unix control codes. The dwIoControlCode parameter has the following form.  I is set if the input buffer is valid for the code, as with IOC_IN. O is set if the output buffer is valid for the code, as with IOC_OUT. Control codes using both input and output buffers set both I and O. V is set if there are no parameters for the code, as with IOC_VOID. T is a 2-bit quantity that defines the type of the IOCTL. The following values are defined: 0 The IOCTL is a standard Unix IOCTL code, as with FIONREAD and FIONBIO. 1 The IOCTL is a generic Windows Sockets 2 IOCTL code. New IOCTL codes defined for Windows Sockets 2 will have T == 1. 2 The IOCTL applies only to a specific address family. 3 The IOCTL applies only to a specific vendor's provider, as with IOC_VENDOR. This type allows companies to be assigned a vendor number that appears in the Vendor/Address family parameter. Then, the vendor can define new IOCTLs specific to that vendor without having to register the IOCTL with a clearinghouse, thereby providing vendor flexibility and privacy. Vendor/Address family An 11-bit quantity that defines the vendor who owns the code (if T == 3) or that contains the address family to which the code applies (if T == 2). If this is a Unix IOCTL code (T == 0) then this parameter has the same value as the code on Unix. If this is a generic Windows Sockets 2 IOCTL (T == 1) then this parameter can be used as an extension of the code parameter to provide additional code values. Code The 16-bit quantity that contains the specific IOCTL code for the operation. The following Unix IOCTL codes (commands) are supported.  The following Windows Sockets 2 commands are supported.  If an overlapped operation completes immediately,  WSAIoctl returns a value of zero and the lpcbBytesReturned parameter is updated with the number of bytes in the output buffer. If the overlapped operation is successfully initiated and will complete later, this function returns SOCKET_ERROR and indicates error code  WSA_IO_PENDING. In this case, lpcbBytesReturned is not updated. When the overlapped operation completes the amount of data in the output buffer is indicated either through the cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in  WSAGetOverlappedResult. When called with an overlapped socket, the lpOverlapped parameter must be valid for the duration of the overlapped operation. The lpOverlapped parameter contains the address of a  WSAOVERLAPPED structure. If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use  WSAWaitForMultipleEvents or  WSAGetOverlappedResult to wait or poll on the event object. If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls  WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of  WSAGetOverlappedResult to TRUE. In this case, the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results. The prototype of the completion routine is as follows: This CompletionRoutine is a placeholder for an application-defined or library-defined function. The completion routine is invoked only if the thread is in an alertable state. To put a thread into an alertable state, use  the WSAWaitForMultipleEvents, WaitForSingleObjectEx, or WaitForMultipleObjectsEx function with the fAlertable or bAlertable parameter set to TRUE. The dwError parameter of CompletionRoutine     specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter specifies the number of bytes returned. Currently, no flag values are defined and dwFlags will be zero. The CompletionRoutine function does not return a value. Returning from this function allows invocation of another pending completion routine for this socket. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. The IOCTL codes with T == 0 are a subset of the IOCTL codes used in Berkeley sockets. In particular, there is no command that is equivalent to FIOASYNC. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAIoctl",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIoControlCode",
        "description": "The control code of operation to perform."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvInBuffer",
        "description": "A pointer to the input buffer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbInBuffer",
        "description": "The size, in bytes, of the input buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpvOutBuffer",
        "description": "A pointer to the output buffer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbOutBuffer",
        "description": "The size, in bytes, of the output buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpcbBytesReturned",
        "description": "A pointer to actual number of bytes of output."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure (ignored for non-overlapped sockets)."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "Note  A pointer to the completion routine called when the operation has been completed (ignored for non-overlapped sockets). See Remarks."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "The  WSAJoinLeaf function joins a leaf node into a multipoint session, exchanges connect data, and specifies needed quality of service based on the specified  FLOWSPEC structures.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSAJoinLeaf returns a value of type SOCKET that is a descriptor for the newly created multipoint socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling  WSAGetLastError. On a blocking socket, the return value indicates success or failure of the join operation. With a nonblocking socket, successful initiation of a join operation is indicated by a return of a valid socket descriptor. Subsequently, an FD_CONNECT indication will be given on the original socket s when the join operation completes, either successfully or otherwise. The application must use either  WSAAsyncSelect or  WSAEventSelect with interest registered for the FD_CONNECT event in order to determine when the join operation has completed and checks the associated error code to determine the success or failure of the operation. The  select function cannot be used to determine when the join operation completes. Also, until the multipoint session join attempt completes all subsequent calls to  WSAJoinLeaf on the same socket will fail with the error code  WSAEALREADY. After the  WSAJoinLeaf operation completes successfully, a subsequent attempt will usually fail with the error code  WSAEISCONN. An exception to the WSAEISCONN rule occurs for a c_root socket that allows root-initiated joins. In such a case, another join may be initiated after a prior  WSAJoinLeaf operation completes. If the return error code indicates the multipoint session join attempt failed (that is,  WSAECONNREFUSED,  WSAENETUNREACH,  WSAETIMEDOUT) the application can call  WSAJoinLeaf again for the same socket.  ",
    "remarks": "The  WSAJoinLeaf function is used to join a leaf node to a multipoint session, and to perform a number of other ancillary operations that occur at session join time as well. If the socket s is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound. The  WSAJoinLeaf function has the same parameters and semantics as  WSAConnect except that it returns a socket descriptor (as in  WSAAccept), and it has an additional dwFlags parameter. Only multipoint sockets created using  WSASocket with appropriate multipoint flags set can be used for input parameter s in this function. The returned socket descriptor will not be usable until after the join operation completes. For example, if the socket is in nonblocking mode after a corresponding FD_CONNECT indication has been received from  WSAAsyncSelect or  WSAEventSelect on the original socket s, except that  closesocket may be invoked on this new socket descriptor to cancel a pending join operation. A root application in a multipoint session may call  WSAJoinLeaf one or more times in order to add a number of leaf nodes, however at most one multipoint connection request may be outstanding at a time. Refer to  Multipoint and Multicast Semantics for additional information. For nonblocking sockets it is often not possible to complete the connection immediately. In such a case, this function returns an as-yet unusable socket descriptor and the operation proceeds. There is no error code such as  WSAEWOULDBLOCK in this case, since the function has effectively returned a successful start indication. When the final outcome success or failure becomes known, it may be reported through  WSAAsyncSelect or  WSAEventSelect depending on how the client registers for notification on the original socket s. In either case, the notification is announced with FD_CONNECT and the error code associated with the FD_CONNECT indicates either success or a specific reason for failure. The  select function cannot be used to detect completion notification for  WSAJoinLeaf. The socket descriptor returned by  WSAJoinLeaf is different depending on whether the input socket descriptor, s, is a c_root or a c_leaf. When used with a c_root socket, the name parameter designates a particular leaf node to be added and the returned socket descriptor is a c_leaf socket corresponding to the newly added leaf node. The newly created socket has the same properties as s, including asynchronous events registered with  WSAAsyncSelect or with  WSAEventSelect. It is not intended to be used for exchange of multipoint data, but rather is used to receive network event indications (for example, FD_CLOSE) for the connection that exists to the particular c_leaf. Some multipoint implementations can also allow this socket to be used for side chats between the root and an individual leaf node. An FD_CLOSE indication will be received for this socket if the corresponding leaf node calls  closesocket to drop out of the multipoint session. Symmetrically, invoking  closesocket on the c_leaf socket returned from  WSAJoinLeaf will cause the socket in the corresponding leaf node to get an FD_CLOSE notification. When  WSAJoinLeaf is invoked with a c_leaf socket, the name parameter contains the address of the root application (for a rooted control scheme) or an existing multipoint session (nonrooted control scheme), and the returned socket descriptor is the same as the input socket descriptor. In other words, a new socket descriptor is not allocated. In a rooted control scheme, the root application would put its c_root socket in listening mode by calling  listen. The standard FD_ACCEPT notification will be delivered when the leaf node requests to join itself to the multipoint session. The root application uses the usual  accept or  \t\t\t\tWSAAccept functions to admit the new leaf node. The value returned from either  accept or  WSAAccept is also a c_leaf socket descriptor just like those returned from  WSAJoinLeaf. To accommodate multipoint schemes that allow both root-initiated and leaf-initiated joins, it is acceptable for a c_root socket that is already in listening mode to be used as an input to  WSAJoinLeaf. The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies. The lpCallerData is a value parameter that contains any user data that is to be sent along with the multipoint session join request. If lpCallerData is NULL, no user data will be passed to the peer. The lpCalleeData is a result parameter that will contain any user data passed back from the peer as part of the multipoint session establishment. The len member of the WSABUF structure pointed to by the lpCalleeData parameter initially contains the length of the buffer allocated by the application and pointed to by the buf member of the WSABUF structure. The len member of the WSABUF structure pointed to by the lpCalleeData parameter will be set to zero if no user data has been passed back. The lpCalleeData information will be valid when the multipoint join operation is complete. For blocking sockets, this will be when the  WSAJoinLeaf function returns. For nonblocking sockets, this will be after the join operation has completed. For example, this could occur after FD_CONNECT notification on the original socket s). If lpCalleeData is NULL, no user data will be passed back. The exact format of the user data is specific to the address family to which the socket belongs. At multipoint session establishment time, an application can use the lpSQOS and/or lpGQOS parameters to override any previous quality of service specification made for the socket through  WSAIoctl with the SIO_SET_QOS or  SIO_SET_GROUP_QOS opcodes. The lpSQOS parameter specifies the  FLOWSPEC structures for socket s, one for each direction, followed by any additional provider-specific parameters. If either the associated transport provider in general or the specific type of socket in particular cannot honor the quality of service request, an error will be returned as indicated in the following. The respective sending or receiving flow specification values will be ignored for any unidirectional sockets. If no provider-specific parameters are specified, the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter should be set to NULL and zero, respectively. A NULL value for lpSQOS indicates no application-supplied quality of service. Reserved for future socket groups. The lpGQOS parameter specifies the  FLOWSPEC structures for the socket group (if applicable), one for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are specified, the the buf and len members of the WSABUF structure pointed to by the lpCalleeData parameter should be set to should be set to NULL and zero, respectively. A NULL value for lpGQOS indicates no application-supplied group quality of service. This parameter will be ignored if s is not the creator of the socket group. When connected sockets break (that is, become closed for whatever reason), they should be discarded and recreated. It is safest to assume that when things go awry for any reason on a connected socket, the application must discard and recreate the needed sockets in order to return to a stable point. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "SOCKET",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAJoinLeaf",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "Descriptor identifying a multipoint socket."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "name",
        "description": "Name of the peer to which the socket is to be joined."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "namelen",
        "description": "Length of name, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "LPWSABUF",
        "name": "lpCallerData",
        "description": "Pointer to the user data that is to be transferred to the peer during multipoint session establishment."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSABUF",
        "name": "lpCalleeData",
        "description": "Pointer to the user data that is to be transferred back from the peer during multipoint session establishment."
      },
      {
        "in_out": "_In_",
        "type": "LPQOS",
        "name": "lpSQOS",
        "description": "Pointer to the  FLOWSPEC structures for socket s, one for each direction."
      },
      {
        "in_out": "_In_",
        "type": "LPQOS",
        "name": "lpGQOS",
        "description": "Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if applicable)."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Flags to indicate that the socket is acting as a sender (JL_SENDER_ONLY), receiver (JL_RECEIVER_ONLY), or both (JL_BOTH)."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSALookupServiceBegin function initiates a client query that is constrained by the information contained within a  WSAQUERYSET structure.  WSALookupServiceBegin only returns a handle, which should be used by subsequent calls to  WSALookupServiceNext to get the actual results.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The lpqsRestrictions parameter points to a buffer containing a WSAQUERYSET structure. At a minimum, the dwSize member of the WSAQUERYSET must be set to the length of the buffer before calling the  WSALookupServiceBegin function. Applications can restrict the query by specifying other members in the WSAQUERYSET. In most instances, applications interested in only a particular transport protocol should constrain their query by address family and protocol using the dwNumberOfProtocols and lpafpProtocols members of the WSAQUERYSET rather than by specifiying the namespace in the dwNameSpace member. Information on supported network transport protocols can be retreived using the EnumProtocols, WSAEnumProtocols, WSCEnumProtocols, or  WSCEnumProtocols32 function. It is also possible to constrain the query to a single namespace. For example, a query that only wants results from DNS (not results from the local hosts file and other naming services) would set the dwNameSpace member to NS_DNS. For example, a bluetooth device discovery would set the the dwNameSpace member to NS_BTH. Applications can also restrict the query to a specific namespace provider by specifying a pointer to the GUID for the provider in the lpNSProviderId member. Information on namespace providers on the local computer can be retrieved using the WSAEnumNameSpaceProviders, WSAEnumNameSpaceProvidersEx, WSCEnumNameSpaceProviders32, or WSCEnumNameSpaceProvidersEx32 function. If LUP_CONTAINERS is specified in a call, other restriction values should be avoided. If any are specified, it is up to the name service provider to decide if it can support this restriction over the containers. If it cannot, it should return an error. Some name service providers can have other means of finding containers. For example, containers might all be of some well-known type, or of a set of well-known types, and therefore a query restriction can be created for finding them. No matter what other means the name service provider has for locating containers, LUP_CONTAINERS and LUP_NOCONTAINERS take precedence. Hence, if a query restriction is given that includes containers, specifying LUP_NOCONTAINERS will prevent the container items from being returned. Similarly, no matter the query restriction, if LUP_CONTAINERS is given, only containers should be returned. If a namespace does not support containers, and LUP_CONTAINERS is specified, it should simply return WSANO_DATA. The preferred method of obtaining the containers within another container, is the call: This call is followed by the requisite number of  WSALookupServiceNext calls. This will return all containers contained immediately within the starting context; that is, it is not a deep query. With this, one can map the address space structure by walking the hierarchy, perhaps enumerating the content of selected containers. Subsequent uses of  WSALookupServiceBegin use the containers returned from a previous call. As mentioned above, a  WSAQUERYSET structure is used as an input parameter to WSALookupBegin in order to qualify the query. The following table indicates how the  WSAQUERYSET is used to construct a query. When a parameter is marked as (Optional) a NULL pointer can be specified, indicating that the parameter will not be used as a search criteria. See section  Query-Related Data Structures for additional information.  Windows Phone 8: The WSALookupServiceBeginW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSALookupServiceBeginW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSALookupServiceBegin",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSAQUERYSET",
        "name": "lpqsRestrictions",
        "description": "A pointer to the search criteria. See the Remarks for details."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwControlFlags",
        "description": "A set of flags that controls the depth of the search. Supported values for the dwControlFlags parameter are defined in the Winsock2.h header file and can be a combination of the following options.    FlagMeaning  LUP_DEEP 0x0001   Queries deep as opposed to just the first level.   LUP_CONTAINERS 0x0002   Returns containers only.   LUP_NOCONTAINERS 0x0004   Do not return containers.   LUP_NEAREST 0x0008   If possible, returns results in the order of distance. The measure of distance is provider specific.   LUP_RETURN_NAME 0x0010   Retrieves the name as lpszServiceInstanceName.   LUP_RETURN_TYPE 0x0020   Retrieves the type as lpServiceClassId.   LUP_RETURN_VERSION 0x0040   Retrieves the version as lpVersion.   LUP_RETURN_COMMENT 0x0080   Retrieves the comment as lpszComment.   LUP_RETURN_ADDR 0x0100   Retrieves the addresses as lpcsaBuffer.   LUP_RETURN_BLOB 0x0200   Retrieves the private data as lpBlob.   LUP_RETURN_ALIASES 0x0400   Any available alias information is to be returned in successive calls to  WSALookupServiceNext, and each alias returned will have the RESULT_IS_ALIAS flag set.   LUP_RETURN_QUERY_STRING 0x0800   Retrieves the query string used for the request.   LUP_RETURN_ALL 0x0FF0   A set of flags that retrieves all of the LUP_RETURN_* values.   LUP_FLUSHPREVIOUS 0x1000   Used as a value for the dwControlFlags parameter in  WSALookupServiceNext. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.   LUP_FLUSHCACHE 0x2000   If the provider has been caching information, ignores the cache, and queries the namespace itself.   LUP_RES_SERVICE 0x8000   This indicates whether prime response is in the remote or local part of  CSADDR_INFO structure. The other part needs to be usable in either case."
      },
      {
        "in_out": "_Out_",
        "type": "LPHANDLE",
        "name": "lphLookup",
        "description": "A  handle to be used when calling  WSALookupServiceNext in order to start retrieving the results set."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSALookupServiceEnd function is called to free the handle after previous calls to  WSALookupServiceBegin and  WSALookupServiceNext.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSALookupServiceEnd",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hLookup",
        "description": "Handle previously obtained by calling  WSALookupServiceBegin."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 4,
    "description": "The  WSALookupServiceNext function is called after obtaining a handle from a previous call to  WSALookupServiceBegin in order to retrieve the requested service information.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The dwControlFlags parameter specified in this function and the ones specified at the time of  WSALookupServiceBegin are treated as restrictions for the purpose of combination. The restrictions are combined between the ones at  WSALookupServiceBegin time and the ones at  WSALookupServiceNext time. Therefore the flags at  WSALookupServiceNext can never increase the amount of data returned beyond what was requested at  WSALookupServiceBegin, although it is not an error to specify more or fewer flags. The flags specified at a given  WSALookupServiceNext apply only to that call. The dwControlFlags LUP_FLUSHPREVIOUS and LUP_RES_SERVICE are exceptions to the combined restrictions rule (because they are behavior flags instead of restriction flags). If either of these flags are used in  WSALookupServiceNext they have their defined effect regardless of the setting of the same flags at  WSALookupServiceBegin. For example, if LUP_RETURN_VERSION is specified at  WSALookupServiceBegin the service provider retrieves records including the version. If LUP_RETURN_VERSION is NOT specified at  WSALookupServiceNext, the returned information does not include the version, even though it was available. No error is generated. Also for example, if LUP_RETURN_BLOB is NOT specified at  WSALookupServiceBegin but is specified at  WSALookupServiceNext, the returned information does not include the private data. No error is generated. If the WSALookupServiceNext function fails with an error of  \t\t\t\t\t\t\t\tWSAEFAULT, this indicates that the buffer pointed to by the lpqsResults parameter was too small to contain the query results. A new buffer for a WSAQUERYSET should be provided with a size specified by the value pointed to by  the lpdwBufferLength parameter. This new buffer for the WSAQUERYSET needs to have some of the members of the WSAQUERYSET specified before calling the WSALookupServiceNext function again. At a minimum, the dwSize member of the WSAQUERYSET must be set to the new size of the buffer. The following table describes how the query results are represented in the  WSAQUERYSET structure.  Windows Phone 8: The WSALookupServiceNextW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSALookupServiceNextW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSALookupServiceNext",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hLookup",
        "description": "A handle returned from the previous call to  WSALookupServiceBegin."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwControlFlags",
        "description": "A set of flags that controls the operation. ..."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpdwBufferLength",
        "description": "On input, the number of bytes contained in the buffer pointed to by lpqsResults. On output, if the function fails and the error is  WSAEFAULT, then it contains the minimum number of bytes to pass for the lpqsResults to retrieve the record."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSAQUERYSET",
        "name": "lpqsResults",
        "description": "A pointer to a block of memory, which will contain one result set in a  WSAQUERYSET structure on return."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 8,
    "description": "The Windows Sockets  WSANSPIoctl function enables developers to make I/O control calls to a registered namespace.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "Success returns NO_ERROR. Failure returns SOCKET_ERROR, and a specific error code can be retrieved by calling the  WSAGetLastError function. The following table describes the error codes.  ",
    "remarks": "The  WSANSPIoctl function is used to set or retrieve operating parameters associated with a query handle to a namespace provider. The hLookup parameter is a handle to the namespace provider query previously returned by  the WSALookupServiceBegin function (not  a socket handle). Any IOCTL sent to a namespace provider may block indefinitely, depending upon the implementation of the namespace. If an application cannot tolerate blocking in a  WSANSPIoctl function call, overlapped I/O should be used and the lpCompletion parameter should point to a WSACOMPLETION structure. To make a  WSANSPIoctl function call nonblocking and return immediately, set the Type member of the WSACOMPLETION structure to NSP_NOTIFY_IMMEDIATELY. If lpCompletion is NULL, the  WSANSPIoctl function executes as a blocking call. The namespace provider should return immediately and should not block. But each namespace is responsible for enforcing this behavior. The following IOCTL code is supported by several Microsoft name space provider:  Immediate poll operations are usually much less expensive since they do not require a notification object. In most cases, this is implemented as a simple Boolean variable check. Asynchronous notification, however, may necessitate the creation of dedicated worker threads and/or inter-process communication channels, depending on the implementation of the namespace provider service, and will incur processing overhead related to the notification object involved with signaling the change event. To cancel an asynchronous notification request, end the original query with a  WSALookupServiceEnd function call on the affected query handle. Canceling the asynchronous notification for LUP_NOTIFY_HWND will not post any message, however, an overlapped operation will be completed and notification will be delivered with the error  WSA_OPERATION_ABORTED. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSANSPIoctl",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hLookup",
        "description": "The lookup handle returned from a previous call to the  WSALookupServiceBegin function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwControlCode",
        "description": "The control code of the operation to perform.  The values that may be used for the dwControlCode parameter are determined by the namespace provider.  The following value is supported by several Microsoft namespace providers including the Network Location Awareness (NS_NLA) namespace provider. This IOCTL is defined in the Winsock2.h header file.  ValueMeaning  SIO_NSP_NOTIFY_CHANGE   This operation checks if the results returned with previous calls using the hLookup parameter are still valid.  These previous calls include the initial call to the WSALookupServiceBegin function to retrieve the hLookup parameter.  These previous calls may also include calls to the WSALookupServiceNext function using the hLookup parameter."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpvInBuffer",
        "description": "A pointer to the input buffer."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD",
        "name": "cbInBuffer",
        "description": "The size, in bytes, of the input buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpvOutBuffer",
        "description": "A pointer to the output buffer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbOutBuffer",
        "description": "The size, in bytes, of the output buffer."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpcbBytesReturned",
        "description": "A pointer to the number of bytes returned."
      },
      {
        "in_out": "_In_",
        "type": "LPWSACOMPLETION",
        "name": "lpCompletion",
        "description": "A pointer to a WSACOMPLETION structure, used for asynchronous processing. Set lpCompletion to NULL to force blocking (synchronous) execution."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSANtohl function converts a u_long from network byte order to host byte order.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSANtohl returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSANtohl function takes a 32-bit number in network byte order and returns a 32-bit number in host byte order in the 32-bit number pointed to by the lphostlong parameter. The socket passed in the s parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders. If the socket is for the AF_INET or AF_INET6 address family, the  WSANtohl function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the netlong parameter is a valid IPv4 address. The  WSANtohl function requires that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. For use with the AF_INET or AF_INET6 family, the ntohl function does not require that the Winsock DLL be loaded. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSANtohl",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "u_long",
        "name": "netlong",
        "description": "A 32-bit number in network byte order."
      },
      {
        "in_out": "_Out_",
        "type": "u_long*",
        "name": "lphostlong",
        "description": "A pointer to a 32-bit number to receive the number in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSANtohs function converts a u_short from network byte order to host byte order.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSANtohs returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.   ",
    "remarks": "The  WSANtohs function takes a 16-bit number in network byte order and returns a 16-bit number in host byte order in the 16-bit number pointed to by the lphostshort parameter. The socket passed in the s parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders. If the socket is for the AF_INET or AF_INET6 address family, the  WSANtohs function can be used to convert an IP port number  in network byte order to the IP port number in host byte order. The  WSANtohs function requires that the Winsock DLL has previously been loaded with a successful  call to the WSAStartup function. For use with the AF_INET OR AF_INET6 address family, the ntohs \t\t\t \t\t\tfunction does not require that the Winsock DLL be loaded. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSANtohs",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "u_short",
        "name": "netshort",
        "description": "A 16-bit number in network byte order."
      },
      {
        "in_out": "_Out_",
        "type": "u_short*",
        "name": "lphostshort",
        "description": "A pointer to a 16-bit number to receive the number in host byte order."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The WSAPoll function determines status of one or more sockets.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h (include Winsock2.h)",
    "return_value": "Returns one of the following values.   ",
    "remarks": "The WSAPoll function is defined on Windows Vista and later. The WSAPoll function is used to determine the status of one or more sockets. The set of sockets for which status is requested is specified in fdarray parameter, which is an array of WSAPOLLFD structures.  An application sets the appropriate flags in the events member of the WSAPOLLFD structure to specify the type of status requested for each corresponding socket.  The WSAPoll function returns the status of a socket in the revents member of the WSAPOLLFD structure. For each socket, a caller can request information on read or write status.  Error conditions are always returned, so information on them need not be requested. The fdarray parameter must contain at least one valid non-negative socket. Upon return, all of the supplied sockets that either satisfy the requested status conditions or have an error condition will have the appropriate flags set on the revents member of their corresponding WSAPOLLFD structure pointed to by the fdarray parameter. All sockets that do not meet these criteria and have no error condition will have the corresponding  revents member set to 0. A combination of the following flags can be set in the events member of the WSAPOLLFD structure for a given socket when requesting status for that socket:  The POLLIN flag is defined as the combination of the POLLRDNORM  and POLLRDBAND flag values. The POLLOUT flag is defined as the same as the POLLWRNORM  flag value. The events member of the WSAPOLLFD structure must only contain a combination of the above flags that are supported by the Winsock provider. Any other values are considered errors and  WSAPoll will return SOCKET_ERROR. A subsequent call to  the WSAGetLastError function will retrieve the extended error code of WSAEINVAL. If the POLLPRI flag is set on a socket for the Microsoft Winsock provider, the WSAPoll function will fail. When the WSAPoll function returns a positive value, a combination of the following flags are returned in the revents member of the WSAPOLLFD structures pointed to by the fdarray parameter to indicate socket  status:   With regard to TCP and UDP sockets: The number of elements (not sockets) in fdarray is indicated by nfds. Members of fdarray which have their fd member set to a negative value are ignored and their revents will be cleared upon return. This behavior is useful to an application which maintains a fixed fdarray allocation and will not compact the array to remove unused entries or to reallocate memory. It is not necessary to clear revents for any element prior to calling WSAPoll. The timeout argument specifies how long the function is to wait before returning. A positive value contains the number of milliseconds to wait before returning. A zero value forces WSAPoll to return immediately, and a negative value indicates that WSAPoll should wait indefinitely. Windows 8.1 and Windows Server 2012 R2: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAPoll",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "WSAPOLLFD",
        "name": "fdarray[]",
        "description": "An array of one or more POLLFD structures specifying the set  of sockets for which status is requested. The   array must contain at least one structure with a valid socket. Upon return, this parameter receives the updated sockets with the revents status flags member set on each one that matches the status query criteria."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "nfds",
        "description": "The number of WSAPOLLFD structures in fdarray. This is not necessarily the number of sockets for which status is requested."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "timeout",
        "description": "A value that specifies the wait behavior, based on the following values. \t\t\t  Return valueMeaning Greater than zeroThe time, in milliseconds, to wait. ZeroReturn immediately. Less than zeroWait indefinitely."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSAProviderConfigChange function notifies the application when the provider configuration is changed.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs the  WSAProviderConfigChange returns 0. Otherwise, a value of SOCKET_ERROR is returned and a specific error code may be retrieved by calling  WSAGetLastError. The error code  WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion (and thus change event) will be indicated at a later time.  ",
    "remarks": "The  WSAProviderConfigChange function notifies the application of provider (both transport and namespace) installation or removal in Windows operating environments that support such configuration change without requiring a restart. When called for the first time (lpNotificationHandle parameter points to NULL handle), this function completes immediately and returns notification handle in the location pointed by lpNotificationHandle that can be used in subsequent calls to receive notifications of provider installation and removal. The second and any subsequent calls only complete when provider information changes since the time the call was made It is expected (but not required) that the application uses overlapped I/O on second and subsequent calls to  WSAProviderConfigChange, in which case the call will return immediately and application will be notified of provider configuration changes using the completion mechanism chosen through specified overlapped completion parameters. Notification handle returned by  WSAProviderConfigChange is like any regular operating system handle that should be closed (when no longer needed) using Windows  CloseHandle call. The following sequence of actions can be used to guarantee that application always has current protocol configuration information: Windows 8.1 and Windows Server 2012 R2: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAProviderConfigChange",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_Inout_",
        "type": "LPHANDLE",
        "name": "lpNotificationHandle",
        "description": "Pointer to notification handle. If the notification handle is set to NULL (the handle value not the pointer itself), this function returns a notification handle in the location pointed to by lpNotificationHandle."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "Pointer to a  WSAOVERLAPPED structure."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "Pointer to the completion routine called when the provider change notification is received."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 7,
    "description": "The WSAQuerySocketSecurity function queries information about the security applied to a connection on a socket.",
    "library": "Fwpuclnt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Ws2tcpip.h",
    "return_value": "If the function succeeds, the return value is zero.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. Some possible error codes are listed below.  ",
    "remarks": "The WSAQuerySocketSecurity function provides a method to query the current security settings on a socket. After a connection is established, the WSAQuerySocketSecurity function allows an application to query the security properties of the connection, which can include information on peer access tokens. For connection-oriented sockets, it is preferred to call the WSAQuerySocketSecurity function immediately after a connection is established. For connectionless sockets, it is preferred to call the WSAQuerySocketSecurity function immediately after data is sent to a new peer address or received from a new peer address. The WSAQuerySocketSecurity function can be called multiple times on a single socket. This function simplifies having to call the WSAIoctl function with a dwIoControlCode parameter set to SIO_QUERY_SECURITY. The WSAQuerySocketSecurity function may be called on a Socket parameter created with an address family of AF_INET or AF_INET6. If the Socket parameter was created with a protocol of IPPROTO_TCP, the SecurityQueryTemplate parameter may be NULL and the SecurityQueryTemplateLen parameter may be zero. Otherwise, the SecurityQueryTemplate parameter must point to a SOCKET_SECURITY_QUERY_TEMPLATE structure. For a client application using connection-oriented sockets (socket created with a protocol of IPPROTO_TCP), the WSAQuerySocketSecurity function should be called after the connect, ConnectEx, or WSAConnect function returns.  For a server application using connection-oriented sockets (protocol of IPPROTO_TCP), the WSAQuerySocketSecurity function should be called after the accept, AcceptEx, or WSAAccept function returns. For connectionless sockets (socket created with a protocol of IPPROTO_UDP), the application should call the WSAQuerySocketSecurity function immediately after WSASendTo or WSARecvFrom call returns for a new peer address. An error will be returned if the following conditions are not met. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAQuerySocketSecurity",
    "is_callback": 0,
    "dll": "Fwpuclnt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor identifying a socket for which security information is being queried."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SOCKET_SECURITY_QUERY_TEMPLATE*",
        "name": "SecurityQueryTemplate",
        "description": "A pointer to a SOCKET_SECURITY_QUERY_TEMPLATE structure that specifies the type of query information to return.  A SOCKET_SECURITY_QUERY_TEMPLATE structure pointed to by this parameter may contain zeroes for all members to request default security information. On successful return, only the Flags member in the SOCKET_SECURITY_QUERY_INFO will be set in the returned  SecurityQueryInfo parameter.  This parameter may be a NULL pointer if the Socket parameter was created with a protocol of IPPROTO_TCP. In this case, the information returned is the same as if a SOCKET_SECURITY_QUERY_TEMPLATE structure with all values set to zero was passed. This parameter should be specified for a socket with protocol of IPPROTO_TCP if more than the default security information is required.  If the SOCKET_SECURITY_QUERY_TEMPLATE structure  is specified with the PeerTokenAccessMask member not specified (set to zero), then the WSAQuerySocketSecurity function will not return the PeerApplicationAccessTokenHandle and PeerMachineAccessTokenHandle members in the SOCKET_SECURITY_QUERY_INFO structure. If a Socket parameter was created with a protocol not equal to IPPROTO_TCP, the SecurityQueryTemplate parameter must be specified. In these cases, the PeerAddress member of the SOCKET_SECURITY_QUERY_TEMPLATE structure must specify an address family of AF_INET or AF_INET6 along with peer IP address and port number."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SecurityQueryTemplateLen",
        "description": "The size, in bytes, of the SecurityQueryTemplate parameter.  This parameter may be a zero if the Socket parameter was created with a protocol of IPPROTO_TCP. Otherwise, this parameter must be the size of a SOCKET_SECURITY_QUERY_TEMPLATE structure."
      },
      {
        "in_out": "_Out_opt_",
        "type": "SOCKET_SECURITY_QUERY_INFO*",
        "name": "SecurityQueryInfo",
        "description": "A pointer to a buffer that will receive a SOCKET_SECURITY_QUERY_INFO structure containing the information queried.  This value can be set to NULL to query the size of the output buffer."
      },
      {
        "in_out": "_Inout_",
        "type": "ULONG*",
        "name": "SecurityQueryInfoLen",
        "description": "On input, a pointer to the size, in bytes, of the SecurityQueryInfo parameter.   If the buffer is too small to receive the queried information, the call will return SOCKET_ERROR, and the number of bytes needed to return the queried information will be set in the value pointed to by this parameter.  On a successful call, the number of bytes copied is returned."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED",
        "name": "Overlapped",
        "description": "A pointer to a WSAOVERLAPPED structure.  This parameter is ignored for non-overlapped sockets."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "CompletionRoutine",
        "description": "A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The  WSARecv function receives data from a connected socket or a bound connectionless socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs and the receive operation has completed immediately,  WSARecv returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. The error code  WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.  ",
    "remarks": "The  WSARecv function provides some additional features compared with the standard  recv function in three important areas: The  WSARecv function is used on connected sockets or bound connectionless sockets specified by the s parameter and is used to read incoming data. The socket's local address must be known. For server applications, this is usually done explicitly through  bind or implicitly through  accept or  WSAAccept. Explicit binding is discouraged for client applications. For client applications the socket can become bound implicitly to a local address through  connect,  WSAConnect,  sendto,  WSASendTo, or  WSAJoinLeaf. For connected, connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded. For overlapped sockets,  WSARecv is used to post one or more buffers into which incoming data will be placed as it becomes available, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or  WSAGetOverlappedResult. If both lpOverlapped and lpCompletionRoutine are NULL, the socket in this function will be treated as a nonoverlapped socket. For nonoverlapped sockets, the blocking semantics are identical to that of the standard  recv function and the lpOverlapped and lpCompletionRoutine parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the specified user buffers. In the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received. Windows Sockets 2 does not define any standard blocking time-out mechanism for this function. For protocols acting as byte-stream protocols the stack tries to return as much data as possible subject to the available buffer space and amount of received data available. However, receipt of a single byte is sufficient to unblock the caller. There is no guarantee that more than a single byte will be returned. For protocols acting as message-oriented, a full message is required to unblock the caller. Whether or not a protocol is acting as byte stream is determined by the setting of XP1_MESSAGE_ORIENTED and XP1_PSEUDO_STREAM in its  WSAPROTOCOL_INFO structure and the setting of the MSG_PARTIAL flag passed in to this function (for protocols that support it). The following table lists relevant combinations, (an asterisk (*) indicates that the setting of this bit does not matter in this case).   The buffers are filled in the order in which they appear in the array pointed to by lpBuffers, and the buffers are packed so that no holes are created. If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the  WSABUF structures before returning from this call. This enables applications to build stack-based  WSABUF arrays pointed to by the lpBuffers parameter. For byte stream-style sockets (for example, type SOCK_STREAM), incoming data is placed into the buffers until the buffers are filled, the connection is closed, or the internally buffered data is exhausted. Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets. For message-oriented sockets (for example, type SOCK_DGRAM), an incoming message is placed into the buffers up to the total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the first part of the message. If the MSG_PARTIAL feature is supported by the underlying service provider, the MSG_PARTIAL flag is set in lpFlags and subsequent receive operations will retrieve the rest of the message. If MSG_PARTIAL is not supported but the protocol is reliable,  WSARecv generates the error  WSAEMSGSIZE and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol is unreliable and does not support MSG_PARTIAL), the excess data is lost, and  WSARecv generates the error WSAEMSGSIZE. For connection-oriented sockets,  WSARecv can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read (as indicated by a zero return value to indicate success, and lpNumberOfBytesRecvd value of zero) indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a failure with an error code of  WSAEDISCON is used to indicate graceful closure. In any case a return error code of  WSAECONNRESET indicates an abortive close has occurred. The lpFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the lpFlags parameter. The latter is constructed by using the bitwise OR operator with any of the values listed in the following table.   For message-oriented sockets, the MSG_PARTIAL bit is set in the lpFlags parameter if a partial message is received. If a complete message is received, MSG_PARTIAL is cleared in lpFlags. In the case of delayed completion, the value pointed to by lpFlags is not updated. When completion has been indicated, the application should call  WSAGetOverlappedResult and examine the flags indicated by the lpdwFlags parameter. If an overlapped operation completes immediately,  WSARecv returns a value of zero and the lpNumberOfBytesRecvd parameter is updated with the number of bytes received and the flag bits indicated by the lpFlags parameter are also updated. If the overlapped operation is successfully initiated and will complete later,  WSARecv returns SOCKET_ERROR and indicates error code  WSA_IO_PENDING. In this case, lpNumberOfBytesRecvd and lpFlags are not updated. When the overlapped operation completes, the amount of data transferred is indicated either through the cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in  WSAGetOverlappedResult. Flag values are obtained by examining the lpdwFlags parameter of  WSAGetOverlappedResult. The  WSARecv function using overlapped I/O can be called from within the completion routine of a previous  WSARecv,  WSARecvFrom,  WSASend or  WSASendTo function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate  WSAOVERLAPPED structure. If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use  WSAWaitForMultipleEvents or  WSAGetOverlappedResult to wait or poll on the event object. If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls  WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of  WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results. The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function  WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked. The prototype of the completion routine is as follows: CompletionRoutine is a placeholder for an application-defined or library-defined function name. The dwError specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter specifies the number of bytes received. The dwFlags parameter contains information that would have appeared in lpFlags if the receive operation had completed immediately. This function does not return a value. Returning from this function allows invocation of another pending completion routine for this socket. When using  WSAWaitForMultipleEvents, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order in which they are specified. If you are using I/O completion ports, be aware that the order of calls made to WSARecv is also the order in which the buffers are populated. WSARecv should not be called on the same socket simultaneously from different threads, because it can result in an unpredictable buffer order. The following example shows how to use  the WSARecv function in overlapped I/O mode. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSARecv",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A  descriptor identifying a connected socket."
      },
      {
        "in_out": "_Inout_",
        "type": "LPWSABUF",
        "name": "lpBuffers",
        "description": "A pointer to an array of  WSABUF structures. Each  WSABUF structure contains a pointer to a buffer and the length, in bytes, of the buffer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwBufferCount",
        "description": "The number of  WSABUF structures in the lpBuffers array."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesRecvd",
        "description": "A pointer to the number, in bytes, of data received by this call if the receive operation completes immediately.  Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results. This parameter can be NULL only  if the lpOverlapped parameter is not NULL."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpFlags",
        "description": "A pointer to flags used to modify the behavior of the  WSARecv function call. For more information, see the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure (ignored for nonoverlapped sockets)."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to the completion routine called when the receive operation has been completed (ignored for nonoverlapped sockets)."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  WSARecvDisconnect function terminates reception on a socket, and retrieves the disconnect data if the socket is connection oriented.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSARecvDisconnect returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSARecvDisconnect function is used on connection-oriented sockets to disable reception and retrieve any incoming disconnect data from the remote party. This is equivalent to a shutdown (SD_RECEIVE), except that  WSARecvDisconnect also allows receipt of disconnect data (in protocols that support it). After this function has been successfully issued, subsequent receives on the socket will be disallowed. Calling  WSARecvDisconnect has no effect on the lower protocol layers. For TCP sockets, if there is still data queued on the socket waiting to be received, or data arrives subsequently, the connection is reset, since the data cannot be delivered to the user. For UDP, incoming datagrams are accepted and queued. In no case will an ICMP error packet be generated. To successfully receive incoming disconnect data, an application must use other mechanisms to determine that the circuit has been closed. For example, an application needs to receive an FD_CLOSE notification, to receive a zero return value, or to receive a  WSAEDISCON or  WSAECONNRESET error code from  recv/WSARecv. The  WSARecvDisconnect function does not close the socket, and resources attached to the socket will not be freed until  closesocket is invoked. The  WSARecvDisconnect function does not block regardless of the SO_LINGER setting on the socket. An application should not rely on being able to reuse a socket after it has been disconnected using  WSARecvDisconnect. In particular, a Windows Sockets provider is not required to support the use of  connect or  \t\t\t\tWSAConnect on such a socket. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSARecvDisconnect",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSABUF",
        "name": "lpInboundDisconnectData",
        "description": "A pointer to the incoming disconnect data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The  WSARecvEx function receives data from a connected socket or a bound connectionless socket. The WSARecvEx function is similar to the  recv function, except that the flags parameter is used only to return information. When a partial message is received while using datagram protocol, the MSG_PARTIAL bit is set in the flags parameter on return from the function.",
    "library": "Mswsock.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs,  WSARecvEx returns the number of bytes received. If the connection has been closed, it returns zero. Additionally, if a partial message was received, the MSG_PARTIAL bit is set in the flags parameter. If a complete message was received, MSG_PARTIAL is not set in flags Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSARecvEx function that is part of the Microsoft implementation of Windows Sockets 2 is similar to the more common  recv function except that the flags parameter is used for a single specific purpose. The flags parameter is used to indicate whether a partial or complete message is received when a message-oriented protocol is being used. The value pointed to by the flags parameter is ignored on input. So no flags can be passed to the  WSARecvEx function to modify its behavior. The value pointed to by the flags parameter is set on output. This differs from the recv and WSARecv functions where the  value pointed to by the flags parameter on input can modify the behavior of the function. The  WSARecvEx and  recv functions behave identically for stream-oriented protocols. The flags parameter accommodates two common situations in which a partial message will be received: The MSG_PARTIAL bit is set in the value pointed to by the flags parameter on return from  WSARecvEx when a partial message was received. If a complete message was received, MSG_PARTIAL is not set in the value pointed to by the flags parameter. The  recv function is different from the   WSARecvEx and WSARecv functions in that the  recv function always receives a single message for each call for message-oriented transport protocols. The  recv function also does not have a means to indicate to the application that the data received is only a partial message. An application must build its own protocol for checking whether a message is partial or complete by checking for the error code  WSAEMSGSIZE after each call to  recv. When the application buffer is smaller than the data being sent, as much of the message as will fit is copied into the user's buffer and  recv returns with the error code WSAEMSGSIZE. A subsequent call to  recv will get the next part of the message. Applications written for message-oriented transport protocols should be coded for this possibility if message sizing is not guaranteed by the application's data transfer protocol. An application can use  recv and manage the protocol itself. Alternatively, an application can use  WSARecvEx and check that the MSG_PARTIAL bit is set in the flags parameter. The  WSARecvEx function provides the developer with a more effective way of checking whether a message received is partial or complete when a very large message arrives incrementally. For example, if an application sends a one-megabyte message, the transport protocol must break up the message in order to send it over the physical network. It is theoretically possible for the transport protocol on the receiving side to buffer all the data in the message, but this would be quite expensive in terms of resources. Instead,  WSARecvEx can be used, minimizing overhead and eliminating the need for an application-based protocol. ",
    "return_type": "int PASCAL FAR",
    "category": "Windows Sockets (Winsock)",
    "name": "WSARecvEx",
    "is_callback": 0,
    "dll": "Mswsock.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies a connected socket."
      },
      {
        "in_out": "_Out_",
        "type": "char*",
        "name": "buf",
        "description": "A pointer to the buffer to receive the incoming data."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "len",
        "description": "The length, in bytes, of the buffer pointed to by the buf parameter."
      },
      {
        "in_out": "_Inout_",
        "type": "int*",
        "name": "flags",
        "description": "An indicator specifying whether the message is fully or partially received for datagram sockets."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "The  WSARecvFrom function receives a datagram and stores the source address.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs and the receive operation has completed immediately,  WSARecvFrom returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.  ",
    "remarks": "The  WSARecvFrom function provides functionality over and above the standard  recvfrom function in three important areas: The  WSARecvFrom function is used primarily on a connectionless socket specified by s. The socket's local address must be known. For server applications, this is usually done explicitly through  bind. Explicit binding is discouraged for client applications. For client applications using this function the socket can become bound implicitly to a local address through  sendto,  WSASendTo, or  WSAJoinLeaf. For overlapped sockets, this function is used to post one or more buffers into which incoming data will be placed as it becomes available on a (possibly connected) socket, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or  WSAGetOverlappedResult. Also, the values indicated by lpFrom and lpFromlen are not updated until completion is itself indicated. Applications must not use or disturb these values until they have been updated, therefore the application must not use automatic (that is, stack-based) variables for these parameters. If both lpOverlapped and lpCompletionRoutine are NULL, the socket in this function will be treated as a nonoverlapped socket. For nonoverlapped sockets, the blocking semantics are identical to that of the standard  WSARecv function and the lpOverlapped and lpCompletionRoutine parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the user buffers. For the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received. The buffers are filled in the order in which they appear in the array indicated by lpBuffers, and the buffers are packed so that no holes are created. If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the  WSABUF structures before returning from this call. This enables applications to build stack-based  WSABUF arrays pointed to by the lpBuffers parameter. For connectionless socket types, the address from which the data originated is copied to the buffer indicated by lpFrom. The value pointed to by lpFromlen is initialized to the size of this buffer, and is modified on completion to indicate the actual size of the address stored there. As stated previously for overlapped sockets, the lpFrom and lpFromlen parameters are not updated until after the overlapped I/O has completed. The memory pointed to by these parameters must, therefore, remain available to the service provider and cannot be allocated on the application stack frame. The lpFrom and lpFromlen parameters are ignored for connection-oriented sockets. For byte stream\u00e2\u0080\u0093style sockets (for example, type SOCK_STREAM), incoming data is placed into the buffers until: Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets. For message-oriented sockets, an incoming message is placed into the buffers up to the total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the first part of the message. If the MSG_PARTIAL feature is supported by the underlying service provider, the MSG_PARTIAL flag is set in lpFlags and subsequent receive operation(s) will retrieve the rest of the message. If MSG_PARTIAL is not supported, but the protocol is reliable,  WSARecvFrom generates the error  WSAEMSGSIZE and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol is unreliable and does not support MSG_PARTIAL), the excess data is lost, and  WSARecvFrom generates the error WSAEMSGSIZE. The lpFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the lpFlags parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.  For message-oriented sockets, the MSG_PARTIAL bit is set in the lpFlags parameter if a partial message is received. If a complete message is received, MSG_PARTIAL is cleared in lpFlags. In the case of delayed completion, the value pointed to by lpFlags is not updated. When completion has been indicated the application should call  WSAGetOverlappedResult and examine the flags pointed to by the lpdwFlags parameter. If an overlapped operation completes immediately,  WSARecvFrom returns a value of zero and the lpNumberOfBytesRecvd parameter is updated with the number of bytes received and the flag bits pointed by the lpFlags parameter are also updated. If the overlapped operation is successfully initiated and will complete later,  WSARecvFrom returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, lpNumberOfBytesRecvd and lpFlags is not updated. When the overlapped operation completes the amount of data transferred is indicated either through the cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in  WSAGetOverlappedResult. Flag values are obtained either through the dwFlags parameter of the completion routine, or by examining the lpdwFlags parameter of  WSAGetOverlappedResult. The  WSARecvFrom function can be called from within the completion routine of a previous  WSARecv,  WSARecvFrom,  WSASend, or  WSASendTo function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate  WSAOVERLAPPED structure. If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use  WSAWaitForMultipleEvents or  WSAGetOverlappedResult to wait or poll on the event object. If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls  WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of  WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results. The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function  WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked. The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The prototype of the completion routine is as follows. The CompletionRoutine is a placeholder for an application-defined or library-defined function name. The dwError specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred specifies the number of bytes received. The dwFlags parameter contains information that would have appeared in lpFlags if the receive operation had completed immediately. This function does not return a value. Returning from this function allows invocation of another pending completion routine for this socket. When using  WSAWaitForMultipleEvents, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order they are specified. The following example demonstrates the use of the WSARecvFrom function. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSARecvFrom",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a socket."
      },
      {
        "in_out": "_Inout_",
        "type": "LPWSABUF",
        "name": "lpBuffers",
        "description": "A pointer to an array of  WSABUF structures. Each  WSABUF structure contains a pointer to a buffer and the length of the buffer."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwBufferCount",
        "description": "The number of  WSABUF structures in the lpBuffers array."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesRecvd",
        "description": "A pointer to the number of bytes received by this call if the  WSARecvFrom operation completes immediately.  Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results. This parameter can be NULL only  if the lpOverlapped parameter is not NULL."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpFlags",
        "description": "A pointer to flags used to modify the behavior of the  WSARecvFrom function call. See remarks below."
      },
      {
        "in_out": "_Out_",
        "type": "struct sockaddr*",
        "name": "lpFrom",
        "description": "An optional pointer to a buffer that will hold the source address upon the completion of the overlapped operation."
      },
      {
        "in_out": "_Inout_",
        "type": "LPINT",
        "name": "lpFromlen",
        "description": "A pointer to the size, in bytes, of the \"from\" buffer required only if lpFrom is specified."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure (ignored for nonoverlapped sockets)."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to the completion routine called when the  WSARecvFrom operation has been completed (ignored for nonoverlapped sockets)."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSARecvMsg function receives data and optional control information from connected and unconnected sockets.",
    "library": "",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "If no error occurs and the receive operation has completed immediately,  WSARecvMsg returns zero.  \t\t\t\t\t\tIn this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the operation was not successfully initiated and no completion indication will occur if an overlapped operation was requested.  ",
    "remarks": "The  WSARecvMsg function can be used in place of the  WSARecv and  WSARecvFrom functions to receive data and optional control information from connected and unconnected sockets.  The WSARecvMsg function can only be used with datagrams  and raw sockets. The socket descriptor in the s parameter must be opened with the socket type set to SOCK_DGRAM or SOCK_RAW.  The dwFlags member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter may only contain the MSG_PEEK control flag on input. Overlapped sockets are  created with a WSASocket function call that has the WSA_FLAG_OVERLAPPED flag set. For overlapped sockets, receiving information uses overlapped I/O unless both the lpOverlapped and lpCompletionRoutine parameters are NULL. The socket is treated as a non-overlapped socket when both the lpOverlapped and lpCompletionRoutine parameters are NULL. A completion indication occurs with overlapped sockets. Once the buffer or buffers have been consumed by the transport, a completion routine is triggered or an event object is set. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or by calling the WSAGetOverlappedResult function. For overlapped sockets,  WSARecvMsg is used to post one or more buffers into which incoming data will be placed as it becomes available, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or  the WSAGetOverlappedResult function. For non-overlapped sockets, the blocking semantics are identical to that of the standard  recv function and the lpOverlapped and lpCompletionRoutine parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the specified user buffers. In the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received. Windows Sockets 2 does not define any standard blocking time-out mechanism for this function. For protocols acting as byte-stream protocols the stack tries to return as much data as possible subject to the available buffer space and amount of received data available. However, receipt of a single byte is sufficient to unblock the caller. There is no guarantee that more than a single byte will be returned. For protocols acting as message-oriented, a full message is required to unblock the caller. The buffers are filled in the order in which they appear in the array pointed to by the lpBuffers member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter, and the buffers are packed so that no holes are created. If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture this WSABUF structure before returning from this call. This enables applications to build stack-based  WSABUF arrays pointed to by the lpBuffers member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter. For message-oriented sockets (a socket type  of SOCK_DGRAM or SOCK_RAW), an incoming message is placed into the buffers up to the total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the first part of the message and  the excess data is lost, and  WSARecvMsg generates the error WSAEMSGSIZE. When the IP_PKTINFO socket option is enabled on an IPv4 socket of type  SOCK_DGRAM or SOCK_RAW, the WSARecvMsg function returns packet information in the WSAMSG structure pointed to by the lpMsg parameter.  One of the control data objects in the returned WSAMSG structure will contain an  in_pktinfo structure used to store received packet address information. For datagrams received over IPv4, the Control member of the WSAMSG structure received will contain a WSABUF structure that contains a WSACMSGHDR structure. The cmsg_level member of this WSACMSGHDR structure would contain  IPPROTO_IP, the cmsg_type member of this structure would contain IP_PKTINFO, and the cmsg_data member would contain an in_pktinfo structure used to store received IPv4 packet address information. The IPv4 address in the in_pktinfo structure is the IPv4 address from which the packet was received. When the IPV6_PKTINFO socket option is enabled on an IPv6 socket of type  SOCK_DGRAM or SOCK_RAW, the WSARecvMsg function returns packet information in the WSAMSG structure pointed to by the lpMsg parameter.  One of the control data objects in the returned WSAMSG structure will contain an  in6_pktinfo structure used to store received packet address information. For datagrams received over IPv6, the Control member of the WSAMSG structure received will contain a WSABUF structure that contains a WSACMSGHDR structure. The cmsg_level member of this WSACMSGHDR structure would contain  IPPROTO_IPV6, the cmsg_type member of this structure would contain IPV6_PKTINFO, and the cmsg_data member would contain an in6_pktinfo structure used to store received IPv6 packet address information. The IPv6 address in the in6_pktinfo structure is the IPv6 address from which the packet was received. For a dual-stack datagram socket, if an application requires the WSARecvMsg function to return packet information in a WSAMSG structure for datagrams received over IPv4, then IP_PKTINFO socket option must be set to true on the socket. If only the IPV6_PKTINFO option is set to true on the socket, packet information will be provided for datagrams received over IPv6 but may not be provided for datagrams received over IPv4. Note that the Ws2ipdef.h header file is automatically included in Ws2tcpip.h, and should never be used directly. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. On input, the dwFlags member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter can be used to influence the behavior of the function invocation beyond the socket options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags member of the WSAMSG \t\t\t structure. The only possible input value for the dwFlags member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter is MSG_PEEK.  On output, the dwFlags member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter may return a combination of any of the following values.  On versions of the Platform Software Development Kit (SDK) for Windows Server 2003 and earlier, the possible values for the  dwFlags member on output are defined in the Mswsock.h header file. If an overlapped operation completes immediately,  WSARecvMsg returns a value of zero and the lpNumberOfBytesRecvd parameter is updated with the number of bytes received and the flag bits indicated by the lpFlags parameter are also updated. If the overlapped operation is successfully initiated and will complete later,  WSARecvMsg returns SOCKET_ERROR and indicates error code  WSA_IO_PENDING. In this case, lpNumberOfBytesRecvd is not updated. When the overlapped operation completes, the amount of data transferred is indicated either through the cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in  WSAGetOverlappedResult. Flag values are obtained by examining the lpdwFlags parameter of  WSAGetOverlappedResult. The  WSARecvMsg function using overlapped I/O can be called from within the completion routine of a previous  WSARecv,  WSARecvFrom,  WSARecvMsg, WSASend, WSASendMsg, or  WSASendTo function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate  WSAOVERLAPPED structure. If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use  WSAWaitForMultipleEvents or  WSAGetOverlappedResult to wait or poll on the event object. If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls  WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of  WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results. The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function  WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked. The prototype of the completion routine is as follows: The CompletionRoutine is a placeholder for an application-defined or library-defined function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by the lpOverlapped parameter. The cbTransferred parameter specifies the number of bytes received. The dwFlags parameter contains information that is also returned in dwFlags member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter if the receive operation had completed immediately. The CompletionRoutine function does not return a value. Returning from this function allows invocation of another pending completion routine for this socket. When using  WSAWaitForMultipleEvents, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order in which they are specified. If you are using I/O completion ports, be aware that the order of calls made to WSARecvMsg is also the order in which the buffers are populated. The WSARecvMsg function should not be called on the same socket simultaneously from different threads, because it can result in an unpredictable buffer order. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSARecvMsg",
    "is_callback": 0,
    "dll": "",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies the socket."
      },
      {
        "in_out": "_Inout_",
        "type": "LPWSAMSG",
        "name": "lpMsg",
        "description": "A  WSAMSG structure based on the Posix.1g specification for the msghdr structure."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpdwNumberOfBytesRecvd",
        "description": "A pointer to the number, in bytes, received by this call if the  WSARecvMsg operation completes immediately.  Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results. This parameter can be NULL only  if the lpOverlapped parameter is not NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure. Ignored for non-overlapped structures."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to the completion routine called when the receive operation completes. Ignored for non-overlapped structures."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSARemoveServiceClass function permanently removes the service class schema from the registry.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.   ",
    "remarks": "",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSARemoveServiceClass",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPGUID",
        "name": "lpServiceClassId",
        "description": "Pointer to the GUID for the service class you want to remove."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSAResetEvent function resets the state of the specified event object to nonsignaled.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If the  WSAResetEvent function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. To get extended error information, call  WSAGetLastError.  ",
    "remarks": "The  WSAResetEvent function is used to set the state of the event object to nonsignaled. The proper way to reset the state of an event object used with the WSAEventSelect function is to pass the handle of the event object to the WSAEnumNetworkEvents function in the hEventObject parameter. This will reset the event object and adjust the status of active FD events on the socket in an atomic fashion. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAResetEvent",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WSAEVENT",
        "name": "hEvent",
        "description": "A handle that identifies an open event object handle."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 0,
    "description": "The WSARevertImpersonation function terminates the impersonation of a socket peer.  This must be called after calling WSAImpersonateSocketPeer and finishing any access checks.",
    "library": "Fwpuclnt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Ws2tcpip.h",
    "return_value": "If the function succeeds, the return value is zero.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. Some possible error codes are listed below.  ",
    "remarks": "The WSARevertImpersonation function causes the calling thread to discontinue     the impersonation of a socket peer. If the thread is not currently     impersonating a socket peer, no action is taken. The WSARevertImpersonation function should be called after calling WSAImpersonateSocketPeer and all access checks are finished. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSARevertImpersonation",
    "is_callback": 0,
    "dll": "Fwpuclnt.dll",
    "arguments": [],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "The  WSASend function sends data on a connected socket.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs and the send operation has completed immediately,  WSASend returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. The error code  WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.  ",
    "remarks": "The  WSASend function provides functionality over and above the standard  send function in two important areas: The  WSASend function is used to write outgoing data from one or more buffers on a connection-oriented socket specified by s. It can also be used, however, on connectionless sockets that have a stipulated default peer address established through the  connect or  WSAConnect function. A socket created by the socket function will have the overlapped attribute as the default. A socket created by the WSASocket function with the dwFlags parameter passed to WSASocket with the WSA_FLAG_OVERLAPPED bit set will have the overlapped attribute. For sockets with the overlapped attribute,  WSASend uses overlapped I/O unless both the  lpOverlapped and lpCompletionRoutine parameters are NULL. In that case, the socket is treated as a non-overlapped socket. A completion indication will occur, invoking the completion of a routine or setting of an event object, when the buffer(s) have been consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or  WSAGetOverlappedResult. If both lpOverlapped and lpCompletionRoutine are NULL, the socket in this function will be treated as a non-overlapped socket. For non-overlapped sockets, the last two parameters (lpOverlapped, lpCompletionRoutine) are ignored and  WSASend adopts the same blocking semantics as  send. Data is copied from the buffer(s) into the transport's buffer. If the socket is non-blocking and stream-oriented, and there is not sufficient space in the transport's buffer,  WSASend will return with only part of the application's buffers having been consumed. Given the same buffer situation and a blocking socket,  WSASend will block until all of the application buffer contents have been consumed. If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the  WSABUF structures before returning from this call. This enables applications to build stack-based  WSABUF arrays pointed to by the lpBuffers parameter. For message-oriented sockets, do not exceed the maximum message size of the underlying provider, which can be obtained by getting the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol the error  WSAEMSGSIZE is returned, and no data is transmitted. Windows Me/98/95:  The WSASend function does not support more than 16 buffers. The dwFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.  If an overlapped operation completes immediately,  WSASend returns a value of zero and the lpNumberOfBytesSent parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later,  WSASend returns SOCKET_ERROR and indicates error code  WSA_IO_PENDING. In this case, lpNumberOfBytesSent is not updated. When the overlapped operation completes the amount of data transferred is indicated either through the cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in  WSAGetOverlappedResult. The  WSASend function using overlapped I/O can be called from within the completion routine of a previous  WSARecv,  WSARecvFrom, WSASend, or  WSASendTo function. This enables time-sensitive data transmissions to occur entirely within a preemptive context. The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate  WSAOVERLAPPED structure. If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use  WSAWaitForMultipleEvents or  WSAGetOverlappedResult to wait or poll on the event object. If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls  WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of  WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results. The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function  WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked. The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The following C++ code example is a prototype of the completion routine. The CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped. cbTransferred specifies the number of bytes sent. Currently there are no flag values defined and dwFlags will be zero. This function does not return a value. Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified. The order of calls made to WSASend is also the order in which the buffers are transmitted to the transport layer. WSASend should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from multiple concurrent send requests on the same stream-oriented socket. The following code example shows how to use the WSASend function in overlapped I/O mode. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASend",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor that identifies a connected socket."
      },
      {
        "in_out": "_In_",
        "type": "LPWSABUF",
        "name": "lpBuffers",
        "description": "A pointer to an array of  WSABUF structures. Each  WSABUF structure contains a pointer to a buffer and the length, in bytes, of the buffer. For a Winsock application, once the  WSASend function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwBufferCount",
        "description": "The number of  WSABUF structures in the lpBuffers array."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesSent",
        "description": "A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately.  Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results. This parameter can be NULL only  if the lpOverlapped parameter is not NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The flags used to modify the behavior of the  WSASend function call. For more information, see Using dwFlags in the Remarks section."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure. This parameter is ignored for nonoverlapped sockets."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to the completion routine called when the send operation has been completed. This parameter is ignored for nonoverlapped sockets."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  WSASendDisconnect function initiates termination of the connection for the socket and sends disconnect data.",
    "library": "Ws2_32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSASendDisconnect returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSASendDisconnect function is used on connection-oriented sockets to disable transmission and to initiate termination of the connection along with the transmission of disconnect data, if any. This is equivalent to a shutdown (SD_SEND), except that  WSASendDisconnect also allows sending disconnect data (in protocols that support it). After this function has been successfully issued, subsequent sends are disallowed. The lpOutboundDisconnectData parameter, if not NULL, points to a buffer containing the outgoing disconnect data to be sent to the remote party for retrieval by using  WSARecvDisconnect. The  WSASendDisconnect function does not close the socket, and resources attached to the socket will not be freed until  closesocket is invoked. The  WSASendDisconnect function does not block regardless of the SO_LINGER setting on the socket. An application should not rely on being able to reuse a socket after calling  WSASendDisconnect. In particular, a Windows Sockets provider is not required to support the use of  connect/WSAConnect on such a socket. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASendDisconnect",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "Descriptor identifying a socket."
      },
      {
        "in_out": "_In_",
        "type": "LPWSABUF",
        "name": "lpOutboundDisconnectData",
        "description": "A pointer to the outgoing disconnect data."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The WSASendMsg function sends data and optional control information from connected and unconnected sockets.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2008 [desktop apps | Windows Store apps]",
    "header": "Mswsock.h",
    "return_value": "Returns zero when successful and immediate completion occurs. When zero is returned, the specified completion routine is called when the calling thread is in the alertable state. A return value of SOCKET_ERROR, and subsequent call to WSAGetLastError that returns WSA_IO_PENDING, indicates the overlapped operation has successfully initiated; completion is then indicated through other means, such as through events or completion ports. Upon failure, returns SOCKET_ERROR and a subsequent call to WSAGetLastError returns a value other than WSA_IO_PENDING. The following table lists error codes.  ",
    "remarks": "The WSASendMsg function can be used in place of the WSASend and WSASendTo functions. The WSASendMsg function can only be used with datagrams  and raw sockets. The socket descriptor in the s parameter must be opened with the socket type set to SOCK_DGRAM or SOCK_RAW. The dwFlags parameter can only contain a combination of the  following control flags: MSG_DONTROUTE, MSG_PARTIAL, and MSG_OOB. The dwFlags member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter is ignored on input and not used on output.  Overlapped sockets are  created with a WSASocket function call that has the WSA_FLAG_OVERLAPPED flag set. For overlapped sockets, sending information uses overlapped I/O unless both lpOverlapped and lpCompletionRoutine are NULL; when lpOverlapped and lpCompletionRoutine are NULL, the socket is treated as a nonoverlapped socket. A completion indication occurs with overlapped sockets; once the buffer or buffers have been consumed by the transport, a completion routine is triggered or an event object is set. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or by calling the WSAGetOverlappedResult function. For nonoverlapped sockets, the lpOverlapped and lpCompletionRoutine parameters  are ignored and WSASendMsg adopts the same blocking semantics as the send function: data is copied from the buffer or buffers into the transport's buffer. If the socket is nonblocking and stream oriented, and there is insufficient space in the transport's buffer, WSASendMsg returns with only part of the application's buffers having been consumed. In contrast, this buffer situation on a blocking socket results in WSASendMsg blocking until all of the application's buffer contents have been consumed. If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture this WSABUF structure before returning from this call. This enables applications to build stack-based  WSABUF arrays pointed to by the lpBuffers member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter. For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying provider, which can be obtained by getting the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol, the error WSAEMSGSIZE is returned and no data is transmitted. On an IPv4 socket of type  SOCK_DGRAM or SOCK_RAW, an application can specific  the local IP source address to use for sending with the WSASendMsg function. One of the control data objects passed in the WSAMSG structure to the WSASendMsg function may contain an  in_pktinfo structure used to specify the local IPv4 source address to use for sending. On an IPv6 socket of type  SOCK_DGRAM or SOCK_RAW, an application can specific  the local IP source address to use for sending with the WSASendMsg function. One of the control data objects passed in the WSAMSG structure to the WSASendMsg function may contain an  in6_pktinfo structure used to specify the local IPv6 source address to use for sending. For a dual-stack socket when sending datagrams  with the WSASendMsg function and an application wants to specify a specific local IP source address to be used, the method to handle this depends on the destination IP address. When sending to an IPv4 destination address or an IPv4-mapped IPv6 destination address, one of the control data objects passed in the WSAMSG structure pointed to by the lpMsg parameter should contain an  in_pktinfo structure containing the local IPv4 source address to use for sending. When sending to an IPv6 destination address that is not a an IPv4-mapped IPv6 address, one of the control data objects passed in the WSAMSG structure pointed to by the lpMsg parameter should contain an  in6_pktinfo structure containing the local IPv6 source address to use for sending. The dwFlags input parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags parameter. The latter is constructed by using the bitwise OR operator with any of the following values.  On output, the dwFlags member of the WSAMSG \t\t\t structure pointed to by the lpMsg parameter is not used. If an overlapped operation completes immediately,  WSASendMsg returns a value of zero and the lpNumberOfBytesSent parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later,  WSASendMsg returns SOCKET_ERROR and indicates error code  WSA_IO_PENDING. In this case, lpNumberOfBytesSent is not updated. When the overlapped operation completes, the amount of data transferred is indicated either through the cbTransferred parameter in the completion routine (if specified) or through the lpcbTransfer parameter in  WSAGetOverlappedResult.  The  WSASendMsg function using overlapped I/O can be called from within the completion routine of a previous  , WSARecv,  WSARecvFrom, WSARecvMsg, WSASend, WSASendMsg, or  WSASendTo function. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate  WSAOVERLAPPED structure. If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use  WSAWaitForMultipleEvents or  WSAGetOverlappedResult to wait or poll on the event object. If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULL lpCompletionRoutine and later calls  WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of  WSAGetOverlappedResult to TRUE. In this case, the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results. The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state, for example, with WSAWaitForMultipleEvents called with the fAlertable parameter set to TRUE. The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The prototype of the completion routine is as follows. The CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by the lpOverlapped parameter. The cbTransferred parameter indicates the number of bytes sent. Currently there are no flag values defined and the dwFlags parameter will be zero. The CompletionRoutine function does not return a value. Returning from this function allows invocation of another pending completion routine for the socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified. Windows 8.1 and Windows Server 2012 R2: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASendMsg",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying the  socket."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAMSG",
        "name": "lpMsg",
        "description": "A WSAMSG structure storing the Posix.1g msghdr structure."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The flags used to modify the behavior of the WSASendMsg function call. For more information, see Using dwFlags in the Remarks section."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesSent",
        "description": "A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately.  Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results. This parameter can be NULL only  if the lpOverlapped parameter is not NULL."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure. Ignored for non-overlapped sockets."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to the completion routine called when the send operation completes. Ignored for non-overlapped sockets."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 9,
    "description": "The  WSASendTo function sends data to a specific destination, using overlapped I/O where applicable.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs and the send operation has completed immediately,  WSASendTo returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.  ",
    "remarks": "The  WSASendTo function provides enhanced features over the standard  sendto function in two important areas: The  WSASendTo function is normally used on a connectionless socket specified by s to send a datagram contained in one or more buffers to a specific peer socket identified by the lpTo parameter. Even if the connectionless socket has been previously connected using the  connect function to a specific address, lpTo overrides the destination address for that particular datagram only. On a connection-oriented socket, the lpTo and iToLen parameters are ignored; in this case, the  WSASendTo is equivalent to  WSASend. For overlapped sockets (created using  WSASocket with flag WSA_FLAG_OVERLAPPED) sending data uses overlapped I/O, unless both lpOverlapped and lpCompletionRoutine are NULL in which case the socket is treated as a nonoverlapped socket. A completion indication will occur (invoking the completion routine or setting of an event object) when the buffer(s) have been consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or  WSAGetOverlappedResult. If both lpOverlapped and lpCompletionRoutine are NULL, the socket in this function will be treated as a nonoverlapped socket. For nonoverlapped sockets, the last two parameters (lpOverlapped, lpCompletionRoutine) are ignored and  WSASendTo adopts the same blocking semantics as  send. Data is copied from the buffer(s) into the transport buffer. If the socket is nonblocking and stream oriented, and there is not sufficient space in the transport's buffer,  WSASendTo returns with only part of the application's buffers having been consumed. Given the same buffer situation and a blocking socket,  WSASendTo will block until all of the application's buffer contents have been consumed. If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the  WSABUF structures before returning from this call. This enables applications to build stack-based  WSABUF arrays pointed to by the lpBuffers parameter. For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport, which can be obtained by getting the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol the error  WSAEMSGSIZE is returned, and no data is transmitted. If the socket is unbound, unique values are assigned to the local association by the system, and the socket is then marked as bound. If the socket is connected, the getsockname function can be used to determine the local IP address and port associated with the socket. If the socket is not connected, the   getsockname   function can be used to determine the local port number associated with the socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY  or \"0.0.0.0\" for IPv4 and IN6ADDR_ANY_INIT or \"::\" for IPv6). The successful completion of a  WSASendTo does not indicate that the data was successfully delivered. The dwFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.  If an overlapped operation completes immediately,  WSASendTo returns a value of zero and the lpNumberOfBytesSent parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later,  WSASendTo returns SOCKET_ERROR and indicates error code  WSA_IO_PENDING. In this case, lpNumberOfBytesSent is not updated. When the overlapped operation completes the amount of data transferred is indicated either through the cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in  WSAGetOverlappedResult. The  WSASendTo function using overlapped I/O can be called from within the completion routine of a previous  WSARecv,  WSARecvFrom,  WSASend, or  WSASendTo function. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate  WSAOVERLAPPED structure. If the lpCompletionRoutine parameter is NULL, the hEvent parameter of lpOverlapped is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use  WSAWaitForMultipleEvents or  WSAGetOverlappedResult to wait or poll on the event object. If lpCompletionRoutine is not NULL, the hEvent parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-NULLlpCompletionRoutine and later calls  WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of  WSAGetOverlappedResult to TRUE. In this case the usage of the hEvent parameter is undefined, and attempting to wait on the hEvent parameter would produce unpredictable results. The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function  WSAWaitForMultipleEvents with the fAlertable parameter set to TRUE is invoked. Transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context. The prototype of the completion routine is as follows. The  CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The dwError parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter specifies the number of bytes sent. Currently there are no flag values defined and dwFlags will be zero. This function does not return a value. Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order in which the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified. The following example demonstrates the use of the WSASendTo function using an event object. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASendTo",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "s",
        "description": "A descriptor identifying a (possibly connected) socket."
      },
      {
        "in_out": "_In_",
        "type": "LPWSABUF",
        "name": "lpBuffers",
        "description": "A pointer to an array of  WSABUF structures. Each  WSABUF structure contains a pointer to a buffer and the length of the buffer, in bytes. For a Winsock application, once the  WSASendTo function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwBufferCount",
        "description": "The number of  WSABUF structures in the lpBuffers array."
      },
      {
        "in_out": "_Out_",
        "type": "LPDWORD",
        "name": "lpNumberOfBytesSent",
        "description": "A pointer to the number of bytes sent by this call if the I/O operation completes immediately.  Use NULL for this parameter if the lpOverlapped parameter is not NULL to avoid potentially erroneous results. This parameter can be NULL only  if the lpOverlapped parameter is not NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The flags  used to modify the behavior of the  WSASendTo function call."
      },
      {
        "in_out": "_In_",
        "type": "const struct sockaddr*",
        "name": "lpTo",
        "description": "An optional pointer to the address of the target socket in the  SOCKADDR structure."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "iToLen",
        "description": "The size, in bytes, of the address in the lpTo parameter."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED",
        "name": "lpOverlapped",
        "description": "A pointer to a  WSAOVERLAPPED structure (ignored for nonoverlapped sockets)."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "lpCompletionRoutine",
        "description": "A pointer to the completion routine called when the send operation has been completed (ignored for nonoverlapped sockets)."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSASetEvent function sets the state of the specified event object to signaled.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE. To get extended error information, call  WSAGetLastError.  ",
    "remarks": "The  WSASetEvent function sets the state of the event object to be signaled. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "BOOL",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASetEvent",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WSAEVENT",
        "name": "hEvent",
        "description": "Handle that identifies an open event object."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 1,
    "description": "The  WSASetLastError function sets the error code that can be retrieved through the  WSAGetLastError function.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "This function generates no return values.  ",
    "remarks": "The  WSASetLastError function allows an application to set the error code to be returned by a subsequent  WSAGetLastError call for the current thread. Note that any subsequent Windows Sockets routine called by the application will override the error code as set by this routine. The error code set by  WSASetLastError is different from the error code reset by calling the function  getsockopt with SO_ERROR. The Windows Sockets error codes used by this function are listed under Windows Sockets Error Codes. Windows Phone 8: This function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "void",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASetLastError",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "iError",
        "description": "Integer that specifies the error code to be returned by a subsequent  WSAGetLastError call."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 3,
    "description": "The  WSASetService function registers or removes from the registry a service instance within one or more namespaces.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value for  WSASetService is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The WSASetService function can be used to affect a specific namespace provider, all providers associated with a specific namespace, or all providers across all namespaces. The available values for essOperation and dwControlFlags combine to control operation of the WSASetService function as shown in the following table.  Publishing services to directories, such as Active Directory Services, is restricted based on access control lists (ACLs). For more information, see Security Issues for Service Publication. When the dwControlFlags parameter is set to SERVICE_MULTIPLE, an application can manage its addresses independently. This is useful when the application wants to manage its protocols individually or when the service resides on more than one computer. For instance, when a service uses more than one protocol, it may find that one listening socket aborts but the other sockets remain operational. In this case, the service could remove the aborted address from the registry without affecting the other addresses. When the dwControlFlags parameter is set to SERVICE_MULTIPLE, an application must not let stale addresses remain in the object. This can happen if the application aborts without issuing a DEREGISTER request. When a service registers, it should store its addresses. On its next invocation, the service should explicitly remove these old stale addresses from the registry before registering new addresses. The following table describes how service property data is represented in a  WSAQUERYSET structure. Fields labeled as (Optional) can contain a null pointer.  As illustrated in the following, the combination of the dwNameSpace and lpNSProviderId members determine that namespace providers are affected by this function.  Windows Phone 8: The WSASetServiceW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSASetServiceW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASetService",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPWSAQUERYSET",
        "name": "lpqsRegInfo",
        "description": "A pointer to the service information for registration or deregistration."
      },
      {
        "in_out": "_In_",
        "type": "WSAESETSERVICEOP",
        "name": "essOperation",
        "description": "A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration type defined in the Winsock2.h header file.     ValueMeaning  RNRSERVICE_REGISTER   Register the service. For SAP, this means sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores, this means updating the address information.   RNRSERVICE_DEREGISTER   Remove the service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores this means deleting address information.   RNRSERVICE_DELETE   Delete the service from dynamic name and persistent spaces. For services represented by multiple  CSADDR_INFO structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding  CSADDR_INFO structure that was specified when the service was registered."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwControlFlags",
        "description": "Service install flags value that further controls the operation performed of the WSASetServicefunction. The possible values for this parameter are defined in the Winsock2.h header file.  FlagMeaning  SERVICE_MULTIPLE   Controls scope of operation. When this flag is not set, service addresses are managed as a group. A register or removal from the registry invalidates all existing addresses before adding the given address set. When set, the action is only performed on the given address set. A register does not invalidate existing addresses and a removal from the registry only invalidates the given set of addresses."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The WSASetSocketPeerTargetName function is used to specify the peer target name (SPN) that corresponds to a peer IP address.  This target name is meant to be specified by client applications to securely identify the peer that should be authenticated.",
    "library": "Fwpuclnt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Ws2tcpip.h",
    "return_value": "If the function succeeds, the return value is zero.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. Some possible error codes are listed below.  ",
    "remarks": "The WSASetSocketPeerTargetName function provides a method to specify the target name that corresponds to a peer security principal. This function is meant to be used by a client application to identify the peer that should be authenticated. A client application should specify the peer target name in order to prevent trusted man-in-the-middle attacks. For connectionless sockets, an application can call the WSASetSocketPeerTargetName function multiple times to specify different target names for different peer IP addresses. This function simplifies having to call the WSAIoctl function with a dwIoControlCode parameter set to SIO_SET_PEER_TARGET_NAME. For connection-oriented sockets, the WSASetSocketPeerTargetName function should be called before WSAConnect.  For connectionless sockets, this function should be called before WSAConnect or before the first WSASendTo call directed to the peer address. An error will be returned if the following conditions are not met. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASetSocketPeerTargetName",
    "is_callback": 0,
    "dll": "Fwpuclnt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor identifying a socket on which the peer target name is being assigned."
      },
      {
        "in_out": "_In_",
        "type": "const SOCKET_PEER_TARGET_NAME*",
        "name": "PeerTargetName",
        "description": "A pointer to a SOCKET_PEER_TARGET_NAME structure that defines the peer target name."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "PeerTargetNameLen",
        "description": "The size, in bytes, of the PeerTargetName parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED",
        "name": "Overlapped",
        "description": "A pointer to a WSAOVERLAPPED structure.  This parameter is ignored for non-overlapped sockets."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "CompletionRoutine",
        "description": "A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "The WSASetSocketSecurity function enables and applies security for a socket.",
    "library": "Fwpuclnt.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Ws2tcpip.h",
    "return_value": "If the function succeeds, the return value is zero.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling  WSAGetLastError. Some possible error codes are listed below.  ",
    "remarks": "The primary purpose of the WSASetSocketSecurity function is to turn on security for a socket if it is not already enabled by administrative policy. For IPsec, this means  that appropriate IPsec filters and policies will be instantiated that will be used to secure this socket. the WSASetSocketSecurity function can also be used to set specific security requirements for the socket. This function simplifies having to call the WSAIoctl function with a dwIoControlCode parameter set to SIO_SET_SECURITY. The WSASetSocketSecurity function may be called on a Socket parameter created with an address family of AF_INET or AF_INET6. For a client application using connection-oriented sockets (protocol of IPPROTO_TCP), the WSASetSocketSecurity function should be called before the connect, ConnectEx, or WSAConnect function is called.  If the WSASetSocketSecurity function is called after the connect, ConnectEx, or WSAConnect function,  WSASetSocketSecurity should fail. For a server application using connection-oriented sockets (protocol of IPPROTO_TCP), the WSASetSocketSecurity function should be called before the bind function is called.  If the WSASetSocketSecurity function is called after the bind function,  WSASetSocketSecurity should fail. For connectionless sockets (protocol of IPPROTO_UDP), the application should call the WSASetSocketSecurity function immediately after socket or WSASocket call returns. Server applications should call the  setsockopt function to acquire exclusive access to the port used by the socket. This prevents other applications from using the same port. The setsockopt function would be called with the level parameter set to SOL_SOCKET,  the optname parameter set to SO_EXCLUSIVEADDRUSE, and the value  parameter set to nonzero. The WSASetSocketSecurity function internally calls the setsockopt with SO_EXCLUSIVEADDRUSE to obtain exclusive access to the port. This is to ensure that the socket is not vulnerable to attacks by other applications running on the local computer. Security settings not set using the WSASetSocketSecurity are derived from the system default policy or the administratively configured policy. It is recommended that most applications specify a value of  SOCKET_SECURITY_PROTOCOL_DEFAULT for the SOCKET_SECURITY_PROTOCOL enumeration in the SecurityProtocol member of the SOCKET_SECURITY_PROTOCOL pointed to by the SecuritySettings parameter.  This makes the application neutral to security protocols and allows easier deployments among different systems. When the SecuritySettings parameter points to a SOCKET_SECURITY_SETTINGS_IPSEC  structure, the SecurityProtocol  member of the structure must be set to SOCKET_SECURITY_PROTOCOL_IPSEC, not SOCKET_SECURITY_PROTOCOL_DEFAULT. An error will be returned if the following conditions are not met. If the SecuritySettings parameter is set to NULL, and there is no other administratively specified IPsec policy on the computer, a default security policy based on IPsec will be used to secure the application's traffic.  Some type of authentication credential (a user certificate or domain membership, for example) must be present for IPsec to succeed with a default policy. The default IPsec policy has been designed so that IPsec security can be negotiated in as many scenarios as possible. ",
    "return_type": "int WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASetSocketSecurity",
    "is_callback": 0,
    "dll": "Fwpuclnt.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "SOCKET",
        "name": "Socket",
        "description": "A descriptor that identifies a socket on which security settings are being applied."
      },
      {
        "in_out": "_In_opt_",
        "type": "const SOCKET_SECURITY_SETTINGS*",
        "name": "SecuritySettings",
        "description": "A pointer to a SOCKET_SECURITY_SETTINGS structure that specifies the security settings to be applied to the socket's traffic. If this parameter is NULL, default settings will be applied to the socket."
      },
      {
        "in_out": "_In_",
        "type": "ULONG",
        "name": "SecuritySettingsLen",
        "description": "The size, in bytes, of the SecuritySettings parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED",
        "name": "Overlapped",
        "description": "A pointer to a WSAOVERLAPPED structure.  This parameter is ignored for non-overlapped sockets."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAOVERLAPPED_COMPLETION_ROUTINE",
        "name": "CompletionRoutine",
        "description": "A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "The  WSASocket function creates a socket that is bound to a specific transport-service provider.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If no error occurs,  WSASocket returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSASocket function causes a socket descriptor and any related resources to be allocated and associated with a transport-service provider. Most sockets should be created with the WSA_FLAG_OVERLAPPED attribute set in the dwFlags parameter. A socket created with this attribute supports the use of overlapped I/O operations which provide higher performance. By default, a socket created with the WSASocket function will not have this overlapped attribute set. In contrast, the socket function creates a socket that supports overlapped I/O operations as the default behavior. If the lpProtocolInfo parameter is NULL, Winsock will utilize the first available transport-service provider that supports the requested combination of address family, socket type and protocol specified in the af, type, and protocol parameters. If the lpProtocolInfo parameter is not NULL, the socket will be bound to the provider associated with the indicated  WSAPROTOCOL_INFO structure. In this instance, the application can supply the manifest constant FROM_PROTOCOL_INFO as the value for any of af, type, or protocol parameters. This indicates that the corresponding values from the indicated  WSAPROTOCOL_INFO structure (iAddressFamily, iSocketType, iProtocol) are to be assumed. In any case, the values specified for af, type, and protocol are passed unmodified to the transport-service provider. When selecting a protocol and its supporting service provider based on af, type, and protocol, this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on type or af, either. That is, they do not lead to an error code of  WSAEAFNOSUPPORT or  WSAEPROTONOSUPPORT, if no suitable protocol is found. Applications are encouraged to use AF_INET6 for the af parameter and create a dual-mode socket that can be used with both IPv4 and IPv6. If a socket is created using the WSASocket function, then the dwFlags parameter must have the WSA_FLAG_OVERLAPPED attribute set for the SO_RCVTIMEO or SO_SNDTIMEO socket options to function properly. Otherwise the timeout never takes effect on the socket. Connection-oriented sockets such as SOCK_STREAM provide full-duplex connections, and must be in a connected state before any data can be sent or received on them. A connection to  a specified socket is established with a  connect or WSAConnect function call. Once connected, data can be transferred using  send/WSASend and  recv/WSARecv calls. When a session has been completed, the closesocket function should be called to release the resources associated with the socket. For connection-oriented sockets, the shutdown function should be called to stop data transfer on the socket before calling the closesocket function. The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to  WSAETIMEDOUT. Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using  sendto/WSASendTo and  recvfrom/WSARecvFrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer using  send/WSASend and can be received from (only) this peer using  recv/WSARecv. Support for sockets with type SOCK_RAW is not required, but service providers are encouraged to support raw sockets whenever possible. The WSASocket function can be used to create a socket to be used by a service so that if another socket tries to bind to the same port used by the service, and audit record is generared. To enable this option, an application would need to do the following:  For more information on ACCESS_SYSTEM_SECURITY, see SACL Access Right and Audit Generation in the Authorization documentation. WinSock 2 introduced the notion of a socket group as a means for an application, or cooperating set of applications, to indicate to an underlying service provider that a particular set of sockets are related and that the group thus formed has certain attributes.  Group attributes include relative priorities of the individual sockets within the group and a group quality of service specification.   Applications that need to exchange multimedia streams over the network are an example where being able to establish a specific relationship among a set of sockets could be beneficial.  It is up to the transport on how to treat socket groups. The WSASocket and WSAAccept functions can be used to explicitly create and join a socket group when creating a new socket.  The socket group ID for a socket can be retrieved by using the getsockopt function with level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_ID.  A socket group     and its associated socket group ID remain valid until the last socket belonging to this     socket group is closed. Socket group IDs are unique across all processes     for a given service provider. A socket group of zero indicates that the socket is not member of a socket group. The relative group priority of  a socket group can be accessed by using the getsockopt function with the level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_PRIORITY. The relative group priority of  a socket group can be set by using setsockopt with the level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_PRIORITY. The Winsock provider included with Windows allows the creation of socket groups and it enforces the SG_CONSTRAINED_GROUP. All sockets in a constrained socket group must be created with the same value for the type and protocol parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.  This is the only restriction applied to a socket group by the Winsock provider included with Windows. The socket group priority is not currently used by the Winsock provider or the TCP/IP stack included with Windows. The following example demonstrates the use of the WSASocket function.  Windows Phone 8: The WSASocketW function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: The WSASocketW function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "SOCKET",
    "category": "Windows Sockets (Winsock)",
    "name": "WSASocket",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "int",
        "name": "af",
        "description": "The address family specification. Possible values for the address family are defined in the Winsock2.h header file.  On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. The values currently supported are AF_INET or AF_INET6, which are the Internet                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, AF_INET and PF_INET), so either constant can be used. The table below lists common values for address family although many other values are possible.   AfMeaning  AF_UNSPEC 0   The address family is unspecified.   AF_INET 2   The Internet Protocol version 4 (IPv4) address family.   AF_IPX 6   The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed.  This address family is not supported on Windows Vista and later.   AF_APPLETALK 16   The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed.  This address family is not supported on Windows Vista and later.   AF_NETBIOS 17   The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed.  The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows.  The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows 7,  Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP.   The Windows Sockets provider for NetBIOS  only supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS  is not directly related to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008, and later.   AF_INET6 23   The Internet Protocol version 6 (IPv6) address family.   AF_IRDA 26   The Infrared Data Association (IrDA) address family.  This address family is only supported if the computer has an infrared port and driver installed.   AF_BTH 32   The Bluetooth address family.  This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "type",
        "description": "The type specification for the new socket.    Possible values for the socket type are defined in the Winsock2.h header file. The following table lists the possible values for the type parameter supported for Windows Sockets 2:  TypeMeaning  SOCK_STREAM 1   A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).   SOCK_DGRAM 2   A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).   SOCK_RAW 3   A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket.  To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the socket.     SOCK_RDM 4   A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as reliable multicast programming.  This type value is only supported if the Reliable Multicast Protocol is installed.   SOCK_SEQPACKET 5   A socket type that provides a pseudo-stream packet based on datagrams.      In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the  WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are SOCK_DGRAM and SOCK_STREAM."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "protocol",
        "description": "The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type specified. Possible values for the protocol are defined are defined in the  Winsock2.h and Wsrm.h header files.  On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this parameter can be one of the values from the IPPROTO enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly. If a value of  0 is specified, the caller does not               wish to specify a protocol and the service provider will choose the protocol to use.  When the af parameter is AF_INET or AF_INET6 and the type is SOCK_RAW, the value specified for the protocol is set in the protocol field of the IPv6 or IPv4 packet header.  The table below lists common values for the protocol although many other values are possible.   protocolMeaning  IPPROTO_ICMP 1   The Internet Control Message Protocol (ICMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.   IPPROTO_IGMP 2   The Internet Group Management Protocol (IGMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.   BTHPROTO_RFCOMM 3   The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the af parameter is AF_BTH and the type parameter is SOCK_STREAM.  This protocol value is supported on Windows XP with SP2 or later.   IPPROTO_TCP 6   The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter is SOCK_STREAM.   IPPROTO_UDP 17   The User Datagram Protocol (UDP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter is SOCK_DGRAM.   IPPROTO_ICMPV6 58   The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6  and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.   IPPROTO_RM 113   The PGM protocol for reliable multicast. This is a possible value when the af parameter is AF_INET and the type parameter is SOCK_RDM. On the Windows SDK released for Windows Vista and later,  this protocol is also called IPPROTO_PGM.  This protocol value is only supported if the Reliable Multicast Protocol is installed."
      },
      {
        "in_out": "_In_",
        "type": "LPWSAPROTOCOL_INFO",
        "name": "lpProtocolInfo",
        "description": "A pointer to a  WSAPROTOCOL_INFO structure that defines the characteristics of the socket to be created. If this parameter is not NULL, the socket will be bound to the provider associated with the indicated  WSAPROTOCOL_INFO structure."
      },
      {
        "in_out": "_In_",
        "type": "GROUP",
        "name": "g",
        "description": "An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group.  If g is an existing socket group ID, join the new socket to this             socket group, provided all the requirements set by this group are met.  If g is not an existing socket group ID, then the following values are possible.  gMeaning   0   No group operation is performed.    SG_UNCONSTRAINED_GROUP 0x01   Create an unconstrained socket group and have the new socket  be the first member. For an unconstrained group, Winsock does not constrain all sockets in the socket group to have been created with the same value for the type and protocol parameters.    SG_CONSTRAINED_GROUP 0x02   Create a constrained socket group and have the new socket  be the first member. For a contrained socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the type and protocol parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.       Note  The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are not currently defined in a public header file."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "A set of flags used to specify additional socket attributes.  A combination of these flags may be set, although some combinations are not allowed.   ValueMeaning  WSA_FLAG_OVERLAPPED 0x01   Create a socket that supports overlapped I/O operations. Most sockets should be created with this flag set. Overlapped sockets can utilize  WSASend,  WSASendTo,  WSARecv,  WSARecvFrom, and  WSAIoctl for overlapped I/O operations, which allow multiple operations to be initiated and in progress simultaneously.  All functions that allow overlapped operation (WSASend,  WSARecv,  WSASendTo,  WSARecvFrom,  WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operations are NULL.   WSA_FLAG_MULTIPOINT_C_ROOT 0x02   Create a socket that will be a c_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is rooted. This would be indicated by the dwServiceFlags1   member of the WSAPROTOCOL_INFO structure  with the XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_CONTROL_PLANE  flags set.  When the lpProtocolInfo parameter is not NULL, the  WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter.  When the lpProtocolInfo parameter is NULL, the  WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the  af, type, and protocol parameters.  Refer to  Multipoint and Multicast Semantics for additional information on a multipoint session.   WSA_FLAG_MULTIPOINT_C_LEAF 0x04   Create a socket that will be a c_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is non-rooted. This would be indicated by the dwServiceFlags1   member of the WSAPROTOCOL_INFO structure  with the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_CONTROL_PLANE  flag not set.  When the lpProtocolInfo parameter is not NULL, the  WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter.  When the lpProtocolInfo parameter is NULL, the  WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the  af, type, and protocol parameters.  Refer to  Multipoint and Multicast Semantics for additional information on a multipoint session.   WSA_FLAG_MULTIPOINT_D_ROOT 0x08   Create a socket that will be a d_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is rooted. This would be indicated by the dwServiceFlags1   member of the WSAPROTOCOL_INFO structure  with the XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_DATA_PLANE  flags set.  When the lpProtocolInfo parameter is not NULL, the  WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter.  When the lpProtocolInfo parameter is NULL, the  WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the  af, type, and protocol parameters.  Refer to  Multipoint and Multicast Semantics for additional information on a multipoint session.   WSA_FLAG_MULTIPOINT_D_LEAF 0x10   Create a socket that will be a d_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is non-rooted. This would be indicated by the dwServiceFlags1   member of the WSAPROTOCOL_INFO structure  with the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_DATA_PLANE  flag not set.  When the lpProtocolInfo parameter is not NULL, the  WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter.  When the lpProtocolInfo parameter is NULL, the  WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the  af, type, and protocol parameters.  Refer to  Multipoint and Multicast Semantics for additional information on a multipoint session.   WSA_FLAG_ACCESS_SYSTEM_SECURITY 0x40   Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access control list (SACL) as opposed to just a discretionary access control list (DACL). SACLs are used for generating audits and alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the socket should be allowed to bind to a specific address specified to the bind function. The ACCESS_SYSTEM_SECURITY access right controls the ability to get or set the SACL in an object's security descriptor. The system grants this access right only if the SE_SECURITY_NAME privilege is enabled in the access token of the requesting thread.     WSA_FLAG_NO_HANDLE_INHERIT 0x80   Create a socket that is non-inheritable.  A socket handle created by the WSASocket or the socket function is inheritable by default. When this flag is set, the socket handle is non-inheritable.  The GetHandleInformation function can be used to determine if a socket handle was created with the WSA_FLAG_NO_HANDLE_INHERIT flag set. The GetHandleInformation function will return that the HANDLE_FLAG_INHERIT value is set. This flag is supported on Windows 7 with SP1,  Windows Server 2008 R2 with SP1, and later      Important  For multipoint sockets, only one of WSA_FLAG_MULTIPOINT_C_ROOT or WSA_FLAG_MULTIPOINT_C_LEAF flags can be specified, and only  one of WSA_FLAG_MULTIPOINT_D_ROOT or WSA_FLAG_MULTIPOINT_D_LEAF flags can be specified. Refer to  Multipoint and Multicast Semantics for additional information."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 2,
    "description": "The  WSAStartup function initiates use of the Winsock DLL by a process.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If successful, the  WSAStartup function returns zero. Otherwise, it returns one of the error codes listed below. The WSAStartup function directly returns the extended error code in the return value for this function. A call to the WSAGetLastError function is not needed and should  not be used.  ",
    "remarks": "The  WSAStartup function must be the first Windows Sockets function called by an application or DLL. It allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation. The application or DLL can only issue further Windows Sockets functions after successfully calling  WSAStartup. In order to support various Windows Sockets implementations and applications that can have functional differences from the latest version of Windows Sockets specification, a negotiation takes place in  WSAStartup. The caller of  WSAStartup passes in the wVersionRequested parameter the highest version of the Windows Sockets specification that the application supports. The Winsock DLL indicates the highest version of the Windows Sockets specification that it can support in its response. The Winsock DLL also replies with version of the Windows Sockets specification that it expects the caller to use. When an application or DLL calls the  WSAStartup function, the Winsock DLL examines the version of the Windows Sockets specification requested by the application passed in the  wVersionRequested parameter. If the version requested by the application is equal to or higher than the lowest version supported by the Winsock DLL, the call succeeds and the Winsock DLL returns detailed information in the WSADATA structure pointed to by the lpWSAData parameter. The wHighVersion member of the WSADATA structure indicates the highest version of the Windows Sockets specification that the Winsock DLL supports.  The wVersion member of the WSADATA structure indicates the version of the Windows Sockets specification that the Winsock DLL expects the caller to use. If the wVersion member of the  WSADATA structure is unacceptable to the caller, the application or DLL should call  WSACleanup to release the Winsock DLL  resources and fail to initialize the Winsock application. In order to support this application or DLL,  it will be necessary to search for an updated version of the Winsock DLL to install on the platform. The current version of the Windows Sockets specification is version 2.2. The current Winsock DLL, Ws2_32.dll, supports applications that request  any of the following  versions of Windows Sockets specification: To get full access to the new syntax of a higher version of the Windows Sockets specification, the application must negotiate for this higher version. In this case, the wVersionRequested parameter should be set to request version 2.2.  The application must also fully conform to that higher version of the Windows Socket specification, such as compiling against the appropriate header file, linking with a new library, or other special cases. The Winsock2.h header file for Winsock 2 support is included with the Microsoft Windows Software Development Kit (SDK). Windows Sockets version 2.2 is supported on Windows Server 2008,    Windows Vista, Windows Server 2003,   Windows XP,   Windows 2000, Windows NT 4.0 with Service Pack 4 (SP4) and later,   Windows Me,   Windows 98, and Windows 95 OSR2.    Windows Sockets version 2.2 is also supported on      Windows 95 with the Windows Socket 2 Update. Applications on these platforms should normally request Winsock 2.2 by setting the wVersionRequested parameter accordingly. On Windows 95 and versions of Windows NT 3.51 and earlier, Windows Sockets version 1.1 is the highest version of the Windows Sockets specification supported. It is legal and possible for an application or DLL written to use a lower version of the Windows Sockets specification that is supported by the Winsock DLL to successfully negotiate this lower version using the  WSAStartup function. For example, an application can request version 1.1 in the wVersionRequested parameter passed to the WSAStartup function on a platform with the Winsock 2.2 DLL. In this case, the application should only rely on features that fit within the version requested. New Ioctl codes, new behavior of existing functions, and new functions should not be used. The version negotiation provided by the WSAStartup was primarily used to allow older Winsock 1.1 applications developed for Windows 95 and   Windows NT 3.51 and earlier to run with the same behavior on later versions of Windows. The Winsock.h header file for Winsock 1.1 support is included with the Windows SDK. This negotiation in the WSAStartup function allows both the application or DLL that uses Windows Sockets  and the Winsock DLL to support a range of Windows Sockets versions. An application or DLL can use the Winsock DLL if there is any overlap in the version ranges. Detailed information on the Windows Sockets implementation is provided in the  WSADATA structure returned by the WSAStartup function. The following table shows how  WSAStartup works with different applications and Winsock DLL versions.  Once an application or DLL has made a successful  WSAStartup call, it can proceed to make other Windows Sockets calls as needed. When it has finished using the services of the Winsock DLL, the application must call  WSACleanup to allow the Winsock DLL to free internal Winsock resources used by the application. An application can call  WSAStartup more than once if it needs to obtain the  WSADATA structure information more than once. On each such call, the application can specify any version number supported by the Winsock DLL. The  WSAStartup function typically leads to protocol-specific helper DLLs being loaded. As a result, the  WSAStartup function should not be called from the DllMain function in a application DLL. This can potentially cause deadlocks. For more information, please see the DLL Main Function. An application must call the WSACleanup function for every successful  time the WSAStartup function is called.  This means, for example, that if an application calls  WSAStartup three times, it must call  WSACleanup three times. The first two calls to  WSACleanup do nothing except decrement an internal counter; the final  WSACleanup call for the task does all necessary resource deallocation for the task.  Windows Phone 8: This  function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. The following code fragment demonstrates how an application that supports only version 2.2 of Windows Sockets makes a  WSAStartup call: ",
    "return_type": "int",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAStartup",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "WORD",
        "name": "wVersionRequested",
        "description": "The highest version of Windows Sockets specification that the caller can use. The high-order byte specifies the minor version number; the low-order byte specifies the major version number."
      },
      {
        "in_out": "_Out_",
        "type": "LPWSADATA",
        "name": "lpWSAData",
        "description": "A pointer to the  WSADATA data structure that is to receive details of the Windows Sockets implementation."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAStringToAddress function converts a network address in its standard text   presentation form into its numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "The return value for  WSAStringToAddress is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling  WSAGetLastError.  ",
    "remarks": "The  WSAStringToAddress function converts a network address in standard text   form into its numeric binary form in a sockaddr structure. Any missing components of the address will be defaulted to a reasonable value, if possible. For example, a missing port number will default to zero. If the caller wants the translation to be done by a particular provider, it should supply the corresponding  WSAPROTOCOL_INFO structure in the lpProtocolInfo parameter. The  WSAStringToAddress function fails (and returns WSAEINVAL) if the sin_family member of the SOCKADDR_IN structure, which is passed in the lpAddress parameter in the form of a  sockaddr structure, is not set to AF_INET or AF_INET6. Support for IPv6 addresses using the WSAStringToAddress function was added on Windows XP with Service Pack 1 (SP1)   and later. IPv6 must also be installed on the local computer for the WSAStringToAddress function to support IPv6 addresses. Windows Phone 8: This  function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "INT WSAAPI",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAStringToAddress",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPTSTR",
        "name": "AddressString",
        "description": "A pointer to the zero-terminated string that contains the network address in standard text form to convert."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "AddressFamily",
        "description": "The address family of the network address pointed to by the AddressString parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPWSAPROTOCOL_INFO",
        "name": "lpProtocolInfo",
        "description": "The  WSAPROTOCOL_INFO structure associated with the provider to be used. If this is NULL, the call is routed to the provider of the first protocol supporting the indicated AddressFamily."
      },
      {
        "in_out": "_Out_",
        "type": "LPSOCKADDR",
        "name": "lpAddress",
        "description": "A pointer to a buffer that is filled with a  sockaddr structure for the address string if the function succeeds."
      },
      {
        "in_out": "_Inout_",
        "type": "LPINT",
        "name": "lpAddressLength",
        "description": "A pointer to the length, in bytes, of the buffer pointed to by the lpAddress parameter. If the function call is successful, this parameter returns a pointer to the size of the sockaddr structure returned in the lpAddress parameter. If the specified buffer is not large enough, the function fails with a specific error of  WSAEFAULT and this parameter is updated with the required size in bytes."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  },
  {
    "n_arguments": 5,
    "description": "The  WSAWaitForMultipleEvents function returns when one or all of the specified event objects are in the signaled state, when the time-out interval expires, or when an I/O completion routine has executed.",
    "library": "Ws2_32.lib",
    "min_server": "Windows Server 2003 [desktop apps | Windows Store apps]",
    "header": "Winsock2.h",
    "return_value": "If the  WSAWaitForMultipleEvents function succeeds,  the return value upon success is one of the following values.  If the WSAWaitForMultipleEvents function fails, the return value is WSA_WAIT_FAILED. The following table lists values that can be used with WSAGetLastError to get extended error information.  ",
    "remarks": "The WSAWaitForMultipleEvents function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state. It uses no processor time while waiting for the criteria to be met.  The  WSAWaitForMultipleEvents function returns when any one or all of the specified objects are in the signaled state, or when the time-out interval elapses. When the bWaitAll parameter is TRUE, the wait operation is completed only when the states of all objects have been set to signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled. When bWaitAll parameter is FALSE, WSAWaitForMultipleEvents checks the handles in the lphEvents array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the lphEvents array whose object was signaled. This function is also used to perform an alertable wait by setting the fAlertable parameter to TRUE. This enables the function to return when the system executes an I/O completion routine by the calling thread. A thread must be in an alertable wait state in order for the system to execute I/O completion routines (asynchronous procedure calls or APCs). So if an application calls WSAWaitForMultipleEvents when there are pending asynchronous operations that have I/O completion routines and the fAlertable parameter is FALSE, then those I/O completion routines will not be executed even if those I/O operations are completed.  If the fAlertable parameter is TRUE and one of the pending operations completes, the APC is executed and WSAWaitForMultipleEvents will return WSA_IO_COMPLETION. The pending event is not signaled yet. The application must call the WSAWaitForMultipleEvents function again. Applications that require an alertable wait state without waiting for any event objects to be signaled should use the Windows  SleepEx function. The current implementation of WSAWaitForMultipleEvents calls the WaitForMultipleObjectsEx function. The following code example shows how to use the WSAWaitForMultipleEvents function. Windows Phone 8: This  function is supported for Windows Phone Store apps on Windows Phone 8 and later. Windows 8.1 and Windows Server 2012 R2: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later. ",
    "return_type": "DWORD",
    "category": "Windows Sockets (Winsock)",
    "name": "WSAWaitForMultipleEvents",
    "is_callback": 0,
    "dll": "Ws2_32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cEvents",
        "description": "The number of event object handles in the array pointed to by lphEvents. The maximum number of event object handles is WSA_MAXIMUM_WAIT_EVENTS. One or more events must be specified."
      },
      {
        "in_out": "_In_",
        "type": "const WSAEVENT*",
        "name": "lphEvents",
        "description": "A pointer to an array of event object handles. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle if the fWaitAll parameter is set to TRUE.  If one of these handles is closed while the wait is still pending, the behavior of WSAWaitForMultipleEvents is undefined.  The handles must have the SYNCHRONIZE access right.  For more information, see Standard Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fWaitAll",
        "description": "A value that specifies the wait type. If TRUE, the function returns when the state of all objects in the lphEvents array is signaled. If FALSE, the function returns when any  of the event objects is signaled. In the latter case, the return value minus WSA_WAIT_EVENT_0 indicates the index of the event object whose state caused the function to return. If more than one event object became signaled during the call, this is the array index to the signaled event object with the smallest index value of all the signaled event objects."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwTimeout",
        "description": "The time-out interval, in milliseconds. WSAWaitForMultipleEvents returns if the time-out interval expires, even if conditions specified by the fWaitAll parameter are not satisfied. If the dwTimeout parameter is zero, WSAWaitForMultipleEvents tests the state of the specified event objects and returns immediately. If dwTimeout is WSA_INFINITE, WSAWaitForMultipleEvents waits forever; that is, the time-out interval never expires."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fAlertable",
        "description": "A value that specifies whether the thread is placed in an alertable wait state so the system can execute I/O completion routines. If TRUE, the thread is placed in an alertable wait state and WSAWaitForMultipleEvents can return when the system executes an I/O completion routine. In this case, WSA_WAIT_IO_COMPLETION is returned and the event that was being waited on is not signaled yet. The application must call the WSAWaitForMultipleEvents function again. If FALSE, the thread is not placed in an alertable wait state and I/O completion routines are not executed."
      }
    ],
    "min_client": "Windows 8.1, Windows Vista [desktop apps | Windows Store apps]"
  }
]

