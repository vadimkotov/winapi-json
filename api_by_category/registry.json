[
  {
    "n_arguments": 2,
    "description": "Retrieves the current size of the registry and the  maximum size that the registry is allowed to attain on the system.",
    "library": "Kernel32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see Using the Windows Headers. ",
    "return_type": "BOOL WINAPI",
    "category": "Registry",
    "name": "GetSystemRegistryQuota",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_opt_",
        "type": "PDWORD",
        "name": "pdwQuotaAllowed",
        "description": "A pointer to a variable that receives the maximum size that the registry is allowed to attain on this system, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PDWORD",
        "name": "pdwQuotaUsed",
        "description": "A pointer to a variable that receives the current size of  the registry, in bytes."
      }
    ],
    "min_client": "Windows Vista, Windows XP with SP1 [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Closes a handle to the specified registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "The handle for a specified key should not be used after it has been closed, because it will no longer be valid. Key handles should not be left open any longer than necessary. The  RegCloseKey function does not necessarily write information to the registry before returning; it can take as much as several seconds for the cache to be flushed to the hard disk. If an application must explicitly write registry information to the hard disk, it can use the  RegFlushKey function.  RegFlushKey, however, uses many system resources and should be called only when necessary. For an example, see  Deleting a Key with Subkeys. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegCloseKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to the open key to be closed. The handle must have been opened by the  RegCreateKeyEx,  RegCreateKeyTransacted, RegOpenKeyEx, RegOpenKeyTransacted, or RegConnectRegistry function."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Establishes a connection to a predefined registry key on another computer.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "RegConnectRegistry requires the Remote Registry service to be running on the remote computer. By default, this service is configured to be started manually. To configure the Remote Registry service to start automatically, run Services.msc and change the Startup Type of the service to Automatic. Windows Server 2003 and Windows XP/2000:  The Remote Registry service is configured to start automatically by default. When a handle returned by  RegConnectRegistry is no longer needed, it should be closed by calling  RegCloseKey. If the computer is joined to a workgroup and the \"Force network logons using local accounts to authenticate as Guest\" policy is enabled, the function fails. Note that this policy is enabled by default if the  computer is joined to a workgroup. If the current user does not have proper access to the remote computer, the call to RegConnectRegistry fails. To connect to a remote registry, call LogonUser with LOGON32_LOGON_NEW_CREDENTIALS and ImpersonateLoggedOnUser before calling RegConnectRegistry. Windows 2000:  One possible workaround is to establish a session to an administrative share such as IPC$ using a different set of credentials. To specify credentials other than those of the current user, use the WNetAddConnection2 function to connect to the share. When you have finished accessing the registry, cancel the connection. Windows XP Home Edition:  You cannot use this function  to connect to a remote computer running Windows XP Home Edition. This function does work with the name of the local computer even if it is running Windows XP Home Edition because this bypasses the authentication layer. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegConnectRegistry",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpMachineName",
        "description": "The name of the remote computer. The string has the following form:     \\\\computername The caller must have access to the remote computer or the function fails. If this parameter is NULL, the local computer name is used."
      },
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A predefined registry handle. This parameter can be one of the following  predefined keys on the remote computer.      HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_USERS"
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a key handle identifying the predefined handle on the remote computer."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Copies the specified registry key, along with its values and subkeys, to the specified destination key.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "This function also copies the security descriptor for the key. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegCopyTree",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKeySrc",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_READ access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the predefined keys."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the key. This key must be a subkey of the key identified by the hKeySrc parameter. This parameter can also be NULL."
      },
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKeyDest",
        "description": "A handle to the destination key. The calling process  must have KEY_CREATE_SUB_KEY access to the key.      This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the predefined keys."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 9,
    "description": "Creates the specified registry key. If the key already exists, the function opens it. Note that key names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "The key that the  RegCreateKeyEx function creates has no values. An application can use the  RegSetValueEx function to set key values. The RegCreateKeyEx function creates all missing keys in the specified path. An application can take advantage of this behavior to create several keys at once. For example, an application can create a subkey four levels deep at the same time as the three preceding subkeys by specifying a string of the following form for the lpSubKey parameter: subkey1\\subkey2\\subkey3\\subkey4 Note that this behavior will result in creation of unwanted keys if an existing key in the path is spelled incorrectly. An application cannot create a key that is a direct child of HKEY_USERS or HKEY_LOCAL_MACHINE. An application can create subkeys in lower levels of the HKEY_USERS or HKEY_LOCAL_MACHINE trees. If your service or application impersonates different users, do not use this function with HKEY_CURRENT_USER. Instead, call the RegOpenCurrentUser function. Note that operations that access certain registry keys are redirected. For more information,  see Registry Virtualization and 32-bit and 64-bit Application Data in the Registry. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegCreateKeyEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The calling process  must have KEY_CREATE_SUB_KEY access to the key. For more information, see  Registry Key Security and Access Rights. Access for key creation is checked against the security descriptor of the registry key, not the access mask specified when the handle was obtained. Therefore, even if hKey was opened with a samDesired of KEY_READ, it   can be used in operations that modify the registry if allowed by its security descriptor. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys:     HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of a subkey that this function opens or creates. The subkey specified must be a subkey of the key identified by the hKey parameter; it can be up to 32 levels deep in the registry tree. For more information on key names, see Structure of the Registry. If lpSubKey is a pointer to an empty string, phkResult receives a new handle to the key specified by hKey. This parameter cannot be NULL."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "Reserved",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpClass",
        "description": "The user-defined class type of this key. This parameter may be ignored. This parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOptions",
        "description": "This parameter can be one of the following values.  ValueMeaning  REG_OPTION_BACKUP_RESTORE 0x00000004L   If this flag is set, the function ignores the samDesired parameter and attempts to open the key with the access required to backup or restore the key. If the calling thread has the SE_BACKUP_NAME privilege enabled, the key is opened with the ACCESS_SYSTEM_SECURITY and KEY_READ access rights. If the calling thread has the SE_RESTORE_NAME privilege enabled, beginning with Windows Vista, the key is opened with the ACCESS_SYSTEM_SECURITY, DELETE and KEY_WRITE access rights. If both privileges are enabled, the key has the combined access rights for both privileges. For more information, see  Running with Special Privileges.   REG_OPTION_CREATE_LINK 0x00000002L   Note  Registry symbolic links should only be used for  for application compatibility when absolutely necessary.    This key is a symbolic link. The target path is assigned to the L\"SymbolicLinkValue\" value of the key. The target path must be an absolute registry path.    REG_OPTION_NON_VOLATILE 0x00000000L   This key is not volatile; this is the default. The information is stored in a file and is preserved when the system is restarted. The  RegSaveKey function saves keys that are not volatile.   REG_OPTION_VOLATILE 0x00000001L   All keys created by the function are volatile. The information is stored in memory and is not preserved when the corresponding registry hive is unloaded. For HKEY_LOCAL_MACHINE, this occurs only when the system initiates a full shutdown. For registry keys loaded by the  RegLoadKey function, this occurs when the corresponding  RegUnLoadKey is performed. The  RegSaveKey function does not save volatile keys. This flag is ignored for keys that already exist.     \t\t\t\t\t\t\t Note  On a user selected shutdown, a fast startup shutdown is the default behavior for the system."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "A mask that specifies the access rights for the key to be created. For more information, see  Registry Key Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpSecurityAttributes is NULL, the handle cannot be inherited.     The lpSecurityDescriptor member of the structure specifies a security descriptor for the new key. If lpSecurityAttributes is NULL, the key gets a default security descriptor. The ACLs in a default security descriptor for a key are inherited from its direct parent key."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened or created key. If the key is not one of the predefined registry keys, call the  RegCloseKey function after you have finished using the handle."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpdwDisposition",
        "description": "A pointer to a variable that receives one of the following disposition values.  ValueMeaning  REG_CREATED_NEW_KEY 0x00000001L   The key did not exist and was created.   REG_OPENED_EXISTING_KEY 0x00000002L   The key existed and was simply opened without being changed.     If lpdwDisposition is NULL, no disposition information is returned."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 11,
    "description": "Creates the specified registry key and associates it with a  transaction. If the key already exists, the function opens it. Note that key names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "When a key is created using this function, subsequent operations on the key are transacted. If a non-transacted operation is performed on the key before the transaction is committed, the transaction is rolled back. After a transaction is committed or rolled back, you must re-open the key using RegCreateKeyTransacted or RegOpenKeyTransacted with an active transaction handle to make additional operations transacted. For more information about transactions, see Kernel Transaction Manager. Note that subsequent operations on subkeys of this key are not automatically transacted. Therefore,  RegDeleteKeyEx does not perform a transacted delete operation. Instead, use the RegDeleteKeyTransacted function to perform a transacted delete operation. The key that the  RegCreateKeyTransacted function creates has no values. An application can use the  RegSetValueEx function to set key values. The RegCreateKeyTransacted function creates all missing keys in the specified path. An application can take advantage of this behavior to create several keys at once. For example, an application can create a subkey four levels deep at the same time as the three preceding subkeys by specifying a string of the following form for the lpSubKey parameter: subkey1\\subkey2\\subkey3\\subkey4 Note that this behavior will result in creation of unwanted keys if an existing key in the path is spelled incorrectly. An application cannot create a key that is a direct child of HKEY_USERS or HKEY_LOCAL_MACHINE. An application can create subkeys in lower levels of the HKEY_USERS or HKEY_LOCAL_MACHINE trees. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegCreateKeyTransacted",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The calling process  must have KEY_CREATE_SUB_KEY access to the key. For more information, see  Registry Key Security and Access Rights. Access for key creation is checked against the security descriptor of the registry key, not the access mask specified when the handle was obtained. Therefore, even if hKey was opened with a samDesired of KEY_READ, it   can be used in operations that create keys if allowed by its security descriptor. This handle is returned by the  RegCreateKeyTransacted or  RegOpenKeyTransacted function, or it can be one of the following  predefined keys:     HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of a subkey that this function opens or creates. The subkey specified must be a subkey of the key identified by the hKey parameter; it can be up to 32 levels deep in the registry tree. For more information on key names, see Structure of the Registry. If lpSubKey is a pointer to an empty string, phkResult receives a new handle to the key specified by hKey. This parameter cannot be NULL."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "Reserved",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPTSTR",
        "name": "lpClass",
        "description": "The user-defined class of this key. This parameter may be ignored. This parameter can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwOptions",
        "description": "This parameter can be one of the following values.  ValueMeaning  REG_OPTION_BACKUP_RESTORE 0x00000004L   If this flag is set, the function ignores the samDesired parameter and attempts to open the key with the access required to backup or restore the key. If the calling thread has the SE_BACKUP_NAME privilege enabled, the key is opened with the ACCESS_SYSTEM_SECURITY and KEY_READ access rights. If the calling thread has the SE_RESTORE_NAME privilege enabled, the key is opened with the ACCESS_SYSTEM_SECURITY and KEY_WRITE access rights. If both privileges are enabled, the key has the combined access rights for both privileges. For more information, see  Running with Special Privileges.   REG_OPTION_NON_VOLATILE 0x00000000L   This key is not volatile; this is the default. The information is stored in a file and is preserved when the system is restarted. The  RegSaveKey function saves keys that are not volatile.   REG_OPTION_VOLATILE 0x00000001L   All keys created by the function are volatile. The information is stored in memory and is not preserved when the corresponding registry hive is unloaded. For HKEY_LOCAL_MACHINE, this occurs when the system is shut down. For registry keys loaded by the  RegLoadKey function, this occurs when the corresponding  RegUnLoadKey is performed. The  RegSaveKey function does not save volatile keys. This flag is ignored for keys that already exist."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "A mask that specifies the access rights for the key to be created. For more information, see  Registry Key Security and Access Rights."
      },
      {
        "in_out": "_In_opt_",
        "type": "const LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpSecurityAttributes is NULL, the handle cannot be inherited.     The lpSecurityDescriptor member of the structure specifies a security descriptor for the new key. If lpSecurityAttributes is NULL, the key gets a default security descriptor. The ACLs in a default security descriptor for a key are inherited from its direct parent key."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened or created key. If the key is not one of the predefined registry keys, call the  RegCloseKey function after you have finished using the handle."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpdwDisposition",
        "description": "A pointer to a variable that receives one of the following disposition values.  ValueMeaning  REG_CREATED_NEW_KEY 0x00000001L   The key did not exist and was created.   REG_OPENED_EXISTING_KEY 0x00000002L   The key existed and was simply opened without being changed.     If lpdwDisposition is NULL, no disposition information is returned."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to an active transaction. This handle is returned by the CreateTransaction function."
      },
      {
        "in_out": "_Reserved_",
        "type": "PVOID",
        "name": "pExtendedParemeter",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Deletes a subkey and its values. Note that key names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. To get a generic description of the error, you can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag. ",
    "remarks": "A deleted key is not removed until the last handle to it is closed. The subkey to be deleted must not have subkeys. To delete a key and all its subkeys, you need to enumerate the subkeys and delete them individually. To delete keys recursively, use the  RegDeleteTree or SHDeleteKey function. For an example that uses this function, see Deleting a Key with Subkeys. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDeleteKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The access rights of this key do not affect the delete operation. For more information about access rights, see  Registry Key Security and Access Rights. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  Predefined Keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the key to be deleted. It must be a subkey of the key that hKey identifies, but it cannot have subkeys. This parameter cannot be NULL. The function opens the subkey with the DELETE access right.  Key names are not case sensitive. For more information, see  Registry Element Size Limits."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Deletes a subkey and its values from the specified platform-specific view of the registry. Note that key names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "A deleted key is not removed until the last handle to it is closed. On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications view. This function enables an application to delete an entry in the alternate registry view. The subkey to be deleted must not have subkeys. To delete a key and all its subkeys, you need to enumerate the subkeys and delete them individually. To delete keys recursively, use the  RegDeleteTree or SHDeleteKey function. If the function succeeds, RegDeleteKeyEx removes the specified key from the registry. The entire key, including all of its values, is removed. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDeleteKeyEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The access rights of this key do not affect the delete operation. For more information about access rights, see  Registry Key Security and Access Rights. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the key to be deleted. This key must be a subkey of the key specified by the value of the hKey parameter.  The  function opens the subkey with the DELETE access right.  Key names are not case sensitive. The value of this parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "An access mask the specifies the platform-specific view of the registry.  ValueMeaning  KEY_WOW64_32KEY 0x0200   Delete the key from the 32-bit registry view.   KEY_WOW64_64KEY 0x0100   Delete the key from the 64-bit registry view."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "Reserved",
        "description": "This parameter is reserved and must be zero."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Deletes a subkey and its values from the specified platform-specific view of the registry as a transacted operation. Note that key names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "A deleted key is not removed until the last handle to it is closed. On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications view. This function enables an application to delete an entry in the alternate registry view. The subkey to be deleted must not have subkeys. To delete a key and all its subkeys, you need to enumerate the subkeys and delete them individually. To delete keys recursively, use the  RegDeleteTree or SHDeleteKey function. If the function succeeds, RegDeleteKeyTransacted removes the specified key from the registry. The entire key, including all of its values, is removed. To remove the entire tree as a transacted operation, use the RegDeleteTree function with a handle returned from RegCreateKeyTransacted or RegOpenKeyTransacted. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDeleteKeyTransacted",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The access rights of this key do not affect the delete operation. For more information about access rights, see  Registry Key Security and Access Rights. This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the key to be deleted. This key must be a subkey of the key specified by the value of the hKey parameter.  The  function opens the subkey with the DELETE access right.  Key names are not case sensitive. The value of this parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "An access mask the specifies the platform-specific view of the registry.  ValueMeaning  KEY_WOW64_32KEY 0x0200   Delete the key from the 32-bit registry view.   KEY_WOW64_64KEY 0x0100   Delete the key from the 64-bit registry view."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "Reserved",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to an active transaction. This handle is returned by the CreateTransaction function."
      },
      {
        "in_out": "_Reserved_",
        "type": "PVOID",
        "name": "pExtendedParameter",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Removes the specified  value from the specified registry key and subkey.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDeleteKeyValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_SET_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys:      HKEY_CLASSES_ROOT    HKEY_CURRENT_CONFIG    HKEY_CURRENT_USER    HKEY_LOCAL_MACHINE    HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the registry key. This key must be a subkey of the key identified by the hKey parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpValueName",
        "description": "The registry value to be removed from the key."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Deletes the subkeys and values of the specified key recursively.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "If the key has values, it must be opened with KEY_SET_VALUE or this function will fail with ERROR_ACCESS_DENIED. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDeleteTree",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the following access rights: DELETE, KEY_ENUMERATE_SUB_KEYS, and KEY_QUERY_VALUE. For more information, see  Registry Key Security and Access Rights. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  Predefined Keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the key. This key must be a subkey of the key identified by the hKey parameter. If this parameter is NULL, the subkeys and values of hKey are deleted."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Removes a named value from the specified registry key. Note that value names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDeleteValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_SET_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys:      HKEY_CLASSES_ROOT    HKEY_CURRENT_CONFIG    HKEY_CURRENT_USER    HKEY_LOCAL_MACHINE    HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpValueName",
        "description": "The registry value to be removed. If this parameter is NULL or an empty string, the value set by the  RegSetValue function is removed.     For more information, see  Registry Element Size Limits."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Disables handle caching of the predefined registry handle for HKEY_CURRENT_USER for the current process. This function does not work on a remote computer.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. ",
    "remarks": "Any access of HKEY_CURRENT_USER after this function is called will result in operations being performed on HKEY_USERS\\SID_of_current_user,  or on HKEY_USERS\\.DEFAULT if the current user's hive is not loaded. For more information on SIDs, see  Security Identifiers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDisablePredefinedCache",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 0,
    "description": "Disables handle caching for all predefined registry handles for the current process.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. ",
    "remarks": "This function does not work on a remote computer. Services that change impersonation should call this function before using any of the predefined handles. For example, any access of HKEY_CURRENT_USER after this function is called results in open and close operations being performed on HKEY_USERS\\SID_of_current_user, or on HKEY_USERS\\.DEFAULT if the current user's hive is not loaded. For more information on SIDs, see  Security Identifiers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDisablePredefinedCacheEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Disables registry reflection for the specified key. Disabling reflection for a key does not affect reflection of any subkeys.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications view. Registry reflection copies specific registry keys and values between the two views. To restore registry reflection for a disabled key, use the RegEnableReflectionKey function. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegDisableReflectionKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hBase",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function; it cannot specify a key on a remote computer. If the key is not on the reflection list, the function succeeds but has no effect. For more information, see Registry Redirector     and Registry Reflection."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Restores registry reflection for the specified disabled key. Restoring reflection for a key does not affect reflection of any subkeys.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications view. Registry reflection copies specific registry keys and values between the two views. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegEnableReflectionKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hBase",
        "description": "A handle to the registry key that was previously disabled using the RegDisableReflectionKey function. This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function; it cannot specify a key on a remote computer. If the key is not on the reflection list, this function succeeds but has no effect. For more information, see Registry Redirector     and Registry Reflection."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Enumerates the subkeys of the specified open registry key. The function retrieves information about one subkey each time it is called.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If there are no more subkeys available, the function returns ERROR_NO_MORE_ITEMS. If the lpName buffer is too small to receive the name of the key, the function returns ERROR_MORE_DATA. ",
    "remarks": "To enumerate subkeys, an application should initially call the  RegEnumKeyEx function with the dwIndex parameter set to zero. The application should then increment the dwIndex parameter and call  RegEnumKeyEx until there are no more subkeys (meaning the function returns ERROR_NO_MORE_ITEMS). The application can also set dwIndex to the index of the last subkey on the first call to the function and decrement the index until the subkey with the index 0 is enumerated. To retrieve the index of the last subkey, use the  RegQueryInfoKey function. While an application is using the  RegEnumKeyEx function, it should not make calls to any registration functions that might change the key being enumerated. Note that operations that access certain registry keys are redirected. For more information,  see Registry Virtualization and 32-bit and 64-bit Application Data in the Registry. For an example, see  Enumerating Registry Subkeys. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegEnumKeyEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_ENUMERATE_SUB_KEYS access right. For more information, see  Registry Key Security and Access Rights. This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIndex",
        "description": "The index of the subkey to retrieve. This parameter should be zero for the first call to the  RegEnumKeyEx function and then incremented for subsequent calls.     Because subkeys are not ordered, any new subkey will have an arbitrary index. This means that the function may return subkeys in any order."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpName",
        "description": "A pointer to a buffer that receives the name of the subkey, including the terminating null character. The function copies only the name of the subkey, not the full key hierarchy, to the buffer.    If the function fails, no information is copied to this buffer. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpcName",
        "description": "A pointer to a variable that specifies the size of the buffer specified by the lpName parameter, in characters. This size should include the terminating null character. If the function succeeds, the variable pointed to by lpcName contains the number of characters stored in the buffer, not including the terminating null character. To determine the required buffer size, use the  RegQueryInfoKey function to determine the size of the largest subkey for the key identified by the hKey parameter."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPDWORD",
        "name": "lpReserved",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_Inout_",
        "type": "LPTSTR",
        "name": "lpClass",
        "description": "A pointer to a buffer that receives the user-defined class of the enumerated subkey. This parameter can be NULL."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "lpcClass",
        "description": "A pointer to a variable that specifies the size of the buffer specified by the lpClass parameter, in characters. The size should include the terminating null character. If the function succeeds, lpcClass contains the number of characters stored in the buffer, not including the terminating null character. This parameter can be NULL only if lpClass is NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PFILETIME",
        "name": "lpftLastWriteTime",
        "description": "A pointer to FILETIME structure that receives the time at which the enumerated subkey was last written. This parameter can be NULL."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Enumerates the values for the specified open registry key. The function copies one indexed value name and data block for the key each time it is called.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If there are no more values available, the function returns ERROR_NO_MORE_ITEMS. If the lpData buffer is too small to receive the value, the function returns ERROR_MORE_DATA. ",
    "remarks": "To enumerate values, an application should initially call the  RegEnumValue function with the dwIndex parameter set to zero. The application should then increment dwIndex and call the  RegEnumValue function until there are no more values (until the function returns ERROR_NO_MORE_ITEMS). The application can also set dwIndex to the index of the last value on the first call to the function and decrement the index until the value with index 0 is enumerated. To retrieve the index of the last value, use the  RegQueryInfoKey function. While using  RegEnumValue, an application should not call any registry functions that might change the key being queried. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, the string may not have been stored with the proper null-terminating characters.  Therefore, even if the function returns ERROR_SUCCESS, the application should ensure that the string is properly terminated before using it; otherwise, it may overwrite a buffer. (Note that REG_MULTI_SZ strings should have two null-terminating characters.) To determine the maximum size of the name and data buffers, use the  RegQueryInfoKey function. For an example, see  Enumerating Registry Subkeys. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegEnumValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIndex",
        "description": "The index of the value to be retrieved. This parameter should be zero for the first call to the  RegEnumValue function and then be incremented for subsequent calls.     Because values are not ordered, any new value will have an arbitrary index. This means that the function may return values in any order."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpValueName",
        "description": "A pointer to a buffer that receives the name of the value as a null-terminated string.    This buffer must be large enough to include the terminating null character.  For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpcchValueName",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by the lpValueName parameter, in characters. When the function returns, the variable receives the number of characters stored in the buffer, not including the terminating null character. Registry value names are limited to 32,767 bytes. The ANSI version of this function treats this parameter as a SHORT value. Therefore, if you specify a value greater than 32,767 bytes, there is an overflow and the function may return ERROR_MORE_DATA."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPDWORD",
        "name": "lpReserved",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpType",
        "description": "A pointer to a variable that receives a code indicating the type of data stored in the specified value. For a list of the possible type codes, see  Registry Value Types. The lpType parameter can be NULL if the type code is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPBYTE",
        "name": "lpData",
        "description": "A pointer to a buffer that receives the data for the value entry. This parameter can be NULL if the data is not required.     If lpData is NULL and lpcbData is non-NULL, the function stores the size of the data, in bytes, in the variable pointed to by lpcbData. This enables an application to determine the best way to allocate a buffer for the data."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "lpcbData",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by the lpData parameter, in bytes. When the function returns, the variable receives the number of bytes stored in the buffer.  This parameter can be NULL only if lpData is NULL. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, this size includes any terminating null character or characters. For more information, see Remarks. If the buffer specified by lpData is not large enough to hold the data, the function returns ERROR_MORE_DATA and stores the required buffer size in the variable pointed to by lpcbData. In this case, the contents of lpData are undefined."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Writes all the attributes of the specified open registry key into the registry.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "Calling RegFlushKey is an expensive operation that significantly affects system-wide performance as  it consumes disk bandwidth and blocks modifications to all keys by all processes in the registry hive that is being flushed until the flush operation completes. RegFlushKey should only be called explicitly when an application must guarantee that registry changes are persisted to disk immediately after modification. All modifications made to keys are visible to other processes without the need to flush them to disk. Alternatively, the registry has a 'lazy flush' mechanism that flushes registry modifications to disk at regular intervals of time. In addition to this regular flush operation,  registry changes are also flushed to disk at system shutdown. Allowing the 'lazy flush' to flush registry changes is the most efficient way to manage registry writes to the registry store on  disk. The  RegFlushKey function returns only when all the data for the hive that contains the specified key has been written to the registry store on disk. The  RegFlushKey function writes out the data for other keys in the hive that have been modified since the last lazy flush or system start. After RegFlushKey returns, use RegCloseKey to close the handle to the registry key. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegFlushKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_USERS"
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "The RegGetKeySecurity function retrieves a copy of the security descriptor protecting the specified open registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the function returns ERROR_SUCCESS. If the function fails, it returns a nonzero error code defined in WinError.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "If the buffer specified by the pSecurityDescriptor parameter is too small, the function returns ERROR_INSUFFICIENT_BUFFER and the lpcbSecurityDescriptor parameter contains the number of bytes required for the requested security descriptor. To read the owner, group, or discretionary access control list (DACL) from the key's security descriptor, the calling process must have been granted READ_CONTROL access when the handle was opened. To get READ_CONTROL access, the caller must be the owner of the key or the key's DACL must grant the access. To read the system access control list (SACL) from the security descriptor, the calling process must have been granted ACCESS_SYSTEM_SECURITY access when the key was opened. The correct way to get this access is to enable the SE_SECURITY_NAME privilege in the caller's current token, open the handle for ACCESS_SYSTEM_SECURITY access, and then disable the privilege. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegGetKeySecurity",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open key for which to retrieve the security descriptor."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_INFORMATION",
        "name": "SecurityInformation",
        "description": "A  SECURITY_INFORMATION value that indicates the requested security information."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "pSecurityDescriptor",
        "description": "A pointer to a buffer that receives a copy of the requested security descriptor."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "lpcbSecurityDescriptor",
        "description": "A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the pSecurityDescriptor parameter. When the function returns, the variable contains the number of bytes written to the buffer."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Retrieves the type and data for the specified registry value.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If the pvData buffer is too small to receive the value, the function returns ERROR_MORE_DATA. If dwFlags specifies a combination of both RRF_SUBKEY_WOW6464KEY and  RRF_SUBKEY_WOW6432KEY, the function returns ERROR_INVALID_PARAMETER. ",
    "remarks": "An application typically calls RegEnumValue to determine the value names and then RegGetValue to retrieve the data for the names. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, and the ANSI version of this function is used (either by explicitly calling RegGetValueA or by not defining UNICODE before including the Windows.h file), this function converts the stored Unicode string to an ANSI string before copying it to the buffer pointed to by pvData. When calling this function with hkey set to the HKEY_PERFORMANCE_DATA handle and a value string of a specified object, the returned data structure sometimes has unrequested objects. Do not be surprised; this is normal behavior. You should always expect to walk the returned data structure to look for the requested object. Note that operations that access certain registry keys are redirected. For more information,  see Registry Virtualization and 32-bit and 64-bit Application Data in the Registry. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegGetValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_PERFORMANCE_NLSTEXT HKEY_PERFORMANCE_TEXT HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the registry key. This key must be a subkey of the key specified by the hkey parameter. Key names are not case sensitive."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpValue",
        "description": "The name of the registry value.     If this parameter is NULL or an empty string, \"\", the function retrieves the type and data for the key's unnamed or default value, if any. For more information, see  Registry Element Size Limits. Keys do not automatically have an unnamed or default value. Unnamed values can be of any type."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The flags that restrict the data type of value to be queried. If the data type of the value does not meet this criteria, the function fails. This parameter can be one or more of the following values.  ValueMeaning  RRF_RT_ANY 0x0000ffff   No type restriction.   RRF_RT_DWORD 0x00000018   Restrict type to 32-bit RRF_RT_REG_BINARY | RRF_RT_REG_DWORD.   RRF_RT_QWORD 0x00000048   Restrict type to 64-bit RRF_RT_REG_BINARY | RRF_RT_REG_DWORD.   RRF_RT_REG_BINARY 0x00000008   Restrict type to REG_BINARY.   RRF_RT_REG_DWORD 0x00000010   Restrict type to REG_DWORD.   RRF_RT_REG_EXPAND_SZ 0x00000004   Restrict type to REG_EXPAND_SZ.   RRF_RT_REG_MULTI_SZ 0x00000020   Restrict type to REG_MULTI_SZ.   RRF_RT_REG_NONE 0x00000001   Restrict type to REG_NONE.   RRF_RT_REG_QWORD 0x00000040   Restrict type to REG_QWORD.   RRF_RT_REG_SZ 0x00000002   Restrict type to REG_SZ.      This parameter can also include one or more of the following values.  ValueMeaning  RRF_NOEXPAND 0x10000000   Do not automatically expand environment strings if the value is of type REG_EXPAND_SZ.   RRF_ZEROONFAILURE 0x20000000   If pvData is not NULL, set the contents of the buffer to zeroes on failure.   RRF_SUBKEY_WOW6464KEY 0x00010000   If lpSubKey is not NULL, open the subkey that  lpSubKey specifies with the KEY_WOW64_64KEY access rights.  For information about these access rights, see Registry Key Security and Access Rights. You cannot specify RRF_SUBKEY_WOW6464KEY in combination with  RRF_SUBKEY_WOW6432KEY.   RRF_SUBKEY_WOW6432KEY 0x00020000   If lpSubKey is not NULL, open the subkey that  lpSubKey specifies with the KEY_WOW64_32KEY access rights. For information about these access rights, see Registry Key Security and Access Rights. You cannot specify RRF_SUBKEY_WOW6432KEY in combination with  RRF_SUBKEY_WOW6464KEY."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwType",
        "description": "A pointer to a variable that receives a code indicating the type of data stored in the specified value. For a list of the possible type codes, see  Registry Value Types. This parameter can be NULL if the type is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PVOID",
        "name": "pvData",
        "description": "A pointer to a buffer that receives the value's data. This parameter can be NULL if the data is not required. If the data is a string, the function checks for a terminating null character. If one is not found, the string is stored with a null terminator if the buffer is large enough to accommodate the extra character. Otherwise, the function fails and returns ERROR_MORE_DATA."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcbData",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by the pvData parameter, in bytes. When the function returns, this variable contains the size of the data copied to pvData.     The pcbData parameter can be NULL only if pvData is NULL. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, this size includes any terminating null character or characters. For more information, see Remarks. If the buffer specified by pvData parameter is not large enough to hold the data, the function returns ERROR_MORE_DATA and stores the required buffer size in the variable pointed to by pcbData. In this case, the contents of the pvData buffer are undefined. If pvData is NULL, and pcbData is non-NULL, the function returns ERROR_SUCCESS and stores the size of the data, in bytes, in the variable pointed to by pcbData. This enables an application to determine the best way to allocate a buffer for the value's data. If hKey specifies HKEY_PERFORMANCE_DATA and the pvData buffer is not large enough to contain all of the returned data,  the function returns ERROR_MORE_DATA and the value returned through the pcbData parameter is undefined. This is because the size of the performance data can change from one call to the next. In this case, you must increase the buffer size and call  RegGetValue again passing the updated buffer size in the pcbData parameter. Repeat this until the function succeeds. You need to maintain a separate variable to keep track of the buffer size, because the value returned by pcbData is unpredictable."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Creates a subkey under HKEY_USERS or HKEY_LOCAL_MACHINE and loads the data from the specified registry hive into that subkey.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "There are two  registry hive file formats. Registry hives created on current operating systems typically cannot be loaded by earlier ones. If hKey is a handle returned by  RegConnectRegistry, then the path specified in lpFile is relative to the remote computer. The calling process must have the SE_RESTORE_NAME and SE_BACKUP_NAME privileges on the computer in which the registry resides. For more information, see  Running with Special Privileges. To load a hive without requiring these special privileges, use the RegLoadAppKey function. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegLoadKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to the key where the subkey will be created. This can be a handle returned by a call to  RegConnectRegistry, or one of the following predefined handles:      HKEY_LOCAL_MACHINE HKEY_USERS  This function always loads information at the top of the registry hierarchy. The HKEY_CLASSES_ROOT and HKEY_CURRENT_USER handle values cannot be specified for this parameter, because they represent subsets of the HKEY_LOCAL_MACHINE and HKEY_USERS handle values, respectively."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the key to be created under hKey. This subkey is where the registration information from the file will be loaded.     Key names are not case sensitive. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFile",
        "description": "The name of the  file containing the registry data. This file must be a local file that was created with the  RegSaveKey function. If this file does not exist, a file is created with the specified name."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Loads the specified string from the specified key and subkey.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If the pcbData buffer is too small to receive the string, the function returns ERROR_MORE_DATA. The ANSI version of this function returns ERROR_CALL_NOT_IMPLEMENTED. ",
    "remarks": "The RegLoadMUIString function is supported only for Unicode. Although both Unicode (W) and ANSI (A) versions of this function are declared, the RegLoadMUIStringA function returns ERROR_CALL_NOT_IMPLEMENTED. Applications should explicitly call RegLoadMUIStringW or specify Unicode as the character set in platform invoke (PInvoke) calls. To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegLoadMUIString",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights. This handle is returned by the  RegCreateKeyEx or RegOpenKeyEx function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "The name of the registry value."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "pszOutBuf",
        "description": "A pointer to a buffer that receives the string. Strings of the following form receive special handling: @[path]\\dllname,-strID The string with identifier strID is loaded from dllname; the path is optional. If the pszDirectory parameter is not NULL, the directory is prepended to the path specified in the registry data. Note that dllname can contain environment variables to be expanded."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbOutBuf",
        "description": "The size of the pszOutBuf buffer, in bytes."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcbData",
        "description": "A pointer to a variable that receives the size of the data copied to the pszOutBuf buffer, in bytes. If the buffer is not large enough to hold the data, the function returns ERROR_MORE_DATA and stores the required buffer size in the variable pointed to by pcbData. In this case, the contents of the buffer are undefined."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "This parameter can be 0 or the following value.  ValueMeaning  REG_MUI_STRING_TRUNCATE 0x00000001   The string is truncated to fit the available size of the pszOutBuf buffer. If this flag is specified, pcbData must be NULL."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszDirectory",
        "description": "The directory path."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Notifies the caller about changes to the attributes or contents of a specified registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "This function detects a single change. After the caller receives a notification event, it should call the function again to receive the next notification. This function cannot be used to detect changes to the registry that result from using the RegRestoreKey function. If the specified key is closed, the event is signaled. This means that an application should not depend on the key being open after returning from a wait operation on the event. The REG_NOTIFY_THREAD_AGNOSTIC flag introduced in Windows 8 enables the use of RegNotifyChangeKeyValue for ThreadPool threads. If the thread that called  RegNotifyChangeKeyValue exits, the event is signaled. To continue to monitor additional changes in the value of the key, call  RegNotifyChangeKeyValue again from another thread. With the exception of RegNotifyChangeKeyValue calls with REG_NOTIFY_THREAD_AGNOSTIC set, this function must be called on persistent threads. If the calling thread is from a thread pool and it is not persistent, the event is signaled every time the thread terminates, not just when there is a registry change. To ensure accurate results, run the thread pool work in a persistent thread by using the SetThreadpoolCallbackPersistent function, or create your own thread using the CreateThread  function. (For the original thread pool API, specify WT_EXECUTEINPERSISTENTTHREAD using the QueueUserWorkItem function.) This function should not be called multiple times with the same  value for the hKey but different values for the bWatchSubtree and dwNotifyFilter parameters. The function will succeed but the changes will be ignored. To change the   watch parameters, you must first close the key handle by calling  RegCloseKey, reopen the key handle by calling  RegOpenKeyEx, and then call RegNotifyChangeKeyValue with the new parameters. Each time a process calls RegNotifyChangeKeyValue with the same set of parameters, it establishes another wait operation, creating a resource leak. Therefore, check that you are not calling RegNotifyChangeKeyValue with the same parameters until the previous wait operation has completed. To monitor registry operations in more detail, see Registry. Windows XP/2000:  When RegNotifyChangeKeyValue is called for a particular key handle, change notifications occur for as long as the key handle is valid. This causes a second call to RegNotifyChangeKeyValue to return immediately, if any changes occur in the interim between the first and second calls. If the function is being used asynchronously, the passed event handle will be signaled immediately if any changes occur in the interim. The following program illustrates how to use RegNotifyChangeKeyValue. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegNotifyChangeKeyValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx or RegOpenKeyEx function. It can also be one of the following  predefined keys:      HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS  This parameter must be a local handle. If  RegNotifyChangeKeyValue is called with a remote handle, it returns ERROR_INVALID_HANDLE. The key must have been opened with the KEY_NOTIFY access right. For more information, see  Registry Key Security and Access Rights."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "bWatchSubtree",
        "description": "If this parameter is TRUE, the function reports changes in the specified key and its subkeys. If the parameter is FALSE, the function reports changes only in the specified key."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwNotifyFilter",
        "description": "A value that indicates the changes that should be reported. This parameter can be one or more of the following values.  ValueMeaning  REG_NOTIFY_CHANGE_NAME 0x00000001L   Notify the caller if a subkey is added or deleted.   REG_NOTIFY_CHANGE_ATTRIBUTES 0x00000002L   Notify the caller of changes to the attributes of the key, such as the security descriptor information.   REG_NOTIFY_CHANGE_LAST_SET 0x00000004L   Notify the caller of changes to a value of the key. This can include adding or deleting a value, or changing an existing value.   REG_NOTIFY_CHANGE_SECURITY 0x00000008L   Notify the caller of changes to the security descriptor of the key.   REG_NOTIFY_THREAD_AGNOSTIC 0x10000000L   Indicates that the lifetime of the registration must not be tied to the lifetime of the thread issuing the RegNotifyChangeKeyValue call. Note  This flag value is only supported in Windows 8 and later."
      },
      {
        "in_out": "_In_opt_",
        "type": "HANDLE",
        "name": "hEvent",
        "description": "A handle to an event. If the fAsynchronous parameter is TRUE, the function returns immediately and changes are reported by signaling this event. If fAsynchronous is FALSE, hEvent is ignored."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fAsynchronous",
        "description": "If this parameter is TRUE, the function returns immediately and reports changes by signaling the specified event. If this parameter is FALSE, the function does not return until a change has occurred.     If hEvent does not specify a valid event, the fAsynchronous parameter cannot be TRUE."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Retrieves a handle to the HKEY_CURRENT_USER key for the user the current thread is impersonating.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "The HKEY_CURRENT_USER key maps to the root of the current user's branch in the HKEY_USERS key. It is cached for all threads in a process. Therefore, this value does not change when another user's profile is loaded.  RegOpenCurrentUser uses the thread's token to access the appropriate key, or the default if the profile is not loaded. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegOpenCurrentUser",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "A mask that specifies the desired access rights to the key. The function fails if the security descriptor of the key does not permit the requested access for the calling process. For more information, see  Registry Key Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened key. When you no longer need the returned handle, call the  RegCloseKey function to close it."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Opens the specified registry key. Note that key names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "Unlike the  RegCreateKeyEx function, the  RegOpenKeyEx function does not create the specified key if the key does not exist in the registry. Certain registry operations perform access checks against the security descriptor of the key, not the access mask specified when the handle to the key was obtained. For example, even if a key is opened with a samDesired of KEY_READ, it can be used to create registry keys if the key's security descriptor permits. In contrast, the RegSetValueEx function specifically requires that the key be opened with the KEY_SET_VALUE access right. If your service or application impersonates different users, do not use this function with HKEY_CURRENT_USER. Instead, call the RegOpenCurrentUser function. Note that operations that access certain registry keys are redirected. For more information,  see Registry Virtualization and 32-bit and 64-bit Application Data in the Registry. For an example, see  Deleting a Key with Subkeys. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegOpenKeyEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys:      HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the registry subkey to be opened.  Key names are not case sensitive. The lpSubKey parameter can be a pointer to an empty string. If lpSubKey is a pointer to an empty string and hKey is HKEY_CLASSES_ROOT, phkResult receives the same hKey handle passed into the function. Otherwise, phkResult receives a new handle to the key specified by hKey. The lpSubKey parameter can be NULL only if hKey is one of the predefined keys. If lpSubKey is NULL and hKey is HKEY_CLASSES_ROOT, phkResult receives a new handle to the key specified by hKey. Otherwise, phkResult receives the same hKey handle passed in to the function. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ulOptions",
        "description": "Specifies the option to apply when opening the key. Set this parameter to zero or the following:  ValueMeaning  REG_OPTION_OPEN_LINK   The key is a symbolic link. Registry symbolic links should only be used when absolutely necessary."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "A mask that specifies the desired access rights to the key to be opened. The function fails if the security descriptor of the key does not permit the requested access for the calling process. For more information, see  Registry Key Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened key. If the key is not one of the predefined registry keys, call the  RegCloseKey function after you have finished using the handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Opens the specified registry key and associates it with a  transaction. Note that key names are not case sensitive.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "When a key is opened using this function, subsequent operations on the key are transacted. If a non-transacted operation is performed on the key before the transaction is committed, the transaction is rolled back. After a transaction is committed or rolled back, you must re-open the key using the RegCreateKeyTransacted or RegOpenKeyTransacted function with an active transaction handle to make additional operations transacted. For more information about transactions, see Kernel Transaction Manager. Note that subsequent operations on subkeys of this key are not automatically transacted. Therefore,  the RegDeleteKeyEx function does not perform a transacted delete operation. Instead, use the RegDeleteKeyTransacted function to perform a transacted delete operation. Unlike the  RegCreateKeyTransacted function, the  RegOpenKeyTransacted function does not create the specified key if the key does not exist in the registry. If your service or application impersonates different users, do not use this function with HKEY_CURRENT_USER. Instead, call the RegOpenCurrentUser function. A single registry key can be opened only 65,534 times. When attempting the 65,535th open operation, this function fails with ERROR_NO_SYSTEM_RESOURCES. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegOpenKeyTransacted",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or   RegOpenKeyTransacted function. It can also be one of the following  predefined keys:  HKEY_CLASSES_ROOT HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the registry subkey to be opened.  Key names are not case sensitive. If this parameter is NULL or a pointer to an empty string, the function will open a new handle to the key identified by the hKey parameter. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "ulOptions",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "A mask that specifies the desired access rights to the key. The function fails if the security descriptor of the key does not permit the requested access for the calling process. For more information, see  Registry Key Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened key. If the key is not one of the predefined registry keys, call the  RegCloseKey function after you have finished using the handle."
      },
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hTransaction",
        "description": "A handle to an active transaction. This handle is returned by the CreateTransaction function."
      },
      {
        "in_out": "_Reserved_",
        "type": "PVOID",
        "name": "pExtendedParameter",
        "description": "This parameter is reserved and must be NULL."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves a handle to the HKEY_CLASSES_ROOT key for a specified user. The user is identified by an access token. The returned key has a view of the registry that merges the contents of the HKEY_LOCAL_MACHINE\\Software\\Classes key with the contents of the Software\\Classes keys in the user's registry hive. For more information, see  HKEY_CLASSES_ROOT Key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "The  RegOpenUserClassesRoot function enables you to retrieve the merged HKEY_CLASSES_ROOT information for users other than the interactive user. For example, the server component of a client/server application could use  RegOpenUserClassesRoot to retrieve the merged information for a client. RegOpenUserClassesRoot fails if the user profile for the specified user is not loaded. When a user logs on interactively, the system automatically loads the user's profile. For other users, you can call the  LoadUserProfile function to load the user's profile. However, LoadUserProfile can be very time-consuming, so do not call it for this purpose unless it is absolutely necessary to have the user's merged HKEY_CLASSES_ROOT information. Applications running in the security context of the interactively logged-on user do not need to use  RegOpenUserClassesRoot. These applications can call the  RegOpenKeyEx function to retrieve a merged view of the HKEY_CLASSES_ROOT key for the interactive user. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegOpenUserClassesRoot",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HANDLE",
        "name": "hToken",
        "description": "A handle to a primary or impersonation access token that identifies the user of interest. This can be a token handle returned by a call to  LogonUser,  CreateRestrictedToken,  DuplicateToken,  DuplicateTokenEx,  OpenProcessToken, or  OpenThreadToken functions.     The handle must have TOKEN_QUERY access. For more information, see  Access Rights for Access-Token Objects."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "dwOptions",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "A mask that specifies the desired access rights to the key. The function fails if the security descriptor of the key does not permit the requested access for the calling process. For more information, see  Registry Key Security and Access Rights."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened key. When you no longer need the returned handle, call the  RegCloseKey function to close it."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Maps a predefined registry key to the specified registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "The  RegOverridePredefKey function is intended for software installation programs. It allows them to remap a predefined key, load a DLL component that will be installed on the system, call an entry point in the DLL, and examine the changes to the registry that the component attempted to make. The installation program can then write those changes to the locations intended by the DLL, or make changes to the data before writing it. For example, consider an installation program that installs an ActiveX control as part of an application installation. The installation program needs to call the control's  DllRegisterServer entry point to enable the control to register itself. Before this call, the installation program can call  RegOverridePredefKey to remap HKEY_CLASSES_ROOT to a temporary key such as HKEY_CURRENT_USER\\TemporaryInstall\\DllRegistration. It then calls DllRegisterServer, which causes the ActiveX control to write its registry entries to the temporary key. The installation program then calls  RegOverridePredefKey again to restore the original mapping of HKEY_CLASSES_ROOT. The installation program can modify the keys written to the temporary key, if necessary, before copying them to the original HKEY_CLASSES_ROOT. After the call to  RegOverridePredefKey, you can safely call  RegCloseKey to close the hNewHKey handle. The system maintains its own reference to hNewHKey. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegOverridePredefKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to one of the following  predefined keys:      HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "HKEY",
        "name": "hNewHKey",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx or RegOpenKeyEx function. It cannot be one of the predefined keys. The function maps hKey to refer to the hNewHKey key. This affects only the calling process.     If hNewHKey is NULL, the function restores the default mapping of the predefined key."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 12,
    "description": "Retrieves information about the specified registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If the lpClass buffer is too small to receive the name of the class, the function returns ERROR_MORE_DATA. For an example, see  Enumerating Registry Subkeys. ",
    "remarks": "",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegQueryInfoKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys:    HKEY_CLASSES_ROOT    HKEY_CURRENT_CONFIG    HKEY_CURRENT_USER    HKEY_LOCAL_MACHINE    HKEY_PERFORMANCE_DATA    HKEY_USERS"
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpClass",
        "description": "A pointer to a buffer that receives the user-defined class of the key. This parameter can be NULL."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "lpcClass",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by the lpClass parameter, in characters.  The size should include the terminating null character. When the function returns, this variable contains the size of the class string that is stored in the buffer. The count returned does not include the terminating null character. If the buffer is not big enough, the function returns ERROR_MORE_DATA, and the variable contains the size of the string, in characters, without counting the terminating null character. If lpClass is NULL, lpcClass can be NULL. If the lpClass parameter is a valid address, but the lpcClass parameter is not, for example, it is NULL, then the  function returns ERROR_INVALID_PARAMETER."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPDWORD",
        "name": "lpReserved",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpcSubKeys",
        "description": "A pointer to a variable that receives the number of subkeys that are contained by the specified key. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpcMaxSubKeyLen",
        "description": "A pointer to a variable that receives the size of the key's subkey with the longest name, in Unicode characters, not including the terminating null character. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpcMaxClassLen",
        "description": "A pointer to a variable that receives the size of the longest string that specifies a subkey class, in Unicode characters. The count returned does not include the terminating null character. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpcValues",
        "description": "A pointer to a variable that receives the number of values that are associated with the key. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpcMaxValueNameLen",
        "description": "A pointer to a variable that receives the size of the key's longest value name, in Unicode characters. The size does not include the terminating null character. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpcMaxValueLen",
        "description": "A pointer to a variable that receives the size of the longest data component among the key's values, in bytes. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpcbSecurityDescriptor",
        "description": "A pointer to a variable that receives the size of the key's security descriptor, in bytes. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "PFILETIME",
        "name": "lpftLastWriteTime",
        "description": "A pointer to a  FILETIME structure that receives the last write time. This parameter can be NULL.     The function sets the members of the  FILETIME structure to indicate the last time that the key or any of its value entries is modified."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves the type and data for a list of value names associated with an open registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is one of the following error codes.  ",
    "remarks": "The  RegQueryMultipleValues function allows an application to query one or more values of a static or dynamic key. If the target key is a static key, the system provides all of the values in an atomic fashion. To prevent excessive serialization, the aggregate data returned by the function cannot exceed one megabyte. If the target key is a dynamic key, its provider must provide all the values in an atomic fashion. This means the provider should fill the results buffer synchronously, providing a consistent view of all the values in the buffer while avoiding excessive serialization. The provider can provide at most one megabyte of total output data during an atomic call to this function. RegQueryMultipleValues is supported remotely; that is, the hKey parameter passed to the function can refer to a remote computer. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegQueryMultipleValues",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_USERS"
      },
      {
        "in_out": "_Out_",
        "type": "PVALENT",
        "name": "val_list",
        "description": "A pointer to an array of  VALENT structures that describe one or more value entries. On input, the ve_valuename member of each structure must contain a pointer to the name of a value to retrieve. The function fails if any of the specified values do not exist in the specified key.     If the function succeeds, each element of the array contains the information for the specified value."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "num_vals",
        "description": "The number of elements in the val_list array."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpValueBuf",
        "description": "A pointer to a buffer. If the function succeeds, the buffer receives the data for each value.     If lpValueBuf is NULL, the value pointed to by the ldwTotsize parameter must be zero, in which case the function returns ERROR_MORE_DATA and ldwTotsize receives the required size of the buffer, in bytes."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "ldwTotsize",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by the lpValueBuf parameter, in bytes. If the function succeeds, ldwTotsize receives the number of bytes copied to the buffer. If the function fails because the buffer is too small, ldwTotsize receives the required size, in bytes."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Determines whether reflection has been disabled or enabled for the specified key.",
    "library": "AdvApi32.lib",
    "min_server": "Windows Server 2008, Windows Server 2003 with SP1 [desktop apps only]",
    "header": "WinReg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the         FormatMessage function with the        FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit      applications view. Registry reflection copies specific registry keys and values between the two views. To disable registry reflection, use the      RegDisableReflectionKey function. To restore      reflection for a disabled key, use the      RegEnableReflectionKey function. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegQueryReflectionKey",
    "is_callback": 0,
    "dll": "AdvApi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hBase",
        "description": "A handle to the registry key.       This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function; it cannot specify a key on a remote computer."
      },
      {
        "in_out": "_Out_",
        "type": "BOOL*",
        "name": "bIsReflectionDisabled",
        "description": "A value that indicates whether reflection has been disabled through RegDisableReflectionKey or enabled through RegEnableReflectionKey."
      }
    ],
    "min_client": "Windows Vista, Windows XP Professional x64 Edition [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves the type and data for the specified value name associated with an open registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If the lpData buffer is too small to receive the data, the function returns ERROR_MORE_DATA. If the lpValueName registry value does not exist, the function returns ERROR_FILE_NOT_FOUND. ",
    "remarks": "An application typically calls RegEnumValue to determine the value names and then RegQueryValueEx to retrieve the data for the names. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, the string may not have been stored with the proper terminating null characters. Therefore, even if the function returns ERROR_SUCCESS, the application should ensure that the string is properly terminated before using it; otherwise, it may overwrite a buffer. (Note that REG_MULTI_SZ strings should have two terminating null characters.) One way an application can ensure that the string is properly terminated is to use RegGetValue, which adds terminating null characters if needed. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, and the ANSI version of this function is used (either by explicitly calling RegQueryValueExA or by not defining UNICODE before including the Windows.h file), this function converts the stored Unicode string to an ANSI string before copying it to the buffer pointed to by lpData. When calling the  RegQueryValueEx function with hKey set to the HKEY_PERFORMANCE_DATA handle and a value string of a specified object, the returned data structure sometimes has unrequested objects. Do not be surprised; this is normal behavior. When calling the  RegQueryValueEx function, you should always expect to walk the returned data structure to look for the requested object. Note that operations that access certain registry keys are redirected. For more information,  see Registry Virtualization and 32-bit and 64-bit Application Data in the Registry. Ensure that you reinitialize the value  pointed to by the lpcbData parameter each time  you  call this function. This is very important when you call this function in a loop, as in the following code example. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegQueryValueEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_PERFORMANCE_DATA HKEY_PERFORMANCE_NLSTEXT HKEY_PERFORMANCE_TEXT HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpValueName",
        "description": "The name of the registry value.     If lpValueName is NULL or an empty string, \"\", the function retrieves the type and data for the key's unnamed or default value, if any.  If lpValueName specifies a value that is not in the registry, the function returns ERROR_FILE_NOT_FOUND. Keys do not automatically have an unnamed or default value. Unnamed values can be of any type. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_Reserved_",
        "type": "LPDWORD",
        "name": "lpReserved",
        "description": "This parameter is reserved and must be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "lpType",
        "description": "A pointer to a variable that receives a code indicating the type of data stored in the specified value. For a list of the possible type codes, see  Registry Value Types. The lpType parameter can be NULL if the type code is not required."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPBYTE",
        "name": "lpData",
        "description": "A pointer to a buffer that receives the value's data. This parameter can be NULL if the data is not required."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "lpcbData",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by the lpData parameter, in bytes. When the function returns, this variable contains the size of the data copied to lpData.     The lpcbData parameter can be NULL only if lpData is NULL. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, this size includes any terminating null character or characters unless the data was stored without them. For more information, see Remarks. If the buffer specified by lpData parameter is not large enough to hold the data, the function returns ERROR_MORE_DATA and stores the required buffer size in the variable pointed to by lpcbData. In this case, the contents of the lpData buffer are undefined. If lpData is NULL, and lpcbData is non-NULL, the function returns ERROR_SUCCESS and stores the size of the data, in bytes, in the variable pointed to by lpcbData. This enables an application to determine the best way to allocate a buffer for the value's data. If hKey specifies HKEY_PERFORMANCE_DATA and the lpData buffer is not large enough to contain all of the returned data,  RegQueryValueEx returns ERROR_MORE_DATA and the value returned through the lpcbData parameter is undefined. This is because the size of the performance data can change from one call to the next. In this case, you must increase the buffer size and call  RegQueryValueEx again passing the updated buffer size in the lpcbData parameter. Repeat this until the function succeeds. You need to maintain a separate variable to keep track of the buffer size, because the value returned by lpcbData is unpredictable. If the lpValueName registry value does not exist, RegQueryValueEx returns ERROR_FILE_NOT_FOUND and the value returned through the lpcbData parameter is undefined."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Replaces the file backing a registry key and all its subkeys with another file, so that when the system is next started, the key and subkeys will have the values stored in the new file.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "There are two different registry hive file formats. Registry hives created on current operating systems typically cannot be loaded by earlier ones. The file specified by the lpNewFile parameter remains open until the system is restarted. If hKey is a handle returned by  RegConnectRegistry, then the paths specified in lpNewFile and lpOldFile are relative to the remote computer. The calling process must have the SE_RESTORE_NAME and SE_BACKUP_NAME privileges on the computer in which the registry resides. For more information, see  Running with Special Privileges. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegReplaceKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys:      HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the registry key whose subkeys and values are to be replaced. If the key exists, it must be a subkey of the key identified by the hKey parameter. If the subkey does not exist, it is created. This parameter can be NULL.     If the specified subkey is not the root of a hive,  RegReplaceKey traverses up the hive tree structure until it encounters a hive root, then it replaces the contents of that hive with the contents of the data file specified by lpNewFile. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpNewFile",
        "description": "The name of the file with the registry information. This file is typically created by using the  RegSaveKey function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpOldFile",
        "description": "The name of the file that receives a backup copy of the registry information being replaced."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Reads the registry information in a specified file and copies it over the specified key. This registry information may be in the form of a key and multiple levels of subkeys.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "There are two different registry hive file formats. Registry hives created on current operating systems typically cannot be loaded by earlier ones. If any subkeys of the hKey parameter are open,  RegRestoreKey fails. The calling process must have the SE_RESTORE_NAME and SE_BACKUP_NAME privileges on the computer in which the registry resides. For more information, see  Running with Special Privileges. This function replaces the keys and values below the specified key with the keys and values that are subsidiary to the top-level key in the file, no matter what the name of the top-level key in the file might be. For example, hKey might identify a key A with subkeys B and C, while the lpFile parameter specifies a file containing key X with subkeys Y and Z. After a call to  RegRestoreKey, the registry would contain key A with subkeys Y and Z. The value entries of A would be replaced by the value entries of X. The new information in the file specified by lpFile overwrites the contents of the key specified by the hKey parameter, except for the key name. If hKey represents a key in a remote computer, the path described by lpFile is relative to the remote computer. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegRestoreKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx or RegOpenKeyEx function. It can also be one of the following  predefined keys:      HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS  Any information contained in this key and its descendent keys is overwritten by the information in the file pointed to by the lpFile parameter."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFile",
        "description": "The name of the file with the registry information. This file is typically created by using the  RegSaveKey function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "The flags that indicate how the key or keys are to be restored. This parameter can be one of the following values.  ValueMeaning  REG_FORCE_RESTORE 0x00000008L   If specified, the restore operation is executed even if open handles exist at or beneath the location in the registry hierarchy to which the hKey parameter points.    REG_WHOLE_HIVE_VOLATILE 0x00000001L   If specified, a new, volatile (memory only) set of registry information, or hive, is created. If REG_WHOLE_HIVE_VOLATILE is specified, the key identified by the hKey parameter must be either the HKEY_USERS or HKEY_LOCAL_MACHINE value."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Saves the specified key and all of its subkeys and values to a new file, in the standard format.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. If the file already exists, the function fails with the ERROR_ALREADY_EXISTS error. ",
    "remarks": "If hKey represents a key on a remote computer, the path described by lpFile is relative to the remote computer. The  RegSaveKey function saves only nonvolatile keys. It does not save volatile keys. A key is made volatile or nonvolatile at its creation; see  RegCreateKeyEx. You can use the file created by  RegSaveKey in subsequent calls to the  RegLoadKey,  RegReplaceKey, or  RegRestoreKey functions. If  RegSaveKey fails part way through its operation, the file will be corrupt and subsequent calls to  RegLoadKey,  RegReplaceKey, or  RegRestoreKey for the file will fail. Using RegSaveKey together with  RegRestoreKey to copy subtrees in the registry is not recommended. This method does not trigger notifications and can invalidate handles used by other applications. Instead, use the  SHCopyKey function or the RegCopyTree function. The calling process must have the SE_BACKUP_NAME privilege enabled. For more information, see  Running with Special Privileges. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegSaveKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key.  This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys:     HKEY_CLASSES_ROOT HKEY_CURRENT_USER"
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFile",
        "description": "The name of the file in which the specified key and subkeys are to be saved. If the file already exists, the function fails.     If the string does not include a path, the file is created in the current directory of the calling process for a local key, or in the %systemroot%\\system32 directory for a remote key. The new file has the archive attribute."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new file. If lpSecurityAttributes is NULL, the file gets a default security descriptor. The ACLs in a default security descriptor for a file are inherited from its parent directory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Saves the specified key and all of its subkeys and values to a registry file, in the specified format.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. If more than one of the possible values listed above for the Flags parameter is specified in one call to this function\u00e2\u0080\u0094for example, if two or more values are OR'ed\u00e2\u0080\u0094 or if REG_NO_COMPRESSION is specified and hKey specifies a key that is not the root of a hive, this function returns ERROR_INVALID_PARAMETER. ",
    "remarks": "Unlike RegSaveKey, this function does not support the HKEY_CLASSES_ROOT predefined key. If hKey represents a key on a remote computer, the path described by lpFile is relative to the remote computer. The  RegSaveKeyEx function saves only nonvolatile keys. It does not save volatile keys. A key is made volatile or nonvolatile at its creation; see  RegCreateKeyEx. You can use the file created by  RegSaveKeyEx in subsequent calls to the  RegLoadKey,  RegReplaceKey, or  RegRestoreKey function. If  RegSaveKeyEx fails partway through its operation, the file will be corrupt and subsequent calls to  RegLoadKey,  RegReplaceKey, or  RegRestoreKey for the file will fail. Using RegSaveKeyEx together with  RegRestoreKey to copy subtrees in the registry is not recommended. This method does not trigger notifications and can invalidate handles used by other applications. Instead, use the  SHCopyKey function or the RegCopyTree function. The calling process must have the SE_BACKUP_NAME privilege enabled. For more information, see  Running with Special Privileges. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegSaveKeyEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key.  This function does not support the HKEY_CLASSES_ROOT predefined key."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFile",
        "description": "The name of the file in which the specified key and subkeys are to be saved. If the file already exists, the function fails.     The new file has the archive attribute. If the string does not include a path, the file is created in the current directory of the calling process for a local key, or in the %systemroot%\\system32 directory for a remote key."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPSECURITY_ATTRIBUTES",
        "name": "lpSecurityAttributes",
        "description": "A pointer to a  SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new file. If lpSecurityAttributes is NULL, the file gets a default security descriptor. The ACLs in a default security descriptor for a file are inherited from its parent directory."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "Flags",
        "description": "The format of the saved key or hive. This parameter can be one of the following values.  ValueMeaning  REG_STANDARD_FORMAT 1   The key or hive is saved in standard format. The standard format is the only format supported by Windows 2000.   REG_LATEST_FORMAT 2   The key or hive is saved in the latest format. The latest format is supported starting with Windows XP. After the key or hive is saved in this format, it cannot be loaded on an earlier system.   REG_NO_COMPRESSION 4   The hive is saved with no compression, for faster save operations. The hKey parameter must specify the root of a hive under HKEY_LOCAL_MACHINE  or HKEY_USERS. For example, HKLM\\SOFTWARE is the root of a hive."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Sets the data for the specified value in the specified registry key and subkey.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2008 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see  Using the Windows Headers. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegSetKeyValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_SET_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys:      HKEY_CLASSES_ROOT    HKEY_CURRENT_CONFIG    HKEY_CURRENT_USER    HKEY_LOCAL_MACHINE    HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of a key and a subkey to the key identified by hKey. If this parameter is NULL, then this value is created in the key using the hKey value and the key gets a default security descriptor."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpValueName",
        "description": "The name of the registry value whose data is to be updated."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "The type of data pointed to by the lpData parameter. For a list of the possible types, see  Registry Value Types."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCVOID",
        "name": "lpData",
        "description": "The data to be stored with the specified value name.  For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbData",
        "description": "The size of the information pointed to by the lpData parameter, in bytes. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, cbData must include the size of the terminating null character or characters."
      }
    ],
    "min_client": "Windows Vista [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "The RegSetKeySecurity function sets the security of an open registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows Server 2003 [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the function returns ERROR_SUCCESS. If the function fails, it returns a nonzero error code defined in WinError.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "If hKey is one of the predefined keys, use  the RegCloseKey function to close the predefined key to  ensure that the new security information is in effect the next time the predefined key is referenced. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegSetKeySecurity",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open key for which the security descriptor is set."
      },
      {
        "in_out": "_In_",
        "type": "SECURITY_INFORMATION",
        "name": "SecurityInformation",
        "description": "A set of  bit flags that indicate the type of security information to set. This parameter can be a combination of the  SECURITY_INFORMATION bit flags."
      },
      {
        "in_out": "_In_",
        "type": "PSECURITY_DESCRIPTOR",
        "name": "pSecurityDescriptor",
        "description": "A pointer to a  SECURITY_DESCRIPTOR structure that specifies the security attributes to set for the specified key."
      }
    ],
    "min_client": "Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Sets the data and type of a specified value under a registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "Value sizes are limited by available memory. However, storing large values in the registry can affect its performance. Long values (more than 2,048 bytes) should be stored as files, with the locations of the files stored in the registry. Application elements such as icons, bitmaps, and executable files should be stored as files and not be placed in the registry. If dwType is the REG_SZ, REG_MULTI_SZ, or REG_EXPAND_SZ type and the ANSI version of this function is used (either by explicitly calling RegSetValueExA or by not defining UNICODE before including the Windows.h file), the data pointed to by the lpData parameter must be an ANSI character string. The string is converted to Unicode before it is stored in the registry. Note that operations that access certain registry keys are redirected. For more information,  see Registry Virtualization and 32-bit and 64-bit Application Data in the Registry. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegSetValueEx",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_SET_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS The Unicode version of this function supports the following additional predefined keys: HKEY_PERFORMANCE_TEXT HKEY_PERFORMANCE_NLSTEXT"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpValueName",
        "description": "The name of the value to be set. If a value with this name is not already present in the key, the function adds it to the key.     If lpValueName is NULL or an empty string, \"\", the function sets the type and data for the key's unnamed or default value. For more information, see  Registry Element Size Limits. Registry keys do not have default values, but they can have one unnamed value, which can be of any type."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "Reserved",
        "description": "This parameter is reserved and must be zero."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "The type of data pointed to by the lpData parameter. For a list of the possible types, see  Registry Value Types."
      },
      {
        "in_out": "_In_",
        "type": "const BYTE*",
        "name": "lpData",
        "description": "The data to be stored.  For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. String-literal values must be formatted using a backslash preceded by another backslash as an escape character. For example, specify \"C:\\\\mydir\\\\myfile\" to store the string \"C:\\mydir\\myfile\". Note  lpData indicating a  null value is valid, however, if this is the case, cbData must be set to '0'."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbData",
        "description": "The size of the information pointed to by the lpData parameter, in bytes. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, cbData must include the size of the terminating null character or characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Unloads the specified registry key and its subkeys from the registry.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "This function removes a hive from the registry but does not modify the file containing the registry information. A hive is a discrete body of keys, subkeys, and values that is rooted at the top of the registry hierarchy. The calling process must have the SE_RESTORE_NAME and SE_BACKUP_NAME privileges on the computer in which the registry resides. For more information, see  Running with Special Privileges. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegUnLoadKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to the registry key to be unloaded. This parameter can be a handle returned by a call to  RegConnectRegistry function or one of the following predefined handles:      HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the subkey to be unloaded. The key referred to by the lpSubKey parameter must have been created by using the  RegLoadKey function.     Key names are not case sensitive. For more information, see  Registry Element Size Limits."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Returns a pointer to an IQueryAssociations object.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: HRESULT If this function succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code. ",
    "remarks": "As of Windows Vista, AssocCreateForClasses is preferred to AssocCreate. ",
    "return_type": "HRESULT",
    "category": "Registry",
    "name": "AssocCreate",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "CLSID",
        "name": "clsid",
        "description": "Type: CLSID The CLSID of the object that exposes the interface. This parameter must be set to CLSID_QueryAssociations, which is defined in Shlguid.h."
      },
      {
        "in_out": "_In_",
        "type": "REFIID",
        "name": "riid",
        "description": "Type: REFIID Reference to the IID IID_IQueryAssociations, which is defined in Shlguid.h."
      },
      {
        "in_out": "_Out_",
        "type": "void*",
        "name": "ppv",
        "description": "Type: void* When this method returns, contains the IQueryAssociations interface pointer requested in riid."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Searches for and retrieves a key related to a file or protocol association from the registry.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: HRESULT Returns S_OK if successful, or a COM error value otherwise. ",
    "remarks": "This function is a wrapper for the IQueryAssociations interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see IQueryAssociations. ",
    "return_type": "HRESULT",
    "category": "Registry",
    "name": "AssocQueryKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ASSOCF",
        "name": "flags",
        "description": "Type: ASSOCF The flags that can be used to control the search. It can be any combination of ASSOCF values, except that only one ASSOCF_INIT value can be included."
      },
      {
        "in_out": "_In_",
        "type": "ASSOCKEY",
        "name": "key",
        "description": "Type: ASSOCKEY The ASSOCKEY value that specifies the type of key that is to be returned."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszAssoc",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.  File name extension   A file name extension, such as .txt.  CLSID   A CLSID GUID in the standard \"{GUID}\" format.  ProgID   An application's ProgID, such as Word.Document.8.  Executable name   The name of an application's .exe file. The ASSOCF_OPEN_BYEXENAME flag must be set in flags."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszExtra",
        "description": "Type: LPCTSTR A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as open. Set this parameter to NULL if it is not used."
      },
      {
        "in_out": "_Out_",
        "type": "HKEY*",
        "name": "phkeyOut",
        "description": "Type: HKEY* A pointer to the key's HKEY value."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Searches for and retrieves a file or protocol association-related string from the registry.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: HRESULT Returns a standard COM error value, including the following:  ",
    "remarks": "This function is a wrapper for the IQueryAssociations interface. The AssocQueryString function is intended to simplify the process of using IQueryAssociations interface. Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use IQueryAssociations to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see IQueryAssociations. ",
    "return_type": "HRESULT",
    "category": "Registry",
    "name": "AssocQueryString",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ASSOCF",
        "name": "flags",
        "description": "Type: ASSOCF The flags that can be used to control the search. It can be any combination of ASSOCF values, except that only one ASSOCF_INIT value can be included."
      },
      {
        "in_out": "_In_",
        "type": "ASSOCSTR",
        "name": "str",
        "description": "Type: ASSOCSTR The ASSOCSTR value that specifies the type of string that is to be returned."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszAssoc",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.  File name extension   A file name extension, such as .txt.  CLSID   A CLSID GUID in the standard \"{GUID}\" format.  ProgID   An application's ProgID, such as Word.Document.8.  Executable name   The name of an application's .exe file. The ASSOCF_OPEN_BYEXENAME flag must be set in flags."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszExtra",
        "description": "Type: LPCTSTR An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as open. Set this parameter to NULL if it is not used."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "pszOut",
        "description": "Type: LPTSTR Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to NULL to retrieve the required buffer size."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD*",
        "name": "pcchOut",
        "description": "Type: DWORD* A pointer to a value that, when calling the function, is set to the number of characters in the pszOut buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer. If the ASSOCF_NOTRUNCATE flag is set in flags and the buffer specified in pszOut is too small, the function returns E_POINTER and the value is set to the required size of the buffer. If pszOut is NULL, the function returns S_FALSE and pcchOut points to the required size, in characters, of the buffer."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Searches for and retrieves a file association-related string from the registry starting from a specified key.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: HRESULT Returns a standard COM error value, including the following:  ",
    "remarks": "This function is a wrapper for the IQueryAssociations interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see IQueryAssociations. ",
    "return_type": "HRESULT",
    "category": "Registry",
    "name": "AssocQueryStringByKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "ASSOCF",
        "name": "flags",
        "description": "Type: ASSOCF The flags that can be used to control the search. It can be any combination of ASSOCF values, except that only one ASSOCF_INIT value can be included."
      },
      {
        "in_out": "_In_",
        "type": "ASSOCSTR",
        "name": "str",
        "description": "Type: ASSOCSTR The ASSOCSTR value that specifies the type of string that is to be returned."
      },
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkAssoc",
        "description": "Type: HKEY The HKEY value of the key that will be used as a root key. The search looks only below this key."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszExtra",
        "description": "Type: LPCTSTR A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as open. Set this parameter to NULL if it is not used."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "pszOut",
        "description": "Type: LPTSTR A pointer to a null-terminated string used to return the requested string. Set this parameter to NULL to retrieve the required buffer size."
      },
      {
        "in_out": "_Inout_",
        "type": "DWORD*",
        "name": "pcchOut",
        "description": "Type: DWORD* A pointer to a value that, on entry, specifies the number of characters in the pszOut buffer. When the function returns, it points to the number of characters placed in the buffer.                        If the ASSOCF_NOTRUNCATE flag is set in flags and the buffer specified in pszOut is too small, the function returns E_POINTER and the value is set to the required size of the buffer. If pszOut is NULL, the function returns S_FALSE and pcchOut points to the required size of the buffer."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Recursively copies the subkeys and values of the source subkey to the destination key. SHCopyKey does not copy the security attributes of the keys.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use FormatMessage with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHCopyKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkeySrc",
        "description": "Type: HKEY A handle to the source key (for example, HKEY_CURRENT_USER)."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszSrcSubKey",
        "description": "Type: LPCTSTR The subkey whose subkeys and values are to be copied."
      },
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkeyDest",
        "description": "Type: HKEY The destination key."
      },
      {
        "in_out": "_Reserved_",
        "type": "DWORD",
        "name": "fReserved",
        "description": "Type: DWORD Reserved. Must be 0."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Deletes an empty key.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "SHDeleteEmptyKey does not delete a key if it contains any subkeys or values. Use SHDeleteKey instead. Alternatively, use the RegDeleteKey or RegDeleteTree function. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHDeleteEmptyKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to an open registry key, or one of the following predefined keys: HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_PERFORMANCE_DATAHKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR The address of a null-terminated string specifying the name of the key to delete."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "Alternatively, use the RegDeleteKey or RegDeleteTree function. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHDeleteKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to an open registry key, or one of the following predefined keys: HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_PERFORMANCE_DATAHKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR The address of a null-terminated string specifying the name of the key to delete."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Deletes a named value from the specified registry key.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHDeleteValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to the currently open key, or any of the following predefined values.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR The address of a null-terminated string specifying the name of the subkey for which to change the value."
      },
      {
        "in_out": "",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR The address of the value to be deleted."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates the subkeys of the specified open registry key.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHEnumKeyEx",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to the currently open key, or any of the following predefined values.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwIndex",
        "description": "Type: DWORD The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "pszName",
        "description": "Type: LPTSTR The address of a character buffer that receives the enumerated key name."
      },
      {
        "in_out": "_In_",
        "type": "LPDWORD",
        "name": "pcchName",
        "description": "Type: LPDWORD The address of a DWORD that, on entry, contains the size of the buffer at pszName, in characters. On exit, this contains the number of characters that were copied to pszName."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 7,
    "description": "Enumerates the values of the specified open registry key.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHEnumValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to the currently open key, or any of the following predefined values.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIndex",
        "description": "Type: DWORD The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls."
      },
      {
        "in_out": "",
        "type": "LPTSTR",
        "name": "pszValueName",
        "description": "Type: LPTSTR The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in pcchValueName."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcchValueName",
        "description": "Type: LPDWORD The address of a DWORD that, on entry, contains the size of the buffer at pszValueName, in characters. On exit, this contains the number of characters that were copied to pszValueName."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwType",
        "description": "Type: LPDWORD The address of a DWORD that receives the data type of the value. These are the same values as those described under the lpType parameter of RegEnumValue."
      },
      {
        "in_out": "",
        "type": "LPVOID",
        "name": "pvData",
        "description": "Type: LPVOID The address of a buffer that receives the data for the value entry. The size of this buffer is specified in pcbData. This parameter can be NULL if the data is not required."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcbData",
        "description": "Type: LPDWORD The address of a DWORD that, on entry, contains the size of the buffer at pvData, in bytes. On exit, this contains the number of bytes that were copied to pvData."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves a registry value.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHGetValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to the currently open key, or any of the following predefined values.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR The address of the value."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwType",
        "description": "Type: LPDWORD The type of value. For more information, see Registry Data Types."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPVOID",
        "name": "pvData",
        "description": "Type: LPVOID The address of the destination data buffer."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcbData",
        "description": "Type: LPDWORD The size of the destination data buffer."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves information about a specified registry key.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHQueryInfoKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to the currently open key, or any of the following predefined values.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcSubKeys",
        "description": "Type: LPDWORD The address of a DWORD that receives the number of subkeys under the specified key."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcchMaxSubKeyLen",
        "description": "Type: LPDWORD The address of a DWORD that receives the number of characters in the name of the subkey with the largest name."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcValues",
        "description": "Type: LPDWORD The address of a DWORD that receives the number of values under the specified key."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcchMaxValueNameLen",
        "description": "Type: LPDWORD The address of a DWORD that receives the number of characters in the name of the value with the largest name."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Opens a registry key and queries it for a specific value.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: DWORD Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "DWORD",
    "category": "Registry",
    "name": "SHQueryValueEx",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to the currently open key, or any of the following predefined values.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR The address of the null-terminated string that contains the name of the value to be queried."
      },
      {
        "in_out": "",
        "type": "LPDWORD",
        "name": "pdwReserved",
        "description": "Type: LPDWORD Reserved. Must be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwType",
        "description": "Type: LPDWORD The address of the variable that receives the key's value type. For more information, see Registry Data Types."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPVOID",
        "name": "pvData",
        "description": "Type: LPVOID The address of the buffer that receives the value's data. This parameter can be NULL if the data is not required."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcbData",
        "description": "Type: LPDWORD The address of the variable that specifies the size, in bytes, of the buffer pointed to by the pvData parameter. When the function returns, this variable contains the size of the data copied to pvData."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Closes a handle to a user-specific registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. Use FormatMessage with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegCloseUSKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "If you want to write values to the new key, use SHRegWriteUSValue to write each value, passing the HUSKEY handle that is returned through phNewUSKey. When you have finished, close the user-specific registry key with SHRegCloseUSKey. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegCreateUSKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszPath",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "Type: REGSAM The desired security access. For more information on security access, see REGSAM."
      },
      {
        "in_out": "_In_opt_",
        "type": "HUSKEY",
        "name": "hRelativeUSKey",
        "description": "Type: HUSKEY The key to be used as a base for relative paths. If pszPath is a relative path, the key it specifies will be relative to hRelativeUSKey. If pszPath is an absolute path, set hRelativeUSKey to NULL. The key will then be created under HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER, depending the value of dwFlags."
      },
      {
        "in_out": "_Out_",
        "type": "PHUSKEY",
        "name": "phNewUSKey",
        "description": "Type: PHUSKEY A pointer to an HUSKEY that will receive the handle to the new key."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Type: DWORD The base key under which the key should be opened. This can be one or more of the following values.  SHREGSET_HKCU   Create/open the key under HKEY_CURRENT_USER. Only creates a key if it is empty.  SHREGSET_FORCE_HKCU   Create/open the key under HKEY_CURRENT_USER. Creates a key even if it is not empty.  SHREGSET_HKLM   Create/open the key under HKEY_LOCAL_MACHINE. Only creates a key if it is empty.  SHREGSET_FORCE_HKLM   Create/open the key under HKEY_LOCAL_MACHINE. Creates a key even if it is not empty.  SHREGSET_DEFAULT   Create/open the key under both HKEY_CURRENT_USER (forced) and HKEY_LOCAL_MACHINE (only if empty). This flag is the equivalent of (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegDeleteEmptyUSKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function."
      },
      {
        "in_out": "_In_",
        "type": "LPCSTR",
        "name": "pszValue",
        "description": "Type: LPCSTR A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted."
      },
      {
        "in_out": "_In_",
        "type": "SHREGDEL_FLAGS",
        "name": "delRegFlags",
        "description": "Type: SHREGDEL_FLAGS One of the SHREGDEL_FLAGS that specifies from which base key the subkey will be deleted."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegDeleteUSValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to the null-terminated string that names the value to remove."
      },
      {
        "in_out": "_In_",
        "type": "SHREGDEL_FLAGS",
        "name": "delRegFlags",
        "description": "Type: SHREGDEL_FLAGS One of the SHREGDEL_FLAGS that specifies from which base key the value will be deleted."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 1,
    "description": "Duplicates a registry key's HKEY handle.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: HKEY Returns a duplicate of the handle specified in hkey. ",
    "remarks": "",
    "return_type": "HKEY",
    "category": "Registry",
    "name": "SHRegDuplicateHKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY The HKEY handle to be duplicated."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegEnumUSKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIndex",
        "description": "Type: DWORD The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszName",
        "description": "Type: LPTSTR A pointer to a character buffer that receives the enumerated key name."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcchName",
        "description": "Type: LPDWORD A pointer to  a DWORD that, on entry, contains the size of the buffer at pszName, in characters. On exit, this contains the number of characters that were copied to pszName."
      },
      {
        "in_out": "_In_",
        "type": "SHREGENUM_FLAGS",
        "name": "enumRegFlags",
        "description": "Type: SHREGENUM_FLAGS A SHREGENUM_FLAGS that specifies the base key in which the enumeration should take place."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegEnumUSValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIndex",
        "description": "Type: DWORD The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszValueName",
        "description": "Type: LPTSTR A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in pcchValueNameLen."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD",
        "name": "pcchValueNameLen",
        "description": "Type: LPDWORD A pointer to a DWORD that, on entry, contains the size of the buffer at pszValueName, in characters. On exit, this contains the number of characters that were copied to pszValueName."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pdwType",
        "description": "Type: LPDWORD A pointer to a DWORD that receives the data type of the value. These are the same values as those described under the lpType parameter of RegEnumValue."
      },
      {
        "in_out": "_Out_opt_",
        "type": "void*",
        "name": "pvData",
        "description": "Type: void* A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in pcbData. This parameter can be NULL if the data is not required."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD",
        "name": "pcbData",
        "description": "Type: LPDWORD A pointer to a DWORD that, on entry, contains the size of the buffer at pvData. On exit, this contains the number of bytes that were copied to pvData."
      },
      {
        "in_out": "_In_",
        "type": "SHREGENUM_FLAGS",
        "name": "enumRegFlags",
        "description": "Type: SHREGENUM_FLAGS One of the SHREGENUM_FLAGS that specifies the base key in which the enumeration should take place."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: BOOL Returns either the value from the registry, or fDefault if none is found. ",
    "remarks": "",
    "return_type": "BOOL",
    "category": "Registry",
    "name": "SHRegGetBoolUSValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR A pointer to a null-terminated string with the name of the subkey relative to HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER. For example, \"Software\\MyCompany\\MyProduct\"."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that specifies the name of the value. This value can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fIgnoreHKCU",
        "description": "Type: BOOL A variable that specifies which key to look under. When set to TRUE, SHRegGetUSValue ignores HKEY_CURRENT_USER and returns a value from HKEY_LOCAL_MACHINE."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fDefault",
        "description": "Type: BOOL A value that is returned if there is no registry value."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Reads a numeric string value from the registry and converts it to an integer.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: int Returns the converted string as an int, or the default value specified by nDefault. ",
    "remarks": "Prior to Windows 2000 Service Pack 3 (SP3), Windows Server 2003 Service Pack 1 (SP1), and Windows XP, SHRegGetIntW was not exported by name. On those systems you must load it directly from Shlwapi.dll as ordinal 280. This function is only available in a Unicode version. ANSI is not supported. ",
    "return_type": "int",
    "category": "Registry",
    "name": "SHRegGetIntW",
    "is_callback": 0,
    "dll": "Shlwapi.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hk",
        "description": "Type: HKEY A handle to the registry key that specifies the value to be read."
      },
      {
        "in_out": "_In_",
        "type": "LPCWSTR",
        "name": "szKey",
        "description": "Type: LPCWSTR A pointer to a string value that specifies the name of the value to be read. The string must be null-terminated."
      },
      {
        "in_out": "_In_",
        "type": "int",
        "name": "nDefault",
        "description": "Type: int An int that specifies the value returned if the registry value cannot be retrieved successfully."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves a file path from the registry, expanding environment variables as needed.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a Windows error code otherwise. ",
    "remarks": "The data type of the specified registry value must be either REG_EXPAND_SZ or REG_SZ. If it has the REG_EXPAND_SZ type, any environment variables in the registry string will be expanded with ExpandEnvironmentStrings. If it has the REG_SZ data type, environment variables will not be expanded and the string pointed to by pszPath will be identical to the string in the registry. The following environment strings will be replaced by their equivalent path.  ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegGetPath",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to a key that is currently open, or a registry root key."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszSubkey",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that contains the name of the subkey."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "pszPath",
        "description": "Type: LPTSTR A buffer to hold the expanded path. You should set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Type: DWORD Reserved."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "When fIgnoreHKCU is set to TRUE, SHRegGetUSValue returns the value from the key under HKEY_LOCAL_MACHINE. When set to FALSE, SHRegGetUSValue first tries to return the value from the key under HKEY_CURRENT_USER. However, if the key is not found under HKEY_CURRENT_USER, the value is returned from the key under HKEY_LOCAL_MACHINE. If neither key is present, or if an error occurred and dwDefaultDataSize is nonzero, then the default data is copied to pvData and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to pvData. To prevent the use of default data, set pvDefaultData to NULL and dwDefaultDataSize to zero. This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with SHRegOpenUSKey and then use SHRegQueryUSValue to retrieve the data. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegGetUSValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR A pointer to a null-terminated string with the name of the subkey relative to HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER. For example: \"Software\\MyCompany\\MyProduct\"."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to a null-terminated string with the name of the value. This value can be NULL."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "DWORD*",
        "name": "pdwType",
        "description": "Type: DWORD* A pointer to a DWORD that receives the type of data stored in the retrieved value. When using default values, the input pdwType is the type of the default value. For possible values, see Registry Data Types. If type information is not required, this parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "void*",
        "name": "pvData",
        "description": "Type: void* A pointer to a buffer that receives the value's data."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "DWORD*",
        "name": "pcbData",
        "description": "Type: DWORD* A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by pvData. When SHRegGetUSValue returns, pcbData contains the size of the data copied to pvData."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fIgnoreHKCU",
        "description": "Type: BOOL A variable that specifies which key to look under. When set to TRUE, SHRegGetUSValue ignores HKEY_CURRENT_USER and returns the value from the key under HKEY_LOCAL_MACHINE."
      },
      {
        "in_out": "_In_opt_",
        "type": "void*",
        "name": "pvDefaultData",
        "description": "Type: void* A pointer to a buffer that receives the value's default data."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwDefaultDataSize",
        "description": "Type: DWORD The length, in bytes, of the buffer pointed to by pvDefaultData."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegOpenUSKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszPath",
        "description": "Type: LPCTSTR A pointer to a null-terminated string with the name of the subkey."
      },
      {
        "in_out": "_In_",
        "type": "REGSAM",
        "name": "samDesired",
        "description": "Type: REGSAM The desired security access. For more information on security access, see REGSAM."
      },
      {
        "in_out": "_In_opt_",
        "type": "HUSKEY",
        "name": "hRelativeUSKey",
        "description": "Type: HUSKEY The key to be used as a base for relative paths. If pszPath is a relative path, the key it specifies will be relative to hRelativeUSKey. If pszPath is an absolute path, set hRelativeUSKey to NULL."
      },
      {
        "in_out": "_Out_",
        "type": "PHUSKEY",
        "name": "phNewUSKey",
        "description": "Type: PHUSKEY A pointer to the handle of the opened key."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fIgnoreHKCU",
        "description": "Type: BOOL The variable that specifies which key to look under. When set to TRUE, SHRegOpenUSKey ignores HKEY_CURRENT_USER and returns a value from HKEY_LOCAL_MACHINE."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegQueryInfoUSKey",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcSubKeys",
        "description": "Type: LPDWORD A pointer to  a DWORD that receives the number of subkeys under the specified key."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcchMaxSubKeyLen",
        "description": "Type: LPDWORD A pointer to a DWORD that receives the number of characters in the largest subkey name."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcValues",
        "description": "Type: LPDWORD A pointer to  a DWORD that receives the number of values under the specified key."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPDWORD",
        "name": "pcchMaxValueNameLen",
        "description": "Type: LPDWORD A pointer to a DWORD that receives the number of characters in the largest value name."
      },
      {
        "in_out": "_In_",
        "type": "SHREGENUM_FLAGS",
        "name": "enumRegFlags",
        "description": "Type: SHREGENUM_FLAGS One of the SHREGENUM_FLAGS that specifies the base key in which the query should take place."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 8,
    "description": "Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "When fIgnoreHKCU is set to TRUE, SHRegQueryUSValue returns the value from the key under HKEY_LOCAL_MACHINE. When set to FALSE, SHRegQueryUSValue first tries to return the value from the key under HKEY_CURRENT_USER. However, if the key is not found under HKEY_CURRENT_USER, the value returns from the key under HKEY_LOCAL_MACHINE. If neither key is present, or if an error occurs and dwDefaultDataSize is nonzero, then the default data is copied to pvData and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to pvData. To prevent the use of default data, set pvDefaultData to NULL and dwDefaultDataSize to zero. If you only need to read a single value, SHRegGetUSValue will both open the key and return the value. To use SHRegQueryUSValue, you must first open the key with SHRegOpenUSKey. However, once the key is opened, you can use SHRegQueryUSValue as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to SHRegQueryUSValue is usually more efficient than SHRegGetUSValue, as the key is only opened once. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegQueryUSValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to the null-terminated string that contains the name of the value to be queried."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "LPDWORD*",
        "name": "pdwType",
        "description": "Type: LPDWORD* A pointer to the variable that sets or receives the key's value type. For more information, see Registry Data Types. This parameter can be NULL."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPVOID*",
        "name": "pvData",
        "description": "Type: LPVOID* A pointer to the buffer that receives the value's data. This parameter can be NULL if the data is not required."
      },
      {
        "in_out": "_Inout_",
        "type": "LPDWORD*",
        "name": "pcbData",
        "description": "Type: LPDWORD* A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the pvData parameter. When the function returns, this variable contains the size of the data copied to pvData."
      },
      {
        "in_out": "_In_",
        "type": "BOOL",
        "name": "fIgnoreHKCU",
        "description": "Type: BOOL The variable that specifies which key to look under. When set to TRUE, SHRegQueryUSValue ignores HKEY_CURRENT_USER and returns the value from the key under HKEY_LOCAL_MACHINE."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID*",
        "name": "pvDefaultData",
        "description": "Type: LPVOID* A pointer to the default data."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "dwDefaultDataSize",
        "description": "Type: DWORD The length, in bytes, of the default data."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a Windows error code otherwise. ",
    "remarks": "For Windows 2000, SHRegSetPath uses PathUnExpandEnvStrings to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the REG_EXPAND_SZ data type. Otherwise, it will be set with the REG_SZ data type. The following folder paths will be replaced by their equivalent environment string.  The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegSetPath",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 5.0 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to a key that is currently open, or a registry root key."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszSubkey",
        "description": "Type: LPCTSTR A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, SHRegSetPath will fail."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to a null-terminated string with the name of the value to hold the path string."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszPath",
        "description": "Type: LPCTSTR A pointer to a null-terminated string with a fully qualified file path."
      },
      {
        "in_out": "",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Type: DWORD Reserved."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with SHRegOpenUSKey and then use SHRegWriteUSValue to write the data. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegSetUSValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR A pointer to a null-terminated string with the name of the subkey."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that specifies the name of the value."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "Type: DWORD Type of data to be stored. This parameter must be the REG_SZ type. For more information, see Registry Data Types."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPVOID*",
        "name": "pvData",
        "description": "Type: LPVOID*  Apointer to a null-terminated string that contains the value to be set for the specified key."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "cbData",
        "description": "Type: DWORD Length, in bytes, of the string pointed to by the pvData parameter, not including the terminating null character."
      },
      {
        "in_out": "_In_opt_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Type: DWORD Flags indicating where the data should be written.  SHREGSET_HKCU   Write to HKEY_CURRENT_USER if empty.  SHREGSET_FORCE_HKCU   Write to HKEY_CURRENT_USER.  SHREGSET_HKLM   Write to HKEY_LOCAL_MACHINE if empty.  SHREGSET_FORCE_HKLM   Write to HKEY_LOCAL_MACHINE.  SHREGSET_DEFAULT   Equivalent to (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "To use SHRegWriteUSValue, you must first open the key with SHRegOpenUSKey. Once the key is opened, you can use SHRegWriteUSValue as many times as necessary. If you only need to write a single value, you should use SHRegSetUSValue, which both opens the key and writes the value. If you need to write more than one value on the same key, multiple calls to SHRegWriteUSValue are usually more efficient than SHRegSetUSValue, because the key is only opened once. ",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHRegWriteUSValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HUSKEY",
        "name": "hUSKey",
        "description": "Type: HUSKEY A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see Registry Key Security and Access Rights.                           This handle can be obtained through the SHRegOpenUSKey function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by hUSKey. If a value with this name is not already present in the subkey, it will be added.                           If this parameter is NULL or an empty string, the function sets the type and data for the subkey's Default value."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "Type: DWORD The type of the data to be stored in the value specified by pszValue. One of the following registry value types defined in Winnt.h and Wdm.h.  REG_NONE (0x00000000) REG_SZ (0x00000001) REG_EXPAND_SZ (0x00000002) REG_BINARY (0x00000003) REG_DWORD (0x00000004) REG_DWORD_LITTLE_ENDIAN (0x00000004) REG_DWORD_BIG_ENDIAN (0x00000005) REG_LINK (0x00000006) REG_MULTI_SZ (0x00000007) REG_RESOURCE_LIST (0x00000008) REG_FULL_RESOURCE_DESCRIPTOR (0x00000009) REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A) REG_QWORD (0x0000000B) REG_QWORD_LITTLE_ENDIAN (0x0000000B)"
      },
      {
        "in_out": "_In_",
        "type": "const void*",
        "name": "pvData",
        "description": "Type: const void* A pointer to the data to be set for the value specified by pszValue. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify \"C:\\\\mydir\\\\myfile\" to store the string \"C:\\mydir\\myfile\"."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbData",
        "description": "Type: DWORD The size, in bytes, of the data pointed to by the pvData parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, cbData must include the size of the terminating null character or characters."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwFlags",
        "description": "Type: DWORD Flags that indicate the subtree to which the data should be written. One or more of the following values:  SHREGSET_HKCU (0x00000001)   Write to HKEY_CURRENT_USER only if a value of the name specified in pszValue does not currently exist under the specified subkey.  SHREGSET_FORCE_HKCU (0x00000002)   Write to HKEY_CURRENT_USER. If a value of the name specified in pszValue already exists, it will be overwritten.  SHREGSET_HKLM (0x00000004)   Write to HKEY_LOCAL_MACHINE only if a value of the name specified in pszValue does not currently exist under the specified subkey..  SHREGSET_FORCE_HKLM (0x00000008)   Write to HKEY_LOCAL_MACHINE. If a value of the name specified in pszValue already exists, it will be overwritten.  SHREGSET_DEFAULT (0x00000006)   Equivalent to (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Sets the value of a registry key.",
    "library": "Shlwapi.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Shlwapi.h",
    "return_value": "Type: LSTATUS Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error. ",
    "remarks": "",
    "return_type": "LSTATUS",
    "category": "Registry",
    "name": "SHSetValue",
    "is_callback": 0,
    "dll": "Shlwapi.dll (version 4.71 or later)",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hkey",
        "description": "Type: HKEY A handle to the currently open key, or any of the following predefined values.  HKEY_CLASSES_ROOT   HKEY_CURRENT_CONFIG   HKEY_CURRENT_USER   HKEY_LOCAL_MACHINE   HKEY_PERFORMANCE_DATA   HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszSubKey",
        "description": "Type: LPCTSTR The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be NULL or a pointer to an empty string. In this case, the value is added to the key identified by the hkey parameter."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "pszValue",
        "description": "Type: LPCTSTR The address of a null-terminated string that specifies the value. This value can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "Type: DWORD Type of data to be stored. This parameter must be the REG_SZ type. For more information, see Registry Data Types."
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCVOID",
        "name": "pvData",
        "description": "Type: LPCVOID Pointer to a buffer that contains the data to set for the specified value. This value can be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbData",
        "description": "Type: DWORD Length, in bytes, of the buffer pointed to by the pvData parameter. If the data is a null-terminated string, this length includes the terminating null character."
      }
    ],
    "min_client": "Windows 2000 Professional, Windows XP [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves an integer associated with a key in the specified section of an initialization file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value. ",
    "remarks": "The function searches the file for a key that matches the name specified by the lpKeyName parameter under the section name specified by the lpAppName parameter. A section in the initialization file must have the following form: The  GetPrivateProfileInt function is not case-sensitive; the strings in lpAppName and lpKeyName can be a combination of uppercase and lowercase letters. An application can use the  GetProfileInt function to retrieve an integer value from the Win.ini file. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the  function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "UINT WINAPI",
    "category": "Registry",
    "name": "GetPrivateProfileInt",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section in the initialization file."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpKeyName",
        "description": "The name of the key whose value is to be retrieved. This value is in the form of a string; the  GetPrivateProfileInt function converts the string into an integer and returns the integer."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "nDefault",
        "description": "The default value to return if the key name cannot be found in the initialization file."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves all the keys and values for the specified section of an initialization file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to nSize minus two. ",
    "remarks": "The data in the buffer pointed to by the lpReturnedString parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format: key=string The  GetPrivateProfileSection function is not case-sensitive; the string pointed to by the lpAppName parameter can be a combination of uppercase and lowercase letters. This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the lpReturnedString parameter. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the  function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: Comments (any line that starts with a semicolon) are stripped out and not returned in the lpReturnedString buffer. ",
    "return_type": "DWORD WINAPI",
    "category": "Registry",
    "name": "GetPrivateProfileSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section in the initialization file."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpReturnedString",
        "description": "A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters.    The maximum profile section size is 32,767 characters."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves the names of all sections in an initialization file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by nSize minus two. ",
    "remarks": "This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the  function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "DWORD WINAPI",
    "category": "Registry",
    "name": "GetPrivateProfileSectionNames",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpszReturnBuffer",
        "description": "A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the buffer pointed to by the lpszReturnBuffer parameter, in characters."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the initialization file. If this parameter is NULL, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 6,
    "description": "Retrieves a string from the specified section in an initialization file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "The return value is the number of characters copied to the buffer, not including the terminating null character. If neither lpAppName nor lpKeyName is NULL and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a null character, and the return value is equal to nSize minus one. If either lpAppName or lpKeyName is NULL and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two null characters. In this case, the return value is equal to nSize minus two. In the event the initialization file specified by lpFileName is not found, or contains invalid values, this function will set errorno with a value of '0x2' (File Not Found). To retrieve extended error information, call GetLastError. ",
    "remarks": "The  GetPrivateProfileString function searches the specified initialization file for a key that matches the name specified by the lpKeyName parameter under the section heading specified by the lpAppName parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the lpDefault parameter. A section in the initialization file must have the following form: If lpAppName is NULL,  GetPrivateProfileString copies all section names in the specified file to the supplied buffer. If lpKeyName is NULL, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a null character and the final string is followed by a second null character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two null characters. If the string associated with lpKeyName is enclosed in single or double quotation marks, the marks are discarded when the  GetPrivateProfileString function retrieves the string. The  GetPrivateProfileString function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters. To retrieve a string from the Win.ini file, use the  GetProfileString function. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the  function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "DWORD WINAPI",
    "category": "Registry",
    "name": "GetPrivateProfileString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section containing the key name. If this parameter is NULL, the  GetPrivateProfileString function copies all section names in the file to the supplied buffer."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpKeyName",
        "description": "The name of the key whose associated string is to be retrieved. If this parameter is NULL, all key names in the section specified by the lpAppName parameter are copied to the buffer specified by the lpReturnedString parameter."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpDefault",
        "description": "A default string. If the lpKeyName key cannot be found in the initialization file,  GetPrivateProfileString copies the default string to the lpReturnedString buffer.     If this parameter is NULL, the default is an empty string, \"\". Avoid specifying a default string with trailing blank characters. The function inserts a null character in the lpReturnedString buffer to strip any trailing blanks."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpReturnedString",
        "description": "A pointer to the buffer that receives the retrieved string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the  WritePrivateProfileStruct function when the data was added to the file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. ",
    "remarks": "A section in the initialization file must have the following form: The system maps most .ini file references to the registry, using the mapping defined under the following registry key: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the   function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "BOOL WINAPI",
    "category": "Registry",
    "name": "GetPrivateProfileStruct",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszSection",
        "description": "The name of the section in the initialization file."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszKey",
        "description": "The name of the key whose data is to be retrieved."
      },
      {
        "in_out": "_Out_",
        "type": "LPVOID",
        "name": "lpStruct",
        "description": "A pointer to the buffer that receives the data associated with the file, section, and key names."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uSizeStruct",
        "description": "The size of the buffer pointed to by the lpStruct parameter, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szFile",
        "description": "The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves an integer from a key in the specified section of the Win.ini file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero. ",
    "remarks": "If the key name consists of digits followed by characters that are not numeric, the function returns only the value of the digits. For example, the function returns 102 for the following line: KeyName=102abc. Windows Server 2003 and Windows XP/2000:  Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key:HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping When the operation has been mapped, the  GetProfileInt function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "UINT WINAPI",
    "category": "Registry",
    "name": "GetProfileInt",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section containing the key name."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpKeyName",
        "description": "The name of the key whose value is to be retrieved. This value is in the form of a string; the  GetProfileInt function converts the string into an integer and returns the integer."
      },
      {
        "in_out": "_In_",
        "type": "INT",
        "name": "nDefault",
        "description": "The default value to return if the key name cannot be found in the initialization file."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Retrieves all the keys and values for the specified section of the Win.ini file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by nSize minus two. ",
    "remarks": "The format of the returned keys and values is one or more null-terminated strings, followed by a final null character. Each string has the following form: key=string The  GetProfileSection function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters. This operation is atomic; no updates to the Win.ini file are allowed while the keys and values for the section are being copied to the buffer. Windows Server 2003 and Windows XP/2000:  Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping. When the operation has been mapped, the  GetProfileSection function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "DWORD WINAPI",
    "category": "Registry",
    "name": "GetProfileSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section in the Win.ini file."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpReturnedString",
        "description": "A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters.        The maximum profile section size is 32,767 characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Retrieves the string associated with a key in the specified section of the Win.ini file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "The return value is the number of characters copied to the buffer, not including the null-terminating character. If neither lpAppName nor lpKeyName is NULL and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a null character, and the return value is equal to nSize minus one. If either lpAppName or lpKeyName is NULL and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two null characters. In this case, the return value is equal to nSize minus two. ",
    "remarks": "If the string associated with the lpKeyName parameter is enclosed in single or double quotation marks, the marks are discarded when the  GetProfileString function returns the string. The  GetProfileString function is not case-sensitive; the strings can contain a combination of uppercase and lowercase letters. A section in the Win.ini file must have the following form: An application can use the  GetPrivateProfileString function to retrieve a string from a specified initialization file. The lpDefault parameter must point to a valid string, even if the string is empty (that is, even if its first character is a null character). Windows Server 2003 and Windows XP/2000:  Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following keys:  HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping When the operation has been mapped, the  GetProfileString function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "DWORD WINAPI",
    "category": "Registry",
    "name": "GetProfileString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section containing the key. If this parameter is NULL, the function copies all section names in the file to the supplied buffer."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpKeyName",
        "description": "The name of the key whose associated string is to be retrieved. If this parameter is NULL, the function copies all keys in the given section to the supplied buffer. Each string is followed by a null character, and the final string is followed by a second null character."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpDefault",
        "description": "A default string. If the lpKeyName key cannot be found in the initialization file,  GetProfileString copies the default string to the lpReturnedString buffer. If this parameter is NULL, the default is an empty string, \"\".     Avoid specifying a default string with trailing blank characters. The function inserts a null character in the lpReturnedString buffer to strip any trailing blanks."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpReturnedString",
        "description": "A pointer to a buffer that receives the character string."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "nSize",
        "description": "The size of the buffer pointed to by the lpReturnedString parameter, in characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Replaces the keys and values for the specified section in an initialization file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "The data in the buffer pointed to by the lpString parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following form: key=string The  WritePrivateProfileSection function is not case-sensitive; the string pointed to by the lpAppName parameter can be a combination of uppercase and lowercase letters. If no section name matches the string pointed to by the lpAppName parameter,  WritePrivateProfileSection creates the section at the end of the specified initialization file and initializes the new section with the specified key name and value pairs. WritePrivateProfileSection deletes the existing keys and values for the named section and inserts the key names and values in the buffer pointed to by the lpString parameter. The function does not attempt to correlate old and new key names; if the new names appear in a different order from the old names, any comments associated with preexisting keys and values in the initialization file will probably be associated with incorrect keys and values. This operation is atomic; no operations that read from or write to the specified initialization file are allowed while the information is being written. The system keeps a cached version of the most recent registry file mapping to improve performance. If all parameters are NULL, the function flushes the cache. While the system is editing the cached version of the file, processes that edit the file itself will use the original file until the cache has been cleared. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In this case, the  function writes information to the registry, not to the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "BOOL WINAPI",
    "category": "Registry",
    "name": "WritePrivateProfileSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section in which data is written. This section name is typically the name of the calling application."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and lpFileName does not contain a full path, the function creates the file in the Windows directory.  If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Copies a string into the specified section of an initialization file.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function successfully copies the string to the initialization file, the return value is nonzero. If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "A section in the initialization file must have the following form: If the lpFileName parameter does not contain a full path and file name for the file,  WritePrivateProfileString searches the Windows directory for the file. If the file does not exist, this function creates the file in the Windows directory. If lpFileName contains a full path and file name and the file does not exist,  WritePrivateProfileString creates the file. The specified directory must already exist. The system keeps a cached version of the most recent registry file mapping to improve performance. If all parameters are NULL, the function flushes the cache. While the system is editing the cached version of the file, processes that edit the file itself will use the original file until the cache has been cleared. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In this case, the  function writes information to the registry, not to the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: An application using the WritePrivateProfileString function to enter .ini file information into the registry should follow these guidelines: The following sample code illustrates the preceding guidelines and is based on several assumptions: ",
    "return_type": "BOOL WINAPI",
    "category": "Registry",
    "name": "WritePrivateProfileString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpKeyName",
        "description": "The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries within the section, is deleted."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpFileName",
        "description": "The name of the initialization file. If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data. The  GetPrivateProfileStruct function uses the checksum to ensure the integrity of the data.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function successfully copies the string to the initialization file, the return value is nonzero. If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "A section in the initialization file must have the following form: If the szFile parameter does not contain a full path and file name for the file,  WritePrivateProfileString searches the Windows directory for the file. If the file does not exist, this function creates the file in the Windows directory. If szFile contains a full path and file name and the file does not exist,  WriteProfileString creates the file. The specified directory must already exist. The system keeps a cached version of the most recent registry file mapping to improve performance. If all parameters are NULL, the function flushes the cache. While the system is editing the cached version of the file, processes that edit the file itself will use the original file until the cache has been cleared. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In this case, the  function writes information to the registry, not to the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "BOOL WINAPI",
    "category": "Registry",
    "name": "WritePrivateProfileStruct",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszSection",
        "description": "The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case independent, the string can be any combination of uppercase and lowercase letters."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpszKey",
        "description": "The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all keys and entries within the section, is deleted."
      },
      {
        "in_out": "_In_",
        "type": "LPVOID",
        "name": "lpStruct",
        "description": "The data to be copied. If this parameter is NULL, the key is deleted."
      },
      {
        "in_out": "_In_",
        "type": "UINT",
        "name": "uSizeStruct",
        "description": "The size of the buffer pointed to by the lpStruct parameter, in bytes."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "szFile",
        "description": "The  name of the initialization file. If this parameter is NULL, the information is copied into the Win.ini file. If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 2,
    "description": "Replaces the contents of the specified section in the Win.ini file with specified keys and values. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "Keys and values in the lpString buffer consist of one or more null-terminated strings, followed by a final null character. Each string has the following form: key=string. The  WriteProfileSection function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters. WriteProfileSection deletes the existing keys and values for the named section and inserts the key names and values in the buffer pointed to by lpString. The function does not attempt to correlate old and new key names; if the new names appear in a different order from the old names, any comments associated with preexisting keys and values in the initialization file will probably be associated with incorrect keys and values. This operation is atomic; no other operations that read from or write to the initialization file are allowed while the information is being written. The system keeps a cached version of the most recent registry file mapping to improve performance. If all parameters are NULL, the function flushes the cache. While the system is editing the cached version of the file, processes that edit the file itself will use the original file until the cache has been cleared. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: When the operation has been mapped, the  WriteProfileSection function writes information to the registry, not to the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "BOOL WINAPI",
    "category": "Registry",
    "name": "WriteProfileSection",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The name of the section. This section name is typically the name of the calling application."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes. If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Copies a string into the specified section of the Win.ini file. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.",
    "library": "Kernel32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winbase.h (include Windows.h)",
    "return_value": "If the function successfully copies the string to the Win.ini file, the return value is nonzero. If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call  GetLastError. ",
    "remarks": "A section in the Win.ini file must have the following form: key=string. The system keeps a cached version of the most recent registry file mapping to improve performance. If all parameters are NULL, the function flushes the cache. While the system is editing the cached version of the file, processes that edit the file itself will use the original file until the cache has been cleared. The system maps most .ini file references to the registry, using the mapping defined under the following registry key: When the operation has been mapped, the  WriteProfileString function writes information to the registry, not to the initialization file; the change in the storage location has no effect on the function's behavior. The profile functions use the following steps to locate initialization information: When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping: ",
    "return_type": "BOOL WINAPI",
    "category": "Registry",
    "name": "WriteProfileString",
    "is_callback": 0,
    "dll": "Kernel32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpAppName",
        "description": "The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpKeyName",
        "description": "The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries in the section, is deleted."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpString",
        "description": "A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Creates the specified registry key. If the key already exists in the registry, the function opens it.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "An application cannot create a key that is a direct child of HKEY_USERS or HKEY_LOCAL_MACHINE. An application can create subkeys in lower levels of the HKEY_USERS or HKEY_LOCAL_MACHINE trees. If your service or application impersonates different users, do not use this function with HKEY_CURRENT_USER. Instead, call the RegOpenCurrentUser function. The RegCreateKey function creates all missing keys in the specified path. An application can take advantage of this behavior to create several keys at once. For example, an application can create a subkey four levels deep at the same time as the three preceding subkeys by specifying a string of the following form for the lpSubKey parameter: subkey1\\subkey2\\subkey3\\subkey4 Note that this behavior will result in creation of unwanted keys if an existing key in the path is spelled incorrectly. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegCreateKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The calling process  must have KEY_CREATE_SUB_KEY access to the key. For more information, see  Registry Key Security and Access Rights.     Access for key creation is checked against the security descriptor of the registry key, not the access mask specified when the handle was obtained. Therefore, even if hKey was opened with a samDesired of KEY_READ, it   can be used in operations that create keys if allowed by its security descriptor. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of a key that this function opens or creates. This key must be a subkey of the key identified by the hKey parameter.    For more information on key names, see Structure of the Registry. If hKey is one of the predefined keys, lpSubKey may be NULL. In that case, phkResult receives the same hKey handle passed in to the function."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened or created key. If the key is not one of the predefined registry keys, call the  RegCloseKey function after you have finished using the handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Enumerates the subkeys of the specified open registry key. The function retrieves the name of one subkey each time it is called.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If there are no more subkeys available, the function returns ERROR_NO_MORE_ITEMS. If the lpName buffer is too small to receive the name of the key, the function returns ERROR_MORE_DATA. ",
    "remarks": "To enumerate subkeys, an application should initially call the  RegEnumKey function with the dwIndex parameter set to zero. The application should then increment the dwIndex parameter and call the  RegEnumKey function until there are no more subkeys (meaning the function returns ERROR_NO_MORE_ITEMS). The application can also set dwIndex to the index of the last key on the first call to the function and decrement the index until the subkey with index 0 is enumerated. To retrieve the index of the last subkey, use the  RegQueryInfoKey. While an application is using the  RegEnumKey function, it should not make calls to any registration functions that might change the key being queried. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegEnumKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_ENUMERATE_SUB_KEYS access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwIndex",
        "description": "The index of the subkey of hKey to be retrieved. This value should be zero for the first call to the  RegEnumKey function and then incremented for subsequent calls.     Because subkeys are not ordered, any new subkey will have an arbitrary index. This means that the function may return subkeys in any order."
      },
      {
        "in_out": "_Out_",
        "type": "LPTSTR",
        "name": "lpName",
        "description": "A pointer to a buffer that receives the name of the subkey, including the terminating null character. This function copies only the name of the subkey, not the full key hierarchy, to the buffer.     For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cchName",
        "description": "The size of the buffer pointed to by the lpName parameter, in TCHARs. To determine the required buffer size, use the  RegQueryInfoKey function to determine the size of the largest subkey for the key identified by the hKey parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 3,
    "description": "Opens the specified registry key.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "The  RegOpenKey function uses the default security access mask to open a key. If opening the key requires a different access right, the function fails, returning ERROR_ACCESS_DENIED. An application should use the  RegOpenKeyEx function to specify an access mask in this situation. RegOpenKey does not create the specified key if the key does not exist in the database. If your service or application impersonates different users, do not use this function with HKEY_CURRENT_USER. Instead, call the RegOpenCurrentUser function. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegOpenKey",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. This handle is returned by the  RegCreateKeyEx or  RegOpenKeyEx function, or it can be one of the following  predefined keys:  HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the registry key to be opened. This key must be a subkey of the key identified by the hKey parameter.  Key names are not case sensitive. If this parameter is NULL or a pointer to an empty string, the function returns the same handle that was passed in. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_Out_",
        "type": "PHKEY",
        "name": "phkResult",
        "description": "A pointer to a variable that receives a handle to the opened key. If the key is not one of the predefined registry keys, call the  RegCloseKey function after you have finished using the handle."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 4,
    "description": "Retrieves the data associated with the default or unnamed value of a specified registry key. The data must be a null-terminated string.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a  system error code. If the lpValue buffer is too small to receive the value, the function returns ERROR_MORE_DATA. ",
    "remarks": "If the ANSI version of this function is used (either by explicitly calling RegQueryValueA or by not defining UNICODE before including the Windows.h file), this function converts the stored Unicode string to an ANSI string before copying it to the buffer specified by the lpValue parameter. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, the string may not have been stored with the proper null-terminating characters.  Therefore, even if the function returns ERROR_SUCCESS, the application should ensure that the string is properly terminated before using it; otherwise, it may overwrite a buffer. (Note that REG_MULTI_SZ strings should have two null-terminating characters.) Note that operations that access certain registry keys are redirected. For more information,  see Registry Virtualization and 32-bit and 64-bit Application Data in the Registry. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegQueryValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of the subkey of the hKey parameter for which the default value is retrieved.  Key names are not case sensitive. If this parameter is NULL or points to an empty string, the function retrieves the default value for the key identified by hKey. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_Out_opt_",
        "type": "LPTSTR",
        "name": "lpValue",
        "description": "A pointer to a buffer that receives the default value of the specified key.     If lpValue is NULL, and lpcbValue is non-NULL, the function returns ERROR_SUCCESS, and stores the size of the data, in bytes, in the variable pointed to by lpcbValue. This enables an application to determine the best way to allocate a buffer for the value's data."
      },
      {
        "in_out": "_Inout_opt_",
        "type": "PLONG",
        "name": "lpcbValue",
        "description": "A pointer to a variable that specifies the size of the buffer pointed to by the lpValue parameter, in bytes. When the function returns, this variable contains the size of the data copied to lpValue, including any terminating null characters.     If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, this size includes any terminating null character or characters. For more information, see Remarks. If the buffer specified lpValue is not large enough to hold the data, the function returns ERROR_MORE_DATA and stores the required buffer size in the variable pointed to by lpcbValue. In this case, the contents of the lpValue buffer are undefined."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  },
  {
    "n_arguments": 5,
    "description": "Sets the data for the default or unnamed value of a specified registry key. The data must be a text string.",
    "library": "Advapi32.lib",
    "min_server": "Windows 2000 Server [desktop apps only]",
    "header": "Winreg.h (include Windows.h)",
    "return_value": "If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the  FormatMessage function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error. ",
    "remarks": "If the key specified by the lpSubKey parameter does not exist, the  RegSetValue function creates it. If the ANSI version of this function is used (either by explicitly calling RegSetValueA or by not defining UNICODE before including the Windows.h file), the lpData parameter must be an ANSI character string. The string is converted to Unicode before it is stored in the registry. ",
    "return_type": "LONG WINAPI",
    "category": "Registry",
    "name": "RegSetValue",
    "is_callback": 0,
    "dll": "Advapi32.dll",
    "arguments": [
      {
        "in_out": "_In_",
        "type": "HKEY",
        "name": "hKey",
        "description": "A handle to an open registry key. The key must have been opened with the KEY_SET_VALUE access right. For more information, see  Registry Key Security and Access Rights.     This handle is returned by the  RegCreateKeyEx, RegCreateKeyTransacted, RegOpenKeyEx, or  RegOpenKeyTransacted function. It can also be one of the following  predefined keys: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS"
      },
      {
        "in_out": "_In_opt_",
        "type": "LPCTSTR",
        "name": "lpSubKey",
        "description": "The name of a subkey of the hKey parameter. The function sets the default value of the specified subkey. If lpSubKey does not exist, the function creates it. Key names are not case sensitive. If this parameter is NULL or points to an empty string, the function sets the default value of the key identified by hKey. For more information, see  Registry Element Size Limits."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "dwType",
        "description": "The type of information to be stored. This parameter must be the REG_SZ type. To store other data types, use the  RegSetValueEx function."
      },
      {
        "in_out": "_In_",
        "type": "LPCTSTR",
        "name": "lpData",
        "description": "The data to be stored. This parameter cannot be NULL."
      },
      {
        "in_out": "_In_",
        "type": "DWORD",
        "name": "cbData",
        "description": "This parameter is ignored. The function calculates this value based on the size of the data in the lpData parameter."
      }
    ],
    "min_client": "Windows 2000 Professional [desktop apps only]"
  }
]

